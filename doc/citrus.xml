<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="citrus">

<TitlePage>
  <Title>The <Package>Citrus</Package> Package</Title>

  <Version>Version 0.1</Version>
  
  <Author>J. D. Mitchell <Email>jdm3@st-and.ac.uk</Email></Author>
  
  <Copyright>&copyright; 2011 J. D. Mitchell.<P/></Copyright>

  <Colophon>
  This manual describes the &GAP; 4.5 package <Package>Citrus</Package> version
  0.1 for computing with transformation semigroups. 
  </Colophon>

  <Acknowledgements>
    I would like to thank P. von Bunau, A. Distler, S. Linton, J. 
    Neubueser, V. Maltcev, M. R. Quick, E. F. Robertson, and N. Ruskuc for
    their help and suggestions. Special thanks go to J. Araujo for his 
    mathematical suggestions and to M. Neuhoeffer for his invaluable help in
    improving the efficiency of the package. <P/>

    I would also like to acknowledge the support of the Centre of Algebra at 
    the University of Lisbon, and of EPSRC grant number GR/S/56085/01. 
    <Br/><Br/>
    </Acknowledgements>
</TitlePage>

<TableOfContents/>

<Body>
  <Chapter Label="citrus">
  <Heading>The <Package>Citrus</Package> package</Heading>
	
  <Section><Heading>Overview and Introduction</Heading>
    This is the manual for the <Package>Citrus</Package> package version 0.1 
    for computing with
    transformation semigroups. <Package>Citrus</Package> 0.1 is an updated 
    version of the <Package>Monoid</Package>
    package for &GAP; 3 and 4; see
    <P/><URL>schmidt.nuigalway.ie/monoid/index.html</URL><P/>
    <Alt Only="LaTeX">\noindent</Alt>
    for more information about the original <Package>Monoid</Package> package 
    for &GAP; 3 by Goetz
    Pfeiffer and Steve A. Linton, Edmund F. Robertson and Nik Ruskuc, or
    <P/><URL>www-history.mcs.st-and.ac.uk/~jamesm/monoid/index.html
    </URL><P/>
    <Alt Only="LaTeX">\noindent</Alt> for more information about 
    <Package>Monoid</Package> 3.1.4 for &GAP; 4.

    The functionality of <Package>Monoid</Package> 3.1.4 has been split across 
    two &GAP; 4.5 packages
    <Package>Citrus</Package> and <Package>Comatose</Package>.

    <Package>Citrus</Package> 0.1 retains all the functionality of the original
    <Package>Monoid</Package> package for
    &GAP; 3; and those functions from <Package>Monoid</Package> 3.1.4 not 
    involved in the 
    computation of
    automorphism groups of semigroups. The <Package>Comatose</Package> package 
    retains those
    functions from <Package>Monoid</Package> 3.1.4 used to compute
    automorphism groups of transformation semigroups. See<P/>
    <URL>
      www-history.mcs.st-and.ac.uk/~jamesm/comatose/index.html
     </URL><P/>

    <Alt Only="LaTeX">\noindent</Alt> <Package>Citrus</Package> 0.1 contains 
    more efficient methods than those 
    available in the &GAP; library for calculating Green's classes, finding the
    size, the elements, and testing membership in transformation semigroups;
    see Chapter <Ref Chap="green"/>. 
    After <Package>Citrus</Package> has been loaded many of these methods are
    automatically used in preference to those in the library and do not need to 
    be called explicitly by the user.
    In addition, there are methods for testing if a semigroup satisfies a
    particular property, such as if it is regular, simple, inverse, or 
    completely regular; see Chapter <Ref Chap="properties"/>.<P/>

    <Alt Only="LaTeX">\noindent</Alt> The <Package>Citrus</Package> package is 
    written in &GAP; code only but requires the <Package>Orb</Package> 
    package.
    <Package>Orb</Package> is used to provide efficient methods for computing 
    orbits in transformation semigroups that underpin most of the features of 
    <Package>Citrus</Package>. See:<P/>
    <URL>
    www-groups.mcs.st-and.ac.uk/~neunhoef/Computer/Software/Gap/orb.html
    </URL><P/>
    <Alt Only="LaTeX">\noindent</Alt> or the main &GAP; webpages for more 
    information.
  
  </Section>

  <Section Label="install">
    <Heading>Installing <Package>Citrus</Package></Heading>

    In this section we give a brief description of how to start using  
    <Package>Citrus</Package>. If you have any problems getting
    <Package>Citrus</Package> working, then you could try emailling me at
    <Email>jdm3@st-and.ac.uk</Email>. <P/>

    It is assumed that you have a working copy of &GAP; with version number 
    4.5 or higher. The most up-to-date version of &GAP; and instructions on
    how to install it can be obtained from the main &GAP; webpage
   <P/> 
    <URL>
      www.gap-system.org
    </URL>.<P/>

    <Alt Only="LaTeX">\noindent</Alt> The following is a summary of the steps 
    that should lead to a successful
    installation of <Package>Citrus</Package>:

    <List>
    
      <Item> download and install the <Package>Orb</Package> package version 
      3.7 or higher. For more details go to:
      <P/><URL>
   www-groups.mcs.st-and.ac.uk/~neunhoef/Computer/Software/Gap/orb.html
      </URL><P/>
      <Alt Only="LaTeX">\noindent</Alt> Note that both <Package>Orb</Package>
      and <Package>Citrus</Package> are faster if <Package>Orb</Package>
      is compiled. 
      </Item>
    
      <Item> download the package archive <C>citrus0r1.tar.gz</C> or 
      <C>citrus0r1.tar.bz2</C> from <URL>JDM</URL></Item>
    
      <Item> unzip and untar the file, this should create a directory called
      <C>citrus</C>.</Item>
    
      <Item> 
      locate the <C>pkg</C> directory of your &GAP; directory, which contains
      several other directories such as <C>lib</C>, <C>doc</C> and so on. Move 
      the directory <C>citrus</C> into the <C>pkg</C> directory
      </Item>
    
      <Item> start &GAP; in the usual way</Item>
    
      <Item> type <C>LoadPackage("citrus");</C></Item>
    
    </List>

    Below is an example of an installation of <Package>Citrus</Package> in a
    UNIX environment where <C>GAPROOT</C>  should be substituted with the main 
    &GAP; directory 
    (the one containing the folders <C>bin</C>, <C>lib</C>, and so on) in
    your installation of &GAP;.<P/>

    <Log>
> gunzip citrus0r1.tar.gz 
> tar -xf citrus0r1.tar 
> mv citrus GAPROOT/pkg
> gap 

[ ... ]

gap> LoadPackage("citrus");
----------------------------------------------------------------------
Loading  orb 3.7 (orb - Methods to enumerate orbits)
by Juergen Mueller (http://www.math.rwth-aachen.de/~Juergen.Mueller),
   Max Neunhoeffer (http://www-groups.mcs.st-and.ac.uk/~neunhoef), and
   Felix Noeske (http://www.math.rwth-aachen.de/~Felix.Noeske).
----------------------------------------------------------------------
----------------------------------------------------------------------
Loading  Citrus 0.1 (Citrus - ComputIng with TransfoRmation semigrUopS)
by J. D. Mitchell (http://tinyurl.com/jdmitchell).
----------------------------------------------------------------------
true
gap> </Log>

    Presuming that the above steps can be completed successfully you will be 
    running the <Package>citrus</Package> package!<P/>

    If you want to check that the package is working correctly, please see
    Section <Ref Sect="testing"/>.<P/>

    <B>Please note:</B> before you can used <Package>citrus</Package> you must
    install <Package>orb</Package> version 3.7 or higher as described above.

  </Section>

  <Section Label="testing"><Heading>Testing the installation</Heading>

    In this section we describe how to test that <Package>Citrus</Package> is
    working as intended.  To test that <Package>Citrus</Package> is installed 
    correctly use <Ref Func="CitrusTestInstall"/> or for more extensive tests
    use <Ref Func="CitrusTestAll"/>. Please note that it will take a few moments
    for <Ref Func="CitrusTestInstall"/> to finish and it will take a few minutes
    for <Ref Func="CitrusTestAll"/> to finish.<P/>

    If something goes wrong, then please review the instructions in Section 
    <Ref Sect="install"/> and ensure that <Package>Citrus</Package> has been 
    properly installed.  If you continue having problems, please email me at 
    <Email>jdm3@st-and.ac.uk</Email>.

  </Section>

</Chapter>

<Chapter Label="Transformations and Actions">
  <Heading>Transformations and Actions</Heading>

    The functions described in this section extend the functionality of &GAP;
    relating to transformations; see also 
    <Ref Chap="Transformations" BookName="ref"/>.

  <Section><Heading>Creating Transformations</Heading>
    In this section we describe the functions available in
    <Package>Citrus</Package> for creating transformations. 
    The following functions from the &GAP; reference manual are particularly
    relevant to this section:
    <Ref Func="Transformation" BookName="ref"/>, 
    <Ref Func="IdentityTransformation" BookName="ref"/>, and 
    <Ref Func="RandomTransformation" BookName="ref"/>. 
    
    <#Include Label="ConstantTransformation"/> 	
    <#Include Label="Idempotent">
    <#Include Label="RandomIdempotent">
    <#Include Label="RandomTransformation">
    <!--<#Include Label="TransformationActionNC">-->
  </Section>

  <Section><Heading>Properties of Transformations</Heading>
    In this section we describe the functions available in
    <Package>Citrus</Package> for finding various properties of 
    transformations. <P/>

    <Package>Citrus</Package> also contains a special method for
   <Ref Attr="RankOfTransformation" BookName="ref"/>. 

    <!--IsInjectiveTransOfList-->
    <#Include Label="CanonicalTransSameKernel">
    <#Include Label="IndexPeriodOfTransformation">
    <#Include Label="InversesOfTransformation">
    <#Include Label="IsRegularTransformation">
    <#Include Label="Random"/><!--JDM move this?-->
    <#Include Label="SmallestIdempotentPower">
  </Section>

  <Section><Heading>Operators</Heading>
    <Index Key="^"><C>^</C></Index>
   <C><A>f</A> ^ <A>g</A></C>
    <P/>
    <Index Key="*"><C>*</C></Index>
    <C><A>f</A> * <A>g</A></C>
    <P/>
    
    <Package>Citrus</Package> contains more efficient methods than the &GAP;
    library for <Ref Oper="\*" BookName="ref"/> when <A>f</A> and <A>g</A> are
    transformations or permutations (and at least one of <A>f</A> and <A>g</A>
    is a transformation).<P/>

     <C>f^g</C> returns <C><A>g</A>^-1*<A>f</A>*<A>g</A></C> when <A>f</A> is a
     transformation and <A>g</A> is a permutation 
     <Ref Oper="\^" BookName="ref"/>.

  </Section>

  <Section><Heading>Changing representation</Heading>
  
    <#Include Label="AsPermOfKerImg">
    <#Include Label="AsPermutation">
  </Section>

  <Section><Heading>Actions and Orbits</Heading>

    <!--In <Package>Citrus</Package>, there are essentially two important types 
    of orbits used to compute with transformation semigroups. Let 
    <Math>S</Math> be a semigroup of transformations on the set 
    <Math>\Omega=\{1,2,\ldots, n\} </Math>. The first is the action of the 
    <P/> JDM...-->

    The following are used by <Package>Citrus</Package> in 
    the computation of Green's 
    relations and to test if an arbitrary transformation semigroup has a 
    particular property;  see Chapter <Ref Chap="green"/> and Chapter 
    <Ref Chap="properties"/>.<P/>

    In addition to the actions define in the reference manual
    <Ref Sect="Basic Actions" BookName="ref"/> the following two actions are 
    available in <Package>Citrus</Package>.
    
    <#Include Label="GradedImagesOfTransSemigroup">
    <#Include Label="StrongOrbitsInForwardOrbit">
    <#Include Label="ImagesOfTransSemigroup">
  </Section>	

</Chapter>

<Chapter Label="green"><Heading>Green's Relations</Heading>
  
  <Section><Heading>Introduction</Heading>
    
    This chapter contains instructions on how to use the functions implemented 
    in <Package>Citrus</Package> for
    computing Green's relations and related notions for transformation         
    semigroups and monoids.  
    <P/>
		
    The theory behind these algorithms is developed in <Cite Key="pfeiffer1"/>
    and the algorithms themselves are more or less described in 
    <Cite Key="pfeiffer2"/>.
    Another reference is <Cite Key="lallement"/>.<P/>

    Green's relations can be calculated when  <Package>Citrus</Package>
    is loaded using the same commands that you would used when 
    <Package>Citrus</Package> is not loaded; see <Ref Chap="Semigroups" 
    BookName="ref"/>. For example, in &GAP; with the <Package>Citrus</Package>  
    package loaded:
    
    <Log>
      gap> s:=Semigroup(Transformation([2,1,1,2,1]), 
      > Transformation([3,4,3,4,4]),
      > Transformation([3,4,3,4,3]),
      > Transformation([4,3,3,4,4]));;
      gap> GreensRClasses(s);
      [ {Transformation( [ 2, 1, 1, 2, 1 ] )}, 
        {Transformation( [ 1, 2, 1, 2, 2 ] )}, 
        {Transformation( [ 1, 2, 1, 2, 1 ] )}, 
        {Transformation( [ 2, 1, 1, 2, 2 ] )} ]</Log>
    
    Without the <Package>Citrus</Package> package loaded:
    
    <Log>
      gap> s:=Semigroup(Transformation([2,1,1,2,1]), 
      > Transformation([3,4,3,4,4]),
      > Transformation([3,4,3,4,3]),
      > Transformation([4,3,3,4,4]));;
      gap> GreensRClasses(s);
      [ {Transformation( [ 1, 2, 1, 2, 1 ] )}, 
        {Transformation( [ 1, 2, 1, 2, 2 ] )},
        {Transformation( [ 1, 2, 2, 1, 1 ] )}, 
        {Transformation( [ 1, 2, 2, 1, 2 ] )} ]</Log>
		
    The only noticable differences are the representatives of the classes and 
    the order the classes appear in the list. These differences are caused by 
    the differences in the methods for 
    <Ref Attr="GreensRClasses" BookName="ref"/> in the &GAP; library and 
    <Ref Attr="GreensRClasses" Label="CitrusRClasses"/> in 
    <Package>Citrus</Package>.<P/>
		
    For more details about Green's relations see 
    <Ref Sect="Green's Relations" BookName="ref"/>.<P/>
		
    Due to inherent difficulties with computing Green's
    <Math>\mathcal{L}</Math>-, <Math>\mathcal{D}</Math>-, and
    <Math>\mathcal{H}</Math>-classes in
    transformation semigroups, the 
    methods used to compute with Green's <Math>\mathcal{R}</Math>-classes are 
    the most efficient 
    in <Package>Citrus</Package>.  Thus wherever possible it is advisable to
    use the commands relating to Green's <Math>\mathcal{R}</Math>-classes 
    rather than those relating
    to Green's <Math>\mathcal{L}</Math>-,
    <Math>\mathcal{D}</Math>-, or <Math>\mathcal{H}</Math>-classes.<P/>
		
    The methods in <Package>Citrus</Package> allow the computation of     
    individual Green's classes without the need to compute all the elements of 
    the underlying semigroup; see <Ref Oper="GreensRClassOfElementNC"/>.  
    It is also possible to compute all the 
    <Math>\mathcal{R}</Math>-classes, the number of elements and test 
    membership in a transformation 
    semigroup without computing all the elements; see, for example, 
    <Ref Oper="GreensRClasses" Label="CitrusRClasses"/>, <Ref
    Attr="GreensRClassReps"/>, <Ref Func="IteratorOfRClassReps"/>, 
    <Ref Func="IteratorOfGreensRClasses"/>, or <Ref Func="NrGreensRClasses"/>.
    This may be useful if you 
    want to study a very large semigroup where computing all the elements of 
    the semigroup is infeasible. 
  </Section>

  <Section>
    <Heading>
      New methods for existing &GAP; functions
    </Heading>

      In this section we list the functions from the &GAP; library (those
      available when <Package>Citrus</Package> is not loaded) which have
      new methods in <Package>Citrus</Package>.  Some of these new methods 
      apply to a wider class of objects than the existing methods. Where this
      is the case, we give references to both the <Package>Citrus</Package> 
      documentation and the &GAP;  manual; otherwise we may only give
      references to the &GAP; manual.<P/>
 
    <Package>Citrus</Package> contains special methods for the following
    &GAP; functions where the argument is an arbitrary Green's class
    of a transformation semigroup 
    (specifically a  Green's class satisfying <Ref
    Prop="IsGreensClassOfTransSemigp"/>) or a transformation semigroup itself
    (where appropriate): 
    <Ref Oper="\&lt;"/>, <C>=</C> and <C>in</C> (see  
    <Ref Sect="Comparisons" BookName="ref"/>),
    <Ref Oper="AsSSortedList" BookName="ref"/>, 
    <Ref Oper="Enumerator" BookName="ref"/>, 
    <Ref Attr="GreensHClasses" BookName="ref"/> and 
    <Ref Attr="GreensHClasses" Label="CitrusHClasses"/>,
    <Ref Attr="GreensHClassOfElement" BookName="ref"/>,
    <Ref Attr="GreensLClasses" BookName="ref"/> and 
    <Ref Attr="GreensLClasses" Label="CitrusLClasses"/>,
    <Ref Attr="GreensLClassOfElement" BookName="ref"/>,
    <Ref Attr="GreensRClasses" BookName="ref"/> and 
    <Ref Attr="GreensRClasses" Label="CitrusRClasses"/>,
    <Ref Attr="GreensRClassOfElement" BookName="ref"/>,
    <Ref Attr="GreensDClasses" BookName="ref"/> and
    <Ref Attr="GreensDClasses" Label="CitrusDClasses"/>,
    <Ref Attr="GreensDClassOfElement" BookName="ref"/>,
    <Ref Attr="Idempotents" BookName="ref"/> and 
    <Ref Attr="Idempotents" Label="CitrusIdempotents"/>, 
    and <Ref Oper="Size" BookName="ref"/>. 
    <P/>

    In addition to those functions mentioned above that can be
    applied to all Green's classes, <Package>Citrus</Package> contains 
    special methods for the following
    &GAP; functions:
    <Ref Prop="IsRegularDClass" BookName="ref"/> and 
    <Ref Prop="IsRegularDClass" Label="CitrusIsRegularDClass"/>,
    <Ref Attr="GroupHClassOfGreensDClass" BookName="ref"/> and 
    <Ref Attr="GroupHClass"/>, 
    <Ref Prop="IsGroupHClass" BookName="ref"/>,
    <Ref Oper="IsomorphismPermGroup" BookName="ref"/> 
    (for a group <Math>\mathcal{H}</Math>-class), and
    <Ref Oper="StructureDescription" BookName="ref"/> 
    (for a group <Math>\mathcal{H}</Math>-class).
    <P/>

  </Section>

  <Section><Heading>Green's classes</Heading>
    
    <#Include Label="\&lt;">
    <#Include Label="XClassOfYClass">
    <#Include Label="GreensXClasses">
    <#Include Label="GreensXClassOfElementNC">
    <#Include Label="GreensXClassReps">
    <#Include Label="GroupHClass">
    <#Include Label="Idempotents">
    <#Include Label="IsGreensClassOfTransSemigp">
    
    <#Include Label="IsRegularXClass">
    <#Include Label="IteratorOfXClassReps"> 
    <#Include Label="IteratorOfGreensXClasses"> 
    <#Include Label="NrGreensXClasses">
    <#Include Label="NrIdempotents">
    <#Include Label="NrRegularDClasses">
    <#Include Label="PartialOrderOfDClasses">
    <#Include Label="SchutzenbergerGroup">
    <#Include Label="UnderlyingSemigroupOfIterator">
  </Section>
</Chapter>

<Chapter Label="properties"> <Heading>Properties of semigroups</Heading>
  <Section><Heading>Definitions</Heading>
		
    In this section we give the theoretical results and the corresponding 
    &GAP; functions that can be used to determine whether a set of
    transformations generates a semigroup of a given type. Let <Math>S</Math> 
    be a semigroup. Then:
    
    <List>
      
      <Item> <Math>S</Math> is a <E>left zero semigroup</E> if 
      <Math>(\forall s,t\in S)(st=s).</Math>
      </Item>
      
      <Item> <Math>S</Math> is a <E>right zero semigroup</E> if 
      <Math>(\forall s,t\in S)(st=t).</Math>
      </Item>
      
      <Item><Math>S</Math> is <E>commutative</E> if <Math>(\forall 
       s,t\in S)(st=ts)</Math>.
      </Item>
      
      <Item> <Math>S</Math> is <E>simple</E> if it has no proper two-sided 
      ideals.
      </Item>
			
      <Item> <Math>S</Math> is <E>regular</E> if <Math>(\forall s\in S)
      (\exists t\in S)(sts=s).</Math>
      </Item>
			
      <Item> <Math>S</Math> is <E>completely regular</E> if every element of   
      <Math>S</Math> lies in a subgroup. 
      </Item>
			
      <Item> <Math>S</Math> is an <E>inverse semigroup</E> if 
      <Math>(\forall s\in S)(\exists! t\in S)(sts=s \wedge tst=t).</Math>
      </Item>
			
      <Item> <Math>S</Math> is a <E>Clifford semigroup</E> if 
      <Math>(\forall s\in S)(\exists t\in S)(sts=s)\wedge(\forall 
      s, t\in S)(s^2=s\rightarrow st=ts).</Math>
      </Item>
			
      <Item> <Math>S</Math> is a <E>band</E> if <Math>(\forall s\in S)
      (s^2=s)</Math>.
      </Item>
      
      <Item> <Math>S</Math> is a <E>rectangular band</E> if 
      <Math>(\forall x,y,z\in S)(x^2=x\wedge xyz=xz).</Math>
      </Item>
			
      <Item> <Math>S</Math> is a <E>idempotent generated</E> if it is generated 
      by its idempotent elements.
      </Item>
      
      <Item> <Math>S</Math> is an <E>orthodox semigroup</E> if it is regular 
      and idempotents form a subsemigroup.
      </Item>
			
      <Item><Math>S</Math> is a <E>zero semigroup</E> if 
      <Math>(\exists s\in S)(\forall t,u\in S)(tu=s).</Math>
      </Item>
			
      <Item><Math>S</Math> is a <E>zero group</E> if 
      <Math>(\exists s\in S)(\forall t\in S)(st=ts=s\wedge 
      S\setminus\{s\}\textrm{ is a group }).</Math>
      </Item>
    
    </List>
		
      The following results provide methods to determine if an 
      arbitrary transformation semigroup <Math>S</Math> satisfies a particular 
      property by considering the action of the generators of <Math>S</Math> on 
      the underlying set, rather than <Math>S</Math> itself. 
      For more details see  <Cite Key="largest"/>.<P/>

      Then the following hold:
      
      <List>
      
        <Item> <Math>S</Math> is a left zero semigroup if and only if  
        <Math>\textrm{im}(f)=\textrm{im}(g)</Math> and <Math>f^2=f</Math> for all 
        <Math>f, g\in\Omega</Math>.
        </Item>
        
        <Item> <Math>S</Math> is a right zero semigroup if and only if  
        <Math>\textrm{ker}(f)=\textrm{ker}(g)</Math> and <Math>f^2=f</Math> for
        all <Math>f, g\in\Omega</Math>.
        </Item>

        <Item> <Math>S</Math> is simple if and only if     
        <Math>\textrm{rank}(gf)=\textrm{rank}(f)=\textrm{rank}(g)</Math> 
        for all <Math>f, g\in\Omega</Math>.
        </Item>
        
        <Item> <Math>S</Math> is completely regular if and only if 
        <Math>\textrm{rank}(fgf)=\textrm{rank}(gf)</Math> 
        for all <Math>f, g\in\Omega</Math>.
        </Item>
        
        <Item> <Math>S</Math> is inverse if and only if it is regular and 
        there is a bijection <Math>\phi:\textrm{Kers}(S)\to\textrm{Ims}(S)
        </Math> such that if <Math>f\in S</Math> with 
        <Math>\textrm{im}(f)=\phi(\textrm{ker}(f))</Math>, then   
        <Math>\textrm{rank}(f^2)=\textrm{rank}(f)</Math>. 
        </Item>
        
        <Item> <Math>S</Math> is a Clifford semigroup if and only if for all  
        <Math>f, g\in\Omega</Math> 
        <List>
          <Item> <Math>\textrm{rank}(f^2)=\textrm{rank}(f)</Math>;
          </Item>
          <Item> if <Math>g^n</Math> is an idempotent, then 
          <Math>fg^n=g^nf</Math>.
          </Item> 
        </List>
        </Item>
      </List>

      It is straightforward to verify that <Math>S</Math> is a group if and 
      only if for all <Math>f, g\in\Omega</Math> 
      
      <List>
        
        <Item> <Math>\textrm{ker}(f)=\textrm{ker}(g)</Math>;
        </Item>
        
        <Item> <Math>\textrm{im}(f)=\textrm{im}(g)</Math>;
        </Item> 
        
        <Item> <Math>\textrm{rank}(f)=\textrm{rank}(g)</Math>.
        </Item> 
    
    </List>

  </Section>

  <Section><Heading>IsSuchAndSuchSemigroup</Heading>

    <#Include Label="IsBand">
    <#Include Label="IsCliffordSemigroup">
    <#Include Label="IsCommutativeSemigroup">
    <#Include Label="IsCompletelyRegularSemigroup">
    <#Include Label="IsCompletelySimpleSemigroup">
    <#Include Label="IsGroupAsSemigroup">
    <#Include Label="IsInverseSemigroup">
    <#Include Label="IsLeftZeroSemigroup">
    <#Include Label="IsOrthodoxSemigroup">
    <#Include Label="IsRectangularBand">
    <#Include Label="IsRegularSemigroup">
    <#Include Label="IsRightZeroSemigroup">
    <#Include Label="IsSemiBand">
    <#Include Label="IsZeroGroup">
    <#Include Label="IsZeroSemigroup">
    <#Include Label="MultiplicativeZero">

  </Section>

</Chapter>

<Chapter Label="convenience"><Heading>Utilities and shortcuts</Heading>

  <Section><Heading>Overview</Heading>
    There are several commands in <Package>Citrus</Package> that can be called
    using shorter names than the original 
    commands in &GAP;. These functions are described below. 
  </Section>

  <Section><Heading>Utilities</Heading>
    <#Include Label="CitrusMakeDoc">
    <#Include Label="CitrusTestAll">
    <#Include Label="CitrusTestInstall">
    <#Include Label="CitrusTestManualExamples">
  </Section>

  <Section><Heading>Shortcuts</Heading>
    <#Include Label="DClass">
    <#Include Label="DClassNC">
    <#Include Label="Degree">
    <#Include Label="Generators">
    <#Include Label="HClass">
    <#Include Label="HClassNC">
    <#Include Label="LClass">
    <#Include Label="LClassNC">
    <#Include Label="Rank">
    <#Include Label="RandomTransformationMonoid">
    <#Include Label="RClass">
    <#Include Label="RClassNC">
  </Section>
</Chapter>

<Chapter Label="glossary"><Heading>Glossary</Heading>

  This chapter contains a glossary of mathematical terms used throughout this
  manual.<P/>

  Let <Math>S</Math> be a semigroup and let <Math>\Omega</Math> be a set. Then
  an <E>left action</E> of <Math>S</Math> on <Math>\Omega</Math> is just a 
  function <Math>\Psi:S\times \Omega\to \Omega</Math> satisfying 
  
  <Alt Only="HTML">
    $$\Psi(s, \Psi(t, \alpha))=\Psi(st, \alpha).$$
  </Alt>

  <Alt Not="HTML">
    <Display>\Psi(s, \Psi(t, \alpha))=\Psi(st, \alpha).</Display> 
  </Alt>

  <E>Right actions</E> are defined analogously. The <E>(weak) orbit</E> of 
  <Math>\alpha \in \Omega</Math> under the action <Math>\Psi</Math> of 
  <Math>S</Math> is the set

  <Alt Not="HTML">
    <Display>
      Orb(S,\alpha)=\{\:\beta\in\Omega\::\:(\exists s\in S)
     (\Psi(s, \alpha)=\beta)\:\}.
    </Display>
  </Alt>

  <Alt Only="HTML">
    $$\textrm{Orb}_S(\alpha)=\{\:\beta\in\Omega\::\:(\exists s\in S)
    (\Psi(s, \alpha)=\beta)\:\}.$$
  </Alt>

  If <Math>S</Math> is a group, then <Math>\alpha\in \textrm{Orb}_S(\beta)</Math> 
  if and only if <Math>\beta\in \textrm{Orb}_S(\alpha)</Math>. However, if 
  <Math>S</Math> is not a group, then it is possible that 
  <Math>\alpha\in \textrm{Orb}_S(\beta)</Math> but 
  <Math>\beta\not \in \textrm{Orb}_S(\alpha)</Math>.<P/>

  The <E>strong orbit</E> of <Math>\alpha\in \Omega</Math> is the set 
  
  <Alt Not="HTML">
    <Display>\{\:\beta\in\Omega\::\:(\exists s,t\in S)(\Psi(s, \alpha)=\beta
      \wedge\Psi(t, \beta)=\alpha)\:\}.
    </Display>
  </Alt>
  
  <Alt Only="HTML">
    $$\{\:\beta\in\Omega\::\:(\exists s,t\in S)(\Psi(s, \alpha)=\beta \wedge 
    \Psi(t, \beta)=\alpha)\:\}.$$
  </Alt>
  
  Let <Math>S</Math> be a semigroup generated by a set of transformations 
  <Math>\Omega</Math> on a finite set. If <Math>f\in S</Math>, then denote the
  image  of <Math>f</Math> by <Math>\textrm{im}(f)</Math>. The <E>kernel</E> of 
  <Math>f\in S</Math> is 
  
  <Alt Not="HTML">
    <Display>\textrm{ker}(f)=\{\:(\alpha, \beta)\::\: f(\alpha)=f(\beta)\:\}
    </Display>
  </Alt>

  <Alt Only="HTML">
    $$\textrm{ker}(f)=\{\:(\alpha, \beta)\::\: f(\alpha)=f(\beta)\:\}$$
  </Alt>

  and the <E>rank</E> of <Math>f</Math> is simply 
  
  <Alt Not="HTML">
    <Display>\textrm{rank}(f)=|\textrm{im}(f)|.</Display>
  </Alt>

  <Alt Only="HTML">
    $$\textrm{rank}(f)=|\textrm{im}(f)|.$$
  </Alt>

  Let 
  
  <Alt Not="HTML">
    <Display>\textrm{Ims}(S)=\{\:\textrm{im}(f)\::\: f\in S\:\}</Display>
  </Alt>
  
  <Alt Only="HTML">
    $$\textrm{Ims}(S)=\{\:\textrm{im}(f)\::\: f\in S\:\}$$
  </Alt>

  and let
  
  <Alt Not="HTML">
    <Display>\textrm{Kers}(S)=\{\:\textrm{ker}(f)\::\: f\in S\:\}.</Display>
  </Alt>
  
  <Alt Only="HTML">
    $$\textrm{Kers}(S)=\{\:\textrm{ker}(f)\::\: f\in S\:\}.$$
  </Alt>

</Chapter>

</Body>

<Bibliography Databases="citrus" />
<TheIndex/>

</Book>
  
