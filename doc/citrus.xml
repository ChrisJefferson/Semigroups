<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd">
<!-- SizeScreen([80]); SetInfoLevel(InfoWarning, 0);
TestManualExamples(DirectoriesPackageLibrary("monoid","doc")[1]![1], 
"monoid.xml", ["../gap/autos.gd", "../gap/general.gd", "../gap/greens.gd", 
"../gap/orbits.gd", "../gap/properties.gd", "../gap/semigroups.gd", 
"../gap/semihomo.gd", "../gap/transform.gd", "../gap/isomorph.gd"] );-->

<Book Name="citrus">

<TitlePage>
  <Title>The <Package>Citrus</Package> Package</Title>

  <Version>Version 0.1</Version>
  
  <Author>J. D. Mitchell <Email>jdm3@st-and.ac.uk</Email></Author>
  
  <Copyright>&copyright; 2011 J. D. Mitchell.<P/></Copyright>

  <Colophon>
  This manual describes the &GAP; 4.5 package <Package>Citrus</Package> version
  0.1 for computing with transformation semigroups. 
  </Colophon>

  <Acknowledgements>
    I would like to thank P. von Bunau, A. Distler, S. Linton, J. 
    Neubueser, V. Maltcev, M. R. Quick, E. F. Robertson, and N. Ruskuc for
    their help and suggestions. Special thanks go to J. Araujo for his 
    mathematical suggestions and to M. Neuhoeffer for his invaluable help in
    improving the efficiency of the package. <P/>

    I would also like to acknowledge the support of the Centre of Algebra at 
    the University of Lisbon, and of EPSRC grant number GR/S/56085/01. 
    <Br/><Br/>
    </Acknowledgements>
</TitlePage>

<TableOfContents/>

<Body>
  <Chapter Label="citrus">
  <Heading>The <Package>citrus</Package> package</Heading>
	
  <Section><Heading>Overview and Introduction</Heading>
    This is the manual for the <Package>Citrus</Package> package version 0.1 
    for computing with
    transformation semigroups. <Package>Citrus</Package> 0.1 is an updated 
    version of the <Package>Monoid</Package>
    package for &GAP; 3 and 4; see

    <URL>http://schmidt.nuigalway.ie/monoid/index.html</URL><P/>

    for more information about the original <Package>Monoid</Package> package 
    for &GAP;
    3 by Goetz
    Pfeiffer and Steve A. Linton, Edmund F. Robertson and Nik Ruskuc, or

    http://www-history.mcs.st-and.ac.uk/~jamesm/monoid/index.html

    for more information about <Package>Monoid</Package> 3.1.4 for &GAP; 4.

    The functionality of <Package>Monoid</Package> 3.1.4 has been split across 
    two &GAP; 4.5 packages
    <Package>Citrus</Package> and <Package>Comatose</Package>.

    <Package>Citrus</Package> 0.1 retains all the functionality of the original
    <Package>Monoid</Package> package for
    &GAP; 3; and those functions from <Package>Monoid</Package> 3.1.4 not 
    involved in the 
    computation of
    automorphism groups of semigroups. The Comatose Package retains those
    functions from <Package>Monoid</Package> 3.1.4 used to compute
    automorphism groups of transformation semigroups. See

    <URL>
      http://www-history.mcs.st-and.ac.uk/~jamesm/comatose/index.html
     </URL><P/>

    <Package>Citrus</Package> 0.1 contains more efficient methods than those 
    available in the &GAP; library for calculating Green's classes, finding the
    size, the elements, and testing membership in transformation semigroups. 
    After <Package>Citrus</Package> has been loaded many of these methods are
    automatically used in preference to those in the library and do not need to 
    be called explicitly by the user.

    In addition, there are methods for testing if a semigroup satisfies a
    particular property, such as if it is regular, simple, inverse, or 
    completely regular.

    The <Package>Citrus</Package> package is written in &GAP; code only but
    requires the <Package>Orb</Package> 
    package.
    <Package>orb</Package> is used to provide efficient methods for computing 
    orbits in transformation semigroups that underpin most of the features of 
    <Package>Citrus</Package>. See:

    <URL>
    http://www-groups.mcs.st-and.ac.uk/~neunhoef/Computer/Software/Gap/orb.html
    </URL><P/>

    or the main &GAP; webpages for more information.
  
  </Section>

  <Section Label="install">
    <Heading>Installing <Package>Citrus</Package></Heading>

    In this section we give a brief description of how to start using  
    <Package>Citrus</Package>. If you have any problems getting
    <Package>Citrus</Package> working, then you could try emailling me at
    <Email>jdm3@st-and.ac.uk</Email>. <P/>

    It is assumed that you have a working copy of &GAP; with version number 
    4.5 or higher. The most up-to-date version of &GAP; and instructions on
    how to install it can be obtained from the main &GAP; webpage
    
    <URL>
      http://www.gap-system.org
    </URL>.<P/>

    The following is a summary of the steps that should lead to a successful
    installation of <Package>Citrus</Package>:

    <List>
    
      <Item> download and install the <Package>Orb</Package> package version 
      3.7 or higher. For more details go to:
      <URL>
    http://www-groups.mcs.st-and.ac.uk/~neunhoef/Computer/Software/Gap/orb.html
      </URL>
      Note that both <Package>Orb</Package> and
      <Package>Citrus</Package> are faster if <Package>Orb</Package>
      is compiled. 
      </Item>
    
      <Item> download the package archive <C>citrus0r1.tar.gz</C> or 
      <C>citrus0r1.tar.bz2</C> from <URL>JDM</URL></Item>
    
      <Item> unzip and untar the file, this should create a directory called
      <C>citrus</C>.</Item>
    
      <Item> 
      locate the <C>pkg</C> directory of your &GAP; directory, which contains
      several other directories such as <C>lib</C>, <C>doc</C> and so on. Move 
      the directory <C>citrus</C> into the <C>pkg</C> directory
      </Item>
    
      <Item> start &GAP; in the usual way</Item>
    
      <Item> type <C>LoadPackage("citrus");</C></Item>
    
    </List>

    Below is an example of an installation of <Package>Citrus</Package> in a
    UNIX environment where <C>GAPROOT</C>  should be substituted with the main 
    &GAP; directory 
    (the one containing the folders <C>bin</C>, <C>lib</C>, and so on) in
    your installation of &GAP;.<P/>

    <Log>
      > gunzip citrus0r1.tar.gz 
      > tar -xf citrus0r1.tar 
      > mv citrus GAPROOT/pkg
      > gap 

      [ ... ]

      gap> LoadPackage("citrus");
      ----------------------------------------------------------------------
      Loading  orb 3.7 (orb - Methods to enumerate orbits)
      by Juergen Mueller (http://www.math.rwth-aachen.de/~Juergen.Mueller),
         Max Neunhoeffer (http://www-groups.mcs.st-and.ac.uk/~neunhoef), and
         Felix Noeske (http://www.math.rwth-aachen.de/~Felix.Noeske).
      ----------------------------------------------------------------------
      ----------------------------------------------------------------------
      Loading  Citrus 0.1 (Citrus - ComputIng with TransfoRmation semigrUopS)
      by J. D. Mitchell (http://tinyurl.com/jdmitchell).
      ----------------------------------------------------------------------
      true
      gap> 
    </Log>

    Presuming that the above steps can be completed successfully you will be 
    running the <Package>citrus</Package> package!<P/>

    If you want to check that the package is working correctly, please see
    Section <Ref Sect="testing"/>.<P/>

    <B>Please note:</B> before you can used <Package>citrus</Package> you must
    install <Package>orb</Package> version 3.7 or higher as described above.

  </Section>

  <Section Label="testing"><Heading>Testing the installation</Heading>

    In this section we describe how to test that <Package>Citrus</Package> is
    working as intended.  To test that <Package>Citrus</Package> is installed 
    correctly use <Ref Func="CitrusTestInstall"/> or for more extensive tests
    use <Ref Func="CitrusTestAll"/>. Please note that it will take a few moments
    for <Ref Func="CitrusTestInstall"/> to finish and it will take a few minutes
    for <Ref Func="CitrusTestAll"/> to finish.<P/>

    If something goes wrong, then please review the instructions in Section 
    <Ref Sect="install"/> and ensure that <Package>Citrus</Package> has been 
    properly installed.  If you continue having problems, please email me at 
    <Email>jdm3@st-and.ac.uk</Email>.

  </Section>

</Chapter>

<Chapter Label="glossary"><Heading>Glossary</Heading>

  This chapter contains a glossary of mathematical terms used throughout this
  manual.<P/>

  Let <Math>S</Math> be a semigroup and let <Math>\Omega</Math> be a set. Then
  an <E>left action</E> of <Math>S</Math> on <Math>\Omega</Math> is just a 
  function <Math>\Psi:S\times \Omega\to \Omega</Math> satisfying 
  
  <Alt Only="HTML">
    $$\Psi(s, \Psi(t, \alpha))=\Psi(st, \alpha).$$
  </Alt>

  <Alt Not="HTML">
    <Display>\Psi(s, \Psi(t, \alpha))=\Psi(st, \alpha).</Display> 
  </Alt>

  <E>Right actions</E> are defined analogously. The <E>(weak) orbit</E> of 
  <Math>\alpha \in \Omega</Math> under the action <Math>\Psi</Math> of 
  <Math>S</Math> is the set

  <Alt Not="HTML">
    <Display>
      Orb(S,\alpha)=\{\:\beta\in\Omega\::\:(\exists s\in S)
     (\Psi(s, \alpha)=\beta)\:\}.
    </Display>
  </Alt>

  <Alt Only="HTML">
    $$\textrm{Orb}_S(\alpha)=\{\:\beta\in\Omega\::\:(\exists s\in S)
    (\Psi(s, \alpha)=\beta)\:\}.$$
  </Alt>

  If <Math>S</Math> is a group, then <Math>\alpha\in \textrm{Orb}_S(\beta)</Math> 
  if and only if <Math>\beta\in \textrm{Orb}_S(\alpha)</Math>. However, if 
  <Math>S</Math> is not a group, then it is possible that 
  <Math>\alpha\in \textrm{Orb}_S(\beta)</Math> but 
  <Math>\beta\not \in \textrm{Orb}_S(\alpha)</Math>.<P/>

  The <E>strong orbit</E> of <Math>\alpha\in \Omega</Math> is the set 
  
  <Alt Not="HTML">
    <Display>\{\:\beta\in\Omega\::\:(\exists s,t\in S)(\Psi(s, \alpha)=\beta
      \wedge\Psi(t, \beta)=\alpha)\:\}.
    </Display>
  </Alt>
  
  <Alt Only="HTML">
    $$\{\:\beta\in\Omega\::\:(\exists s,t\in S)(\Psi(s, \alpha)=\beta \wedge 
    \Psi(t, \beta)=\alpha)\:\}.$$
  </Alt>
  
  Let <Math>S</Math> be a semigroup generated by a set of transformations 
  <Math>\Omega</Math> on a finite set. If <Math>f\in S</Math>, then denote the
  image  of <Math>f</Math> by <Math>\textrm{im}(f)</Math>. The <E>kernel</E> of 
  <Math>f\in S</Math> is 
  
  <Alt Not="HTML">
    <Display>\textrm{ker}(f)=\{\:(\alpha, \beta)\::\: f(\alpha)=f(\beta)\:\}
    </Display>
  </Alt>

  <Alt Only="HTML">
    $$\textrm{ker}(f)=\{\:(\alpha, \beta)\::\: f(\alpha)=f(\beta)\:\}$$
  </Alt>

  and the <E>rank</E> of <Math>f</Math> is simply 
  
  <Alt Not="HTML">
    <Display>\textrm{rank}(f)=|\textrm{im}(f)|.</Display>
  </Alt>

  <Alt Only="HTML">
    $$\textrm{rank}(f)=|\textrm{im}(f)|.$$
  </Alt>

  Let 
  
  <Alt Not="HTML">
    <Display>\textrm{Ims}(S)=\{\:\textrm{im}(f)\::\: f\in S\:\}</Display>
  </Alt>
  
  <Alt Only="HTML">
    $$\textrm{Ims}(S)=\{\:\textrm{im}(f)\::\: f\in S\:\}$$
  </Alt>

  and let
  
  <Alt Not="HTML">
    <Display>\textrm{Kers}(S)=\{\:\textrm{ker}(f)\::\: f\in S\:\}.</Display>
  </Alt>
  
  <Alt Only="HTML">
    $$\textrm{Kers}(S)=\{\:\textrm{ker}(f)\::\: f\in S\:\}.$$
  </Alt>

</Chapter>

<!--<Chapter Label="examples"><Heading>Worked Examples</Heading>

  In this chapter we give some examples of what the <Package>citrus</Package>
  can be used for, and how it compares to other software for computing with 
  transformation semigroups.
  JDM: maybe next time include syntactic semigroups, graph endomorphisms,
  synchronizing semigroups, etc...
</Chapter>-->

<Chapter Label="convenience"><Heading>Shortcuts and expedients</Heading>

  <Section><Heading>Overview</Heading>
    There are several commands in <Package>Citrus</Package> that are
    shorter versions of commands in &GAP;. These functions are described below. 
  </Section>

  <Section><Heading>Utilities</Heading>



<Chapter Label="orbits"><Heading>Transformations and actions</Heading>

  <Section><Heading>Actions and Orbits</Heading>

    In <Package>citrus</Package>, there are essentially two important types of 
    orbits used to compute with transformation semigroups. Let <Math>S</Math> 
    be a semigroup of transformations on the set <Math>\Omega=\{1,2,\ldots, n\}
    </Math>. The first is the action of the <P/> JDM...

    The following speciic orbits are used in the computation of Green's 
    relations and to test if an arbitrary transformation semigroup has a 
    particular property;  see Chapter <Ref Chap="greens"/> and Chapter 
    <Ref Chap="properties"/>.<P/>

    In addition to the actions define in the reference manual
    <Ref Sect="Basic Actions" BookName="ref"/> the following two actions are 
    available in <Package>citrus</Package>.

    <#Include Label="StrongOrbitsInForwardOrbit">
    <#Include Label="ImagesOfTransSemigroup">
    <#Include Label="GradedImagesOfTransSemigroup">
  </Section>	

  <Section><Heading>Creating transformations</Heading>
    The functions described in this section extend the functionality of &GAP; 
    relating to transformations. 
	
    <#Include Label="Idempotent">
    <#Include Label="RandomTransformation">
    <#Include Label="TransformationActionNC">
  </Section>
	
  <Section><Heading>Properties of transformations</Heading>
  
    <#Include Label="IsRegularTransformation">
    <#Include Label="IndexPeriodOfTransformation">
    <#Include Label="SmallestIdempotentPower">
    <#Include Label="InversesOfTransformation">
  
  </Section>
	
</Chapter>

<Chapter Label="greens"><Heading>Green's Relations</Heading>
  
  <Section><Heading>Introduction</Heading>
    
    This chapter contains instructions on how to use the functions for
    computing Green's relations and related notions for transformation         
    semigroups and monoids that are implemented in <Package>citrus</Package>. 
    <P/>
		
    The theory behind these algorithms is developed in <Cite Key="pfeiffer1"/>
    and the algorithms themselves are described in <Cite Key="pfeiffer2"/>.
    Another reference is <Cite Key="lallement"/>.<P/>

    Green's relations can be calculated when  <Package>citrus</Package>
    is loaded using the same commands that you would used when 
    <Package>citrus</Package> is not loaded; see <Ref Chap="Semigroups" 
    BookName="ref"/>. For example, in &GAP; with the <Package>citrus</Package>  
    package loaded:
    
    <Example>
      gap> s:=Semigroup(Transformation([2,1,1,2,1])), 
      > Transformation([3,4,3,4,4]),
      > Transformation([3,4,3,4,3]),
      > Transformation([4,3,3,4,4]));;
      gap> GreensRClasses(s);
      [ {Transformation( [ 2, 1, 1, 2, 1 ] )}, 
        {Transformation( [ 1, 2, 1, 2, 2 ] )}, 
        {Transformation( [ 1, 2, 1, 2, 1 ] )}, 
        {Transformation( [ 2, 1, 1, 2, 2 ] )} ]
    </Example>
    
    Without the <Package>citrus</Package> package loaded:
    
    <Example>
      gap> s:=Semigroup(Transformation([2,1,1,2,1])), 
      > Transformation([3,4,3,4,4]),
      > Transformation([3,4,3,4,3]),
      > Transformation([4,3,3,4,4]));;
      gap> GreensRClasses(s);
      [ {Transformation( [ 1, 2, 1, 2, 1 ] )}, 
        {Transformation( [ 1, 2, 1, 2, 2 ] )},
        {Transformation( [ 1, 2, 2, 1, 1 ] )}, 
        {Transformation( [ 1, 2, 2, 1, 2 ] )} ]
    </Example>
		
    The only noticable differences are the representatives of the classes and 
    the order the classes appear in the list. These differences are caused by 
    the differences in the methods for <C>GreensRClasses</C> in 
    <Package>citrus</Package> and the &GAP; library. <P/>
		
    Most of the commands in this section relate to how Green's relations are 
    calculated in <Package>citrus</Package>. Although some of the commands     
    might be used for other purposes, if all that is required is to calculate 
    Green's classes, relations and so on, then this is done in the exactly the 
    same way as described in the &GAP; manual; see 
    <Ref Chap="Green's Relations" BookName="ref"/>.<P/>
		
    Due to inherent difficulties with computing Green's L- and D-classes, the 
    methods used to compute with Green's R-classes are the most efficient 
    in <Package>citrus</Package>.  Thus wherever possible it is advisable to
    use the commands relating to Green's R-classes rather than those relating
    to Green's L-classes, D-classes, or H-classes.<P/>
		
    The methods in <Package>citrus</Package> allow the computation of     
    individual Green's classes without the need to compute all the elements of 
    the underlying semigroup.  It is also possible to compute all the 
    R-classes, the number of elements and test membership in a transformation 
    semigroup without computing all the elements. This may be useful if you 
    want to study a very large semigroup where computing all the elements of 
    the semigroup is infeasible. 
  </Section>

  <Section>
    <Heading>
      &GAP; library functions
    </Heading>
		
    <Package>citrus</Package> contains special methods for R-classes of the 
    following &GAP; functions: <C>&lt;</C>, <C>=</C>, <C>in</C>, <C>AsList</C>, 
    <C>AsSSortedList</C>, <C>Enumerator</C>, <C>Idempotents</C>,  
    <C>Iterator</C>, <C>GreensHClasses</C>,  
    <C>Random</C>, <C>Size</C><P/>

    <Package>citrus</Package> contains special methods for D-classes of the
    following &GAP; functions: <C>&lt;</C>, <C>=</C>, <C>in</C>, ...<P/>

    <Package>citrus</Package> contains special methods for transformation 
    semigroups of the following &GAP; functions: <C>in</C>, <C>AsList</C>, 
    <C>Enumerator</C>, <C>GreensRClasses</C>, <C>GreensRClassOfElement</C>,  
    <C>Iterator</C>, <C>Size</C>, 

  </Section>

  <Section><Heading>Green's relations</Heading>
    The functions described in this section extend the &GAP; library functions
    for Greens <Math>R</Math>-relation and related objects. 
    
    <#Include Label="GreensRClasses">
    <#Include Label="GreensRClassOfElementNC">
    <#Include Label="GreensRClassReps">
    <#Include Label="Idempotents">
    <#Include Label="IsGreensClassOfTransSemigp">
    <#Include Label="IsRegularRClass">
    <#Include Label="IteratorOfGreensRClasses"> 
    <#Include Label="IteratorOfRClassReps"> 
    <#Include Label="NrGreensRClasses">
    
    <#Include Label="NrIdempotents">
    <#Include Label="NrRegularDClasses">
    <#Include Label="PartialOrderOfDClasses">
    <#Include Label="SchutzenbergerGroup">
  

    
    <#Include Label="GreensHClasses">
    <#Include Label="GreensHClassReps">
    <#Include Label="NrGreensHClasses">

  </Section>


</Chapter>

<Chapter Label="properties"> <Heading>Properties of semigroups</Heading>
  <Section><Heading>Definitions</Heading>
		
    In this section we give the theoretical results and the corresponding 
    &GAP; functions that can be used to determine whether a set of
    transformations generates a semigroup of a given type. Let <Math>S</Math> 
    be a semigroup. Then:
    
    <List>
      
      <Item> <Math>S</Math> is a <E>left zero semigroup</E> if 
      <Math>(\forall s,t\in S)(st=s).</Math>
      </Item>
      
      <Item> <Math>S</Math> is a <E>right zero semigroup</E> if 
      <Math>(\forall s,t\in S)(st=t).</Math>
      </Item>
      
      <Item><Math>S</Math> is <E>commutative</E> if <Math>(\forall 
       s,t\in S)(st=ts)</Math>.
      </Item>
      
      <Item> <Math>S</Math> is <E>simple</E> if it has no proper two-sided 
      ideals.
      </Item>
			
      <Item> <Math>S</Math> is <E>regular</E> if <Math>(\forall s\in S)
      (\exists t\in S)(sts=s).</Math>
      </Item>
			
      <Item> <Math>S</Math> is <E>completely regular</E> if every element of   
      <Math>S</Math> lies in a subgroup. 
      </Item>
			
      <Item> <Math>S</Math> is an <E>inverse semigroup</E> if 
      <Math>(\forall s\in S)(\exists! t\in S)(sts=s \wedge tst=t).</Math>
      </Item>
			
      <Item> <Math>S</Math> is a <E>Clifford semigroup</E> if 
      <Math>(\forall s\in S)(\exists t\in S)(sts=s)\wedge(\forall 
      s, t\in S)(s^2=s\rightarrow st=ts).</Math>
      </Item>
			
      <Item> <Math>S</Math> is a <E>band</E> if <Math>(\forall s\in S)
      (s^2=s)</Math>.
      </Item>
      
      <Item> <Math>S</Math> is a <E>rectangular band</E> if 
      <Math>(\forall x,y,z\in S)(x^2=x\wedge xyz=xz).</Math>
      </Item>
			
      <Item> <Math>S</Math> is a <E>idempotent generated</E> if it is generated 
      by its idempotent elements.
      </Item>
      
      <Item> <Math>S</Math> is an <E>orthodox semigroup</E> if it is regular 
      and idempotents form a subsemigroup.
      </Item>
			
      <Item><Math>S</Math> is a <E>zero semigroup</E> if 
      <Math>(\exists s\in S)(\forall t,u\in S)(tu=s).</Math>
      </Item>
			
      <Item><Math>S</Math> is a <E>zero group</E> if 
      <Math>(\exists s\in S)(\forall t\in S)(st=ts=s\wedge 
      S\setminus\{s\}\textrm{ is a group }).</Math>
      </Item>
    
    </List>
		
      The following results provide methods to determine if an 
      arbitrary transformation semigroup <Math>S</Math> satisfies a particular 
      property by considering the action of the generators of <Math>S</Math> on 
      the underlying set, rather than <Math>S</Math> itself. 
      For more details see  <Cite Key="largest"/>.<P/>

      Then the following hold:
      
      <List>
      
        <Item> <Math>S</Math> is a left zero semigroup if and only if  
        <Math>\textrm{im}(f)=\textrm{im}(g)</Math> and <Math>f^2=f</Math> for all 
        <Math>f, g\in\Omega</Math>.
        </Item>
        
        <Item> <Math>S</Math> is a right zero semigroup if and only if  
        <Math>\textrm{ker}(f)=\textrm{ker}(g)</Math> and <Math>f^2=f</Math> for
        all <Math>f, g\in\Omega</Math>.
        </Item>

        <Item> <Math>S</Math> is simple if and only if     
        <Math>\textrm{rank}(gf)=\textrm{rank}(f)=\textrm{rank}(g)</Math> 
        for all <Math>f, g\in\Omega</Math>.
        </Item>
        
        <Item> <Math>S</Math> is completely regular if and only if 
        <Math>\textrm{rank}(fgf)=\textrm{rank}(gf)</Math> 
        for all <Math>f, g\in\Omega</Math>.
        </Item>
        
        <Item> <Math>S</Math> is inverse if and only if it is regular and 
        there is a bijection <Math>\phi:\textrm{Kers}(S)\to\textrm{Ims}(S)
        </Math> such that if <Math>f\in S</Math> with 
        <Math>\textrm{im}(f)=\phi(\textrm{ker}(f))</Math>, then   
        <Math>\textrm{rank}(f^2)=\textrm{rank}(f)</Math>. 
        </Item>
        
        <Item> <Math>S</Math> is a Clifford semigroup if and only if for all  
        <Math>f, g\in\Omega</Math> 
        <List>
          <Item> <Math>\textrm{rank}(f^2)=\textrm{rank}(f)</Math>;
          </Item>
          <Item> if <Math>g^n</Math> is an idempotent, then 
          <Math>fg^n=g^nf</Math>.
          </Item> 
        </List>
        </Item>
      </List>

      It is straightforward to verify that <Math>S</Math> is a group if and 
      only if for all <Math>f, g\in\Omega</Math> 
      
      <List>
        
        <Item> <Math>\textrm{ker}(f)=\textrm{ker}(g)</Math>;
        </Item>
        
        <Item> <Math>\textrm{im}(f)=\textrm{im}(g)</Math>;
        </Item> 
        
        <Item> <Math>\textrm{rank}(f)=\textrm{rank}(g)</Math>.
        </Item> 
    
    </List>

  </Section>

  <Section><Heading>IsSuchAndSuchSemigroup</Heading>

    <#Include Label="IsBand">
    <#Include Label="IsCliffordSemigroup">
    <#Include Label="IsCommutativeSemigroup">
    <#Include Label="IsCompletelyRegularSemigroup">
    <#Include Label="IsCompletelySimpleSemigroup">
    <#Include Label="IsGroupAsSemigroup">
    <#Include Label="IsInverseSemigroup">
    <#Include Label="IsLeftZeroSemigroup">
    <#Include Label="IsOrthodoxSemigroup">
    <#Include Label="IsRectangularBand">
    <#Include Label="IsRegularSemigroup">
    <#Include Label="IsRightZeroSemigroup">
    <#Include Label="IsSemiBand">
    <#Include Label="IsZeroGroup">
    <#Include Label="IsZeroSemigroup">
    <#Include Label="MultiplicativeZero">

  </Section>

</Chapter>

</Body>

<Bibliography Databases="citrus" />
<TheIndex/>

</Book>
  
