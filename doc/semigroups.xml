
<Chapter Label="create"><Heading>Creating semigroups and monoids</Heading> 
  In this chapter we describe the various ways that semigroups and monoids can
  be created in &Citrus; and the options that are available at the time of
  creation. <P/>
  
  Any transformation semigroup created before &Citrus; has been loaded must be
  recreated after &Citrus; is loaded so that the options record (described in
  Section <Ref Sect="opts"/>) is defined. Almost all of the functions and
  methods provided by &Citrus;, including those methods for existing &GAP;
  library functions, will return an error when applied to a transformation
  semigroup created before &Citrus; is loaded. 

 <Section><Heading>Semigroups defined by a generating set</Heading> 

  In this section we give details of how to create semigroups and monoids from
  a set of generators. Most of what is described here is syntactic sugar. 

  <ManSection>
    <Func Name="Monoid" Arg="obj1, obj2, ... [, opts]"/>
    <Func Name="Semigroup" Arg="obj1, obj2, ... [, opts]"/>
    <Returns>A monoid or semigroup.</Returns>
    <Description>
 
      If <A>obj1</A>, <A>obj2</A>, ... are (any combination) of
      transformations, transformation semigroups, or lists of transformations,
      then <C>Monoid</C> or <C>Semigroup</C> returns the monoid or semigroup
      generated by the union of <A>obj1</A>, <A>obj2</A>, ....  <P/>

      If present, the optional final argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created, as
      described in Section <Ref Sect="opts"/>.<P/>
      
      When applied to arguments other than transformations or transformation
      collections these functions behave precisely as described in the
      reference manual. Please consult <Ref Func="Monoid" BookName="ref"/> and
      <Ref Func="Semigroup" BookName="ref"/> for further details.<P/> 

      As an example of how the syntax provided by &Citrus; can be convenient:
      <C>U:=Semigroup(S, f, Idempotents(T));</C>, in the example below, returns
      the same value as: <C>U:=Semigroup(Concatenation(Generators(S), [f],
      Idempotents(T)));</C>.

      <Example>
gap> S:=Semigroup(Transformation( [ 1, 3, 4, 1, 3, 5 ] ), 
> Transformation( [ 5, 1, 6, 1, 6, 3 ] ) );;
gap> f:=Transformation( [ 2, 4, 6, 1, 6, 5 ] );;
gap> T:=Monoid(Transformation( [ 4, 1, 2, 6, 2, 1 ] ),
> Transformation( [ 5, 2, 5, 3, 5, 3 ] ) );;
gap> U:=Semigroup(S, f, Idempotents(T));
&lt;semigroup with 14 generators>
gap> Size(U);
2182
gap> NrRClasses(U);
53</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="InverseSemigroup"  Arg="obj1, obj2, ... [, opts]"/>
    <Returns>An inverse semigroup.</Returns>
  </ManSection>
  
  <ManSection>
    <Func Name="InverseSemigroupByGenerators"  Arg="obj1, obj2, ... [, opts]"/>
    <Returns>An inverse semigroup.</Returns>
  </ManSection>

  <ManSection>
    <Meth Name="MonoidByGenerators" Arg="coll[, opts]"/>
    <Meth Name="SemigroupByGenerators" Arg="coll[, opts]"/>
    <Returns>A monoid or semigroup.</Returns>
    <Description>
      If <A>coll</A> is a transformation collection, then
      <C>MonoidByGenerators</C> and <C>SemigroupByGenerators</C> return the
      monoid and semigroup generated by <A>coll</A>, respectively. <P/>

      If present, the optional second argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created, as
      described in Section <Ref Sect="opts"/>.<P/> 

      When applied to arguments other than transformations or transformation
      collections these functions behave precisely as described in the
      reference manual. Please consult 
      <Ref Func="MonoidByGenerators" BookName="ref"/> and
      <Ref Func="SemigroupByGenerators" BookName="ref"/> for further details.
      <P/>
    </Description>
  </ManSection>

  <#Include Label="RandomTransformationMonoid"> 
  <ManSection>
    <Func Name="RandomInverseSemigroup"  Arg="m,n"/>
    <Returns>An inverse semigroup.</Returns>
  </ManSection>
 </Section> 

  <Section><Heading>New semigroups from old</Heading> 
  <ManSection>
    <Func Name="ClosureSemigroup" Arg="S, coll [, opts]"/>
    <Returns>A transformation semigroup or monoid.</Returns>
    <Description>

      This function returns the semigroup or monoid generated by the
      transformation semigroup <A>S</A> and the transformation collection or
      transformation  <A>coll</A> after removing duplicates and transformations
      in <A>coll</A> that are already in <A>S</A>. In some cases, the new
      semigroup knows at least as much information about its structure as was
      already known about that of <A>S</A>. <P/>

      If present, the optional third argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created as
      described in Section <Ref Sect="opts"/>. For technical reasons
      <C>ClosureSemigroup</C> differs from <Ref Meth="Semigroup"/> and <Ref
      Meth="Monoid"/> only in the case that the option <C>schreier</C> is
      <K>false</K> for either the old or the new semigroup.  <P/> 

      More specifically, if the option <C>schreier</C> is <K>false</K>, then
      the new semigroup knows the Green's class of any representative of a
      Green's classes of <A>S</A> that was known at the time that
      <C>ClosureSemigroup</C> was called. Consequently, if, for example, the
      number of &R;-classes of <A>S</A> is greater than the number of elements
      required to find the &R;-classes of the new semigroup, then
      <C>ClosureSemigroup</C> might be less efficient than creating the new
      semigroup using the command <Ref Meth="Semigroup"/> or <Ref
      Meth="Monoid"/>. It is unlikely that you will be able to determine which
      of <C>ClosureSemigroup</C> and <Ref Meth="Semigroup"/> will be better
      before calling these functions, except in the following case. If the rank
      of the transformations in <A>coll</A> are lower than the ranks of the
      Green's classes containing the majority of the known elements of
      <A>S</A>, then <C>ClosureSemigroup</C> should be superior to <Ref
      Meth="Semigroup"/>.

      <Example>
gap> gens:=[ Transformation( [ 2, 6, 7, 2, 6, 1, 1, 5 ] ), 
>  Transformation( [ 3, 8, 1, 4, 5, 6, 7, 1 ] ), 
>  Transformation( [ 4, 3, 2, 7, 7, 6, 6, 5 ] ), 
>  Transformation( [ 7, 1, 7, 4, 2, 5, 6, 3 ] ) ];;
gap> S:=Monoid(gens[1], rec(schreier:=false));;
gap> for i in [2..4] do S:=ClosureSemigroup(S, gens[i]); od;
gap> S;
&lt;monoid with 4 generators>
gap> Size(S);
233606</Example>
    </Description>
  </ManSection>

   <ManSection>
    <Func Name="ClosureInverseSemigroup"  Arg="S, coll [, opts]"/>
    <Returns>An inverse semigroup.</Returns>
  </ManSection>
 </Section> 

  <Section Label="opts"><Heading>Options when creating semigroups</Heading>
    When using any of  <Ref Func="Semigroup"/>, 
    <Ref Func="Monoid"/>, <Ref Meth="SemigroupByGenerators"/>, 
    <Ref Meth="MonoidByGenerators"/>, or <Ref Func="ClosureSemigroup"/> a
    record can be given as an optional final argument. The components of this
    record specify the values of certain options for the semigroup being
    created. A list of these options and their default values is
    given below.  <P/>

    Assume that <A>S</A> is the semigroup created by one of the functions given
    above and that <A>S</A> is generated by the list of transformations
    <A>gens</A>. 
  
    <List>
      
      <Mark><C>hashlen</C></Mark>
      <Item>
      this component should be a positive integer, which roughly specifies the
      lengths of the hash tables used internally by &Citrus;.  &Citrus; uses
      hash tables in several fundamental methods.  The lengths of these tables
      are a compromise between performance and memory usage; larger tables
      provide better performance for large computations but use more memory.
      Note that it is unlikely that you will need to specify this option unless
      you find that &GAP; runs out of memory unexpectedly or that the
      performance of &Citrus; is poorer than expected. If you find that &GAP;
      runs out of memory unexpectedly, or you plan to do a large number of
      computations with relatively small semigroups (say with tens of thousands
      of elements), then you might consider setting <C>hashlen</C> to be less
      than the default value of <C>25013</C> for each of these semigroups.  If
      you find that the performance of &Citrus; is unexpectedly poor, or you
      plan to do a computation with a very large semigroup (say, more than 10
      million elements), then you might consider setting <C>hashlen</C> to be
      greater than the default value of <C>25013</C>. <P/>

      You might find it useful to set the info level of the info class
      <C>InfoOrb</C> to 2 or higher since this will indicate when hash tables
      used by &Citrus; are being grown; see <Ref Oper="SetInfoLevel"
      BookName="ref"/>.
      </Item>

      <Mark><C>schreier</C></Mark>
      <Item>
      if this component is set to <K>true</K>, then &Citrus; will keep track of
      various pieces of information so that it is possible to factorize
      elements of <A>S</A> using <Ref Meth="Factorization"/>.  This will cause
      a slight decrease in performance and an increase in memory usage.  If
      this component is set to <K>false</K>, then it will not be possible to
      factorize the elements of <A>S</A> using <Ref Meth="Factorization"/>.
      The default value for this component is <K>true</K>.  </Item>
      
      <Mark><C>small</C></Mark> <Item>if this component is set to <K>true</K>,
      then &Citrus; will compute a small subset of <A>gens</A> that generates
      <A>S</A> at the time that <A>S</A> is created. This will increase the
      amount of time required to create <A>S</A> substantially, but may
      decrease the amount of time required for subsequent calculations with
      <A>S</A>. If this component is set to <K>false</K>, then &Citrus; will
      return the semigroup generated by <A>gens</A> without modifying
      <A>gens</A>. The default value for this component is <K>false</K>.
      </Item> </List>
  
      The default values of the options described above are stored in a global
      variable named <Ref Var="CitrusOptionsRec"/>. If you want to change the
      default values of these options for a single &GAP; session, then you can
      simply redefine the value in &GAP;. For example, to change the option
      <C>small</C> from the default value of <A>false</A> use:

    <Log>gap> CitrusOptionsRec.small:=true;
true</Log>

    If you want to change the default values of the options stored in <Ref
      Var="CitrusOptionsRec"/> for all subsequent &GAP; sessions, then you can
    edit these values in the file <C>citrus/gap/options.g</C>. <P/>

    <Example>
gap> S:=Semigroup(Transformation( [ 1, 2, 3, 3 ] ), rec(schreier:=true,
> hashlen:=100003, small:=false));
&lt;semigroup with 1 generator></Example>

     <ManSection>    
       <Var Name="CitrusOptionsRec"/>    
       <Description>
       This global variable is a record whose components contain the default
       values of certain options for transformation semigroups created after
       &Citrus; has been loaded. A description of these options is given above 
       in Section <Ref Sect="opts"/>. <P/>

       The value of <C>CitrusOptionsRec</C> is defined in the file
       <C>citrus/gap/options.g</C> as: 
       <Log>rec( schreier:=true, small:=false,
         hashlen:=rec(S:=251, M:=6257, L:=25013));</Log>
              
   </Description> 
 </ManSection>

    </Section>
    <Section><Heading>Expressing semigroup elements as words in
        generators</Heading> 

      <#Include Label="EvaluateWord">
      <#Include Label="Factorization">
    </Section>
</Chapter>

