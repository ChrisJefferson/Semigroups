
<Chapter Label="create"><Heading>Creating semigroups and monoids</Heading> 
  In this chapter we describe the various ways that semigroups and monoids can
  be created in &Citrus; and the options that are available at the time of
  creation. <P/>
  
  Any transformation semigroup created before &Citrus; has been loaded must be
  recreated after &Citrus; is loaded so that the options record (described in
  Section <Ref Sect="opts"/>) is defined. Almost all of the functions and
  methods provided by &Citrus;, including those methods for existing &GAP;
  library functions, will return an error when applied to a transformation
  semigroup created before &Citrus; is loaded. 

 <Section><Heading>Semigroups defined by a generating set</Heading> 

  In this section we give details of how to create semigroups and monoids from
  a set of generators. Much of what is described here is syntactic sugar. 

  <ManSection>
    <Func Name="Monoid" Arg="obj1, obj2, ... [, opts]"/>
    <Func Name="Semigroup" Arg="obj1, obj2, ... [, opts]"/>
    <Returns>A monoid or semigroup.</Returns>
    <Description>
 
      If <A>obj1</A>, <A>obj2</A>, ... are (any combination) of
      transformations, transformation semigroups, or lists of transformations,
      then <C>Monoid</C> or <C>Semigroup</C> returns the monoid or semigroup
      generated by the union of <A>obj1</A>, <A>obj2</A>, ....  <P/>

      If present, the optional final argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created, as
      described in Section <Ref Sect="opts"/>.<P/>
      
      When applied to arguments other than transformations or transformation
      collections these functions behave precisely as described in the
      reference manual. Please consult <Ref Func="Monoid" BookName="ref"/> and
      <Ref Func="Semigroup" BookName="ref"/> for further details.<P/> 

      As an example of how the syntax provided by &Citrus; can be convenient:
      <C>U:=Semigroup(S, f, Idempotents(T));</C>, in the example below, returns
      the same value as: <C>U:=Semigroup(Concatenation(Generators(S), [f],
      Idempotents(T)));</C>.

      <Example>
gap> S:=Semigroup(Transformation( [ 1, 3, 4, 1, 3, 5 ] ), 
> Transformation( [ 5, 1, 6, 1, 6, 3 ] ) );;
gap> f:=Transformation( [ 2, 4, 6, 1, 6, 5 ] );;
gap> T:=Monoid(Transformation( [ 4, 1, 2, 6, 2, 1 ] ),
> Transformation( [ 5, 2, 5, 3, 5, 3 ] ) );;
gap> U:=Semigroup(S, f, Idempotents(T));
&lt;semigroup with 14 generators>
gap> Size(U);
2182
gap> NrRClasses(U);
53</Example>
    </Description>
  </ManSection>

  <ManSection>
    <Func Name="InverseMonoid"  Arg="obj1, obj2, ... [, opts]"/>
    <Func Name="InverseSemigroup"  Arg="obj1, obj2, ... [, opts]"/>
    <Returns>An inverse semigroup or monoid.</Returns>
    <Description>
      If <A>obj1</A>, <A>obj2</A>, ... are (any combination) of
      partial permutations, partial permutation semigroup, or lists of partial
      permutations, then <C>InverseMonoid</C> or <C>InverseSemigroup</C>
      returns the inverse monoid or semigroup generated by the union of
      <A>obj1</A>, <A>obj2</A>, ... which equals the semigroup or
      monoid generated by the union of <A>obj1</A>, <A>obj2</A>, ... and their
      inverses.<P/>

      If present, the optional final argument <A>opts</A> should be a record
      containing the values of the options for the inverse semigroup being
      created, as described in Section <Ref Sect="opts"/>.<P/>

      As an example of how the syntax provided by &Citrus; can be convenient:
      <C>U:=Semigroup(S, f, Idempotents(T));</C>, in the example below, returns
      the same value as: <C>U:=Semigroup(Concatenation(Generators(S), [f],
        Idempotents(T)));</C>.
      <Example>
gap> S:=InverseSemigroup(
> PartialPermNC( [ 1, 2, 3, 4, 6, 8, 9, 10, 11, 13, 14, 16, 17, 18, 20 ], 
> [ 2, 14, 5, 8, 11, 12, 16, 17, 18, 9, 13, 15, 20, 6, 4 ] ),
> PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 17 ], 
> [ 2, 14, 8, 19, 5, 1, 3, 16, 6, 9, 10, 17, 12, 20 ] ));;
gap> f:=PartialPermNC( 
> [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
>  18, 20, 22, 23, 25, 26, 30, 31, 32, 33, 34, 39, 40, 42, 43, 45 ], 
> [ 4, 47, 34, 19, 32, 22, 12, 15, 16, 45, 49, 8, 24, 40, 17, 
>  46, 14, 6, 44, 2, 48, 41, 10, 31, 18, 50, 23, 5, 37, 11, 38, 30, 21 ] );;
gap> S:=InverseSemigroup(S, f, Idempotents(SymmetricInverseSemigp(10)));
&lt;inverse semigroup with 1027 generators>
gap> S:=InverseSemigroup(S, f, Idempotents(SymmetricInverseSemigp(10)),
> rec(small:=true));
&lt;inverse semigroup with 13 generators>
gap> Size(S);
17147970
gap> S:=InverseMonoid(Generators(S));
&lt;inverse monoid with 13 generators>
gap> Size(S);
17147971</Example>
  </Description>
  </ManSection>
  
  <ManSection>
    <Func Name="InverseMonoidByGenerators" Arg="coll[, opts]"/>
    <Func Name="InverseSemigroupByGenerators"  Arg="coll[, opts]"/>
    <Returns>An inverse monoid or semigroup.</Returns>
    <Description>
      If <A>coll</A> is a partial permutation collection, then
      <C>InverseMonoidByGenerators</C> and 
      <C>InverseSemigroupByGenerators</C>
      return the inverse monoid and semigroup generated by <A>coll</A>,
      respectively. <P/>

      If present, the optional second argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created, as
      described in Section <Ref Sect="opts"/>.<P/> 
    </Description>
  </ManSection>

  <ManSection>
    <Meth Name="MonoidByGenerators" Arg="coll[, opts]"/>
    <Meth Name="SemigroupByGenerators" Arg="coll[, opts]"/>
    <Returns>A monoid or semigroup.</Returns>
    <Description>
      If <A>coll</A> is a transformation collection, then
      <C>MonoidByGenerators</C> and <C>SemigroupByGenerators</C> return the
      monoid and semigroup generated by <A>coll</A>, respectively. <P/>

      If present, the optional second argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created, as
      described in Section <Ref Sect="opts"/>.<P/> 

      When applied to arguments other than transformations or transformation
      collections these functions behave precisely as described in the
      reference manual. Please consult 
      <Ref Func="MonoidByGenerators" BookName="ref"/> and
      <Ref Func="SemigroupByGenerators" BookName="ref"/> for further details.
    </Description>
  </ManSection>

  <#Include Label="RandomTransformationMonoid"> 
  
  <ManSection>
    <Func Name="RandomInverseMonoid" Arg="m,n"/>
    <Func Name="RandomInverseSemigroup"  Arg="m,n"/>
    <Returns>An inverse monoid or semigroup.</Returns>
    <Description>
      Returns  a  random  inverse  monoid  or semigroup of partial
      permutations with degree at most <A>n</A>  with <A>m</A> generators.
      <Example>
gap> S:=RandomInverseSemigroup(10,10);                                
&lt;inverse semigroup with 10 generators>
gap> S:=RandomInverseMonoid(10,10);   
&lt;inverse monoid with 10 generators></Example>
    </Description>
  </ManSection>
 </Section> 

  <Section><Heading>New semigroups from old</Heading> 
  <ManSection>
    <Func Name="ClosureSemigroup" Arg="S, coll [, opts]"/>
    <Returns>A transformation semigroup or monoid.</Returns>
    <Description>
      This function returns the semigroup or monoid generated by the
      transformation semigroup <A>S</A> and the transformation collection or
      transformation  <A>coll</A> after removing duplicates and transformations
      in <A>coll</A> that are already in <A>S</A>. In some cases, the new
      semigroup knows at least as much information about its structure as was
      already known about that of <A>S</A>. <P/>

      If present, the optional third argument <A>opts</A> should be a record
      containing the values of the options for the semigroup being created as
      described in Section <Ref Sect="opts"/>. For technical reasons
      if the option <C>schreier</C> is <K>false</K>, then
      <C>ClosureSemigroup(S, coll)</C> does exactly the same as
      <Ref Meth="Semigroup"/> or <Ref Meth="Monoid"/>, in that the new semigroup
      does not know any information about its structure even if the old
      semigroup had been completely determined. <P/> 

      More specifically, if the option <C>schreier</C> is <K>false</K>, then
      the new semigroup knows the Green's class of any representative of a
      Green's classes of <A>S</A> that was known at the time that
      <C>ClosureSemigroup</C> was called. Consequently, if, for example, the
      number of &R;-classes of <A>S</A> is greater than the number of elements
      required to find the &R;-classes of the new semigroup, then
      <C>ClosureSemigroup</C> might be less efficient than creating the new
      semigroup using the command <Ref Meth="Semigroup"/> or <Ref
      Meth="Monoid"/>. It is unlikely that you will be able to determine which
      of <C>ClosureSemigroup</C> and <Ref Meth="Semigroup"/> will be better
      before calling these functions, except in the following case. If the rank
      of the transformations in <A>coll</A> are lower than the ranks of the
      Green's classes containing the majority of the known elements of
      <A>S</A>, then <C>ClosureSemigroup</C> should be superior to <Ref
      Meth="Semigroup"/>.

      <Example>
gap> gens:=[ Transformation( [ 2, 6, 7, 2, 6, 1, 1, 5 ] ), 
>  Transformation( [ 3, 8, 1, 4, 5, 6, 7, 1 ] ), 
>  Transformation( [ 4, 3, 2, 7, 7, 6, 6, 5 ] ), 
>  Transformation( [ 7, 1, 7, 4, 2, 5, 6, 3 ] ) ];;
gap> S:=Monoid(gens[1], rec(schreier:=false));;
gap> for i in [2..4] do S:=ClosureSemigroup(S, gens[i]); od;
gap> S;
&lt;monoid with 4 generators>
gap> Size(S);
233606</Example>
    </Description>
  </ManSection>

   <ManSection>
    <Func Name="ClosureInverseSemigroup"  Arg="S, coll [, opts]"/>
    <Returns>An inverse semigroup or monoid.</Returns>
    <Description>
      This function returns the inverse semigroup or monoid generated by the
      inverse semigroup of partial permutations <A>S</A> and the partial
      permutation collection or partial permutation <A>coll</A> after first
      removing duplicates and partial permutations in <A>coll</A> that are
      already in <A>S</A>. In most cases, the new semigroups knows at least as
      much information about its structure as was already known about that of
      <A>S</A>. <P/>

      If present, the optional third argument <A>opts</A> should be a record
      contiaing the values of the options for the inverse semigroup being
      created; these options are described in Section <Ref Sect="opts"/>. <P/>

      Unlike <Ref Func="ClosureSemigroup"/>, <C>ClosureInverseSemigroup</C> is
      always at least as efficient as (and often much more than) simply
      creating an inverse semigroup from scratch using 
      <Ref Func="InverseSemigroup"/>.
      <Example>
gap> S:=InverseMonoid(
> PartialPermNC( [ 1, 2, 3, 5, 6, 7, 8 ], [ 5, 9, 10, 6, 3, 8, 4 ] ),
> PartialPermNC( [ 1, 2, 4, 7, 8, 9 ], [ 10, 7, 8, 5, 9, 1 ] ) );;
gap> f:=PartialPermNC(
> [ 1, 2, 3, 4, 5, 7, 8, 10, 11, 13, 18, 19, 20 ],
> [ 5, 1, 7, 3, 10, 2, 12, 14, 11, 16, 6, 9, 15 ]);;
gap> S:=ClosureInverseSemigroup(S, f);
&lt;inverse monoid with 3 generators>
gap> Size(S);
9727
gap> T:=Idempotents(SymmetricInverseSemigp(10));;
gap> S:=ClosureInverseSemigroup(S, T);
&lt;inverse monoid with 858 generators>
gap> S:=InverseSemigroup(SmallGeneratingSet(S));
&lt;inverse semigroup with 14 generators></Example>
    </Description>
  </ManSection>
 </Section> 

  <Section Label="opts"><Heading>Options when creating semigroups</Heading>
    When using any of  <Ref Func="InverseSemigroup"/>, 
    <Ref Func="InverseMonoid"/>, 
    <Ref Func="Semigroup"/>, 
    <Ref Func="Monoid"/>, <Ref Meth="SemigroupByGenerators"/>, 
    <Ref Meth="MonoidByGenerators"/>, <Ref Func="ClosureInverseSemigroup"/>
    or <Ref Func="ClosureSemigroup"/> a
    record can be given as an optional final argument. The components of this
    record specify the values of certain options for the semigroup being
    created. A list of these options and their default values is
    given below.  <P/>

    Assume that <A>S</A> is the semigroup created by one of the functions given
    above and that <A>S</A> is generated by the list of transformations
    <A>gens</A>. 
  
    <List>
      
      <Mark><C>hashlen</C></Mark>
      <Item>
      this component should be a positive integer, which roughly specifies the
      lengths of the hash tables used internally by &Citrus;.  &Citrus; uses
      hash tables in several fundamental methods.  The lengths of these tables
      are a compromise between performance and memory usage; larger tables
      provide better performance for large computations but use more memory.
      Note that it is unlikely that you will need to specify this option unless
      you find that &GAP; runs out of memory unexpectedly or that the
      performance of &Citrus; is poorer than expected. If you find that &GAP;
      runs out of memory unexpectedly, or you plan to do a large number of
      computations with relatively small semigroups (say with tens of thousands
      of elements), then you might consider setting <C>hashlen</C> to be less
      than the default value of <C>25013</C> for each of these semigroups.  If
      you find that the performance of &Citrus; is unexpectedly poor, or you
      plan to do a computation with a very large semigroup (say, more than 10
      million elements), then you might consider setting <C>hashlen</C> to be
      greater than the default value of <C>25013</C>. <P/>

      You might find it useful to set the info level of the info class
      <C>InfoOrb</C> to 2 or higher since this will indicate when hash tables
      used by &Citrus; are being grown; see <Ref Oper="SetInfoLevel"
      BookName="ref"/>.
      </Item>

      <Mark><C>schreier</C></Mark>
      <Item>
      if this component is set to <K>true</K>, then &Citrus; will keep track of
      various pieces of information so that it is possible to factorize
      elements of <A>S</A> using <Ref Meth="Factorization"/>.  This will cause
      a slight decrease in performance and an increase in memory usage.  If
      this component is set to <K>false</K>, then it will not be possible to
      factorize the elements of <A>S</A> using <Ref Meth="Factorization"/>.
      The default value for this component is <K>true</K>.  </Item>
      
      <Mark><C>small</C></Mark> <Item>if this component is set to <K>true</K>,
      then &Citrus; will compute a small subset of <A>gens</A> that generates
      <A>S</A> at the time that <A>S</A> is created. This will increase the
      amount of time required to create <A>S</A> substantially, but may
      decrease the amount of time required for subsequent calculations with
      <A>S</A>. If this component is set to <K>false</K>, then &Citrus; will
      return the semigroup generated by <A>gens</A> without modifying
      <A>gens</A>. The default value for this component is <K>false</K>.
      </Item> </List>
  
      The default values of the options described above are stored in a global
      variable named <Ref Var="CitrusOptionsRec"/>. If you want to change the
      default values of these options for a single &GAP; session, then you can
      simply redefine the value in &GAP;. For example, to change the option
      <C>small</C> from the default value of <A>false</A> use:

    <Log>gap> CitrusOptionsRec.small:=true;
true</Log>

    If you want to change the default values of the options stored in <Ref
      Var="CitrusOptionsRec"/> for all subsequent &GAP; sessions, then you can
    edit these values in the file <C>citrus/gap/options.g</C>. <P/>

    <Example>
gap> S:=Semigroup(Transformation( [ 1, 2, 3, 3 ] ), rec(schreier:=true,
> hashlen:=100003, small:=false));
&lt;semigroup with 1 generator></Example>

     <ManSection>    
       <Var Name="CitrusOptionsRec"/>    
       <Description>
       This global variable is a record whose components contain the default
       values of certain options for transformation semigroups created after
       &Citrus; has been loaded. A description of these options is given above 
       in Section <Ref Sect="opts"/>. <P/>

       The value of <C>CitrusOptionsRec</C> is defined in the file
       <C>citrus/gap/options.g</C> as: 
       <Log>rec( schreier:=true, small:=false,
         hashlen:=rec(S:=251, M:=6257, L:=25013));</Log>
              
       </Description> 
     </ManSection>

    </Section>
    <Section><Heading>Expressing semigroup elements as words in
        generators</Heading> 

      In some cases it is possible to express the elements of a transformation
      semigroup as a word in the generators. This section describes how to
      accomplish this in &Citrus;. <P/>

      Note that at present it is not possible to factorize elements in a
      semigroup of partial permutations. 

      <#Include Label="EvaluateWord">
      <#Include Label="Factorization">
    </Section>

    <Section><Heading>Standard examples</Heading>
    In this section we describe functions for creating several standard
    examples of semigroups of transformations and partial permutations. 

      <ManSection>
      <Oper Name="FullMatrixSemigroup" Arg="d, q"/>
      <Oper Name="GeneralLinearSemigroup" Arg="d, q"/>
      <Returns>A matrix semigroup.</Returns>
      <Description>
      <C>FullMatrixSemigroup</C> and <C>GeneralLinearSemigroup</C> are synonyms
      for each other. They both return the full matrix semigroup, or if you
      prefer the general linear semigroup, of <A>d</A> by <A>d</A> matrices
      with entries over the field with <A>q</A> elements.  This semigroup has
      <C>q^(d^2)</C> elements. <P/>

      <B>Please note:</B> there are currently no special methods for computing
      with matrix semigroups in &Citrus; and so it might be advisable to use
      <Ref Oper="IsomorphismTransformationSemigroup"/>.

      <Example>
gap> S:=FullMatrixSemigroup(3,4);
&lt;3x3 full matrix semigroup over GF(2^2)>
gap> T:=Range(IsomorphismTransformationSemigroup(S));
gap> Size(T);
262144</Example>
      </Description>
    </ManSection>

    <ManSection>
      <Prop Name="IsFullMatrixSemigroup" Arg="S"/>      
      <Prop Name="IsGeneralLinearSemigroup" Arg="S"/>      
      <Description>
      <C>IsFullMatrixSemigroup</C> and <C>IsGeneralLinearSemigroup</C> return
      <K>true</K> if the semigroup <C>S</C> was created using either of the
      commands <Ref Oper="FullMatrixSemigroup"/> or 
      <Ref Oper="GeneralLinearSemigroup"/> and <K>false</K> otherwise. 

      <Example>
gap> S:=RandomTransformationSemigroup(4,4);
&lt;semigroup with 4 generators>
gap> IsFullMatrixSemigroup(S);
false
gap> S:=GeneralLinearSemigroup(3,3);
&lt;3x3 full matrix semigroup over GF(3)>
gap> IsFullMatrixSemigroup(S);
true</Example>
      </Description>
    </ManSection>

    <ManSection><Heading>Semigroups of order preserving functions</Heading>
      <Oper Name="O" Arg="n"/>
      <Oper Name="POI" Arg="n"/>
      <Oper Name="POPI" Arg="n"/>
      <Returns>A semigroup of transformations or partial permutations related
        to a linear order. 
      </Returns>
      <Description>
        <List>
          <Mark><C>O(<A>n</A>)</C></Mark>
          <Item>
            <C>O(<A>n</A>)</C> returns the monoid of transformations that
            preserve the usual order on <M>\{1,2,\ldots, n\}</M> where <A>n</A>
            is a positive integer.  
            <C>O(<A>n</A>)</C> has <C>Binomial(2*<A>n</A>-1, <A>n</A>-1);</C>
            elements.
        </Item>
        <Mark><C>POI(<A>n</A>)</C></Mark>
        <Item>
        <C>POI(<A>n</A>)</C> returns the inverse
        monoid of partial permutations that preserve the usual order
        on <M>\{1,2,\ldots, n\}</M> where <A>n</A> is a positive integer.
        <Alt Not="Text">
        <C>POI(<A>n</A>)</C> is generated by the <M><A>n</A></M> 
        partial permutations:
        <Display>
        \begin{pmatrix}
        1&amp;2&amp;3&amp;\cdots&amp;n\\          
        -&amp;1&amp;2&amp;\cdots&amp;n-1
        \end{pmatrix}, \qquad
        \begin{pmatrix}
        1&amp;2&amp;\cdots&amp;i-1&amp; i&amp; i+1&amp;i+2&amp;\cdots
        &amp;n\\
        1&amp;2&amp;\cdots&amp;i-1&amp; i+1&amp;-&amp;i+2&amp;\cdots&amp;n\\
        \end{pmatrix}\text{ where }i=1\cdots n-1.
      </Display>
      <C>POI(<A>n</A>)</C> has <M>\binom{2n}{n}</M> elements. </Alt>
    </Item>
    <Mark><C>POPI(<A>n</A>)</C></Mark>
    <Item>
      <C>POPI(<A>n</A>)</C> returns the inverse monoid of partial permutation
      that preserve the orientation of <M>\{1,2,\ldots, n\}</M> where
      <M>n</M> is a positive integer.
      <Alt Not="Text">
      <C>POPI(<A>n</A>)</C> is generated by the partial permutations:
      <Display>
\begin{pmatrix}
1&amp;2&amp;\cdots&amp;n-1&amp;n\\
2&amp;3&amp;\cdots&amp;n&amp;1
\end{pmatrix},\qquad
\begin{pmatrix}
1&amp;2&amp;\cdots&amp;n-2&amp;n-1&amp;n\\
1&amp;2&amp;\cdots&amp;n-2&amp;n&amp;-
\end{pmatrix}.
      </Display>
      <C>POPI(<A>n</A>)</C> has <M>1+\frac{n}{2}\binom{2n}{n}</M> elements. 
      </Alt>
    </Item>
  </List>
        <Example>
gap> S:=POPI(10);                                            
&lt;inverse monoid with 2 generators>
gap> Size(S);
923781
gap> 1+5*Binomial(20, 10);
923781
gap> S:=POI(10);
&lt;inverse monoid with 10 generators>
gap> Size(S);
184756
gap> Binomial(20,10);
184756
gap> IsSubsemigroup(POPI(10), POI(10));
true
gap> S:=O(5);
&lt;monoid with 8 generators>
gap> IsSemiBand(S);
true
gap> IsRegularSemigroup(S);
true
gap> Size(S)=Binomial(2*5-1, 5-1);
true</Example>
      </Description>
    </ManSection>

    <ManSection>
      <Oper Name="SingularSemigroup" Arg="n"/>
      <Returns>The semigroup of non-invertible transformations.</Returns>
      <Description>
        If <A>n</A> is a positive integer, then
        <C>SingularSemigroup(<A>n</A>)</C> returns the semigroup of
        non-invertible transformations, which is generated by the
        <A>n(n-1)</A> idempotents of degree <A>n</A> and rank <M>n-1</M> and
        has <M>n^n-n!</M> elements. 

        <Example>
gap> S:=SingularSemigroup(5);
&lt;semigroup with 20 generators>
gap> Size(S);
3005</Example>
      </Description>
    </ManSection>

    <ManSection>
      <Oper Name="SymmetricInverseSemigp" Arg="n"/>
      <Returns>The symmetric inverse semigroup.</Returns>
      <Description>
        If <A>n</A> is a positive integer, then
        <C>SymmetricInverseSemigp(<A>n</A>);</C>
        returns the symmetric inverse semigroup consisting of all partial
        permutations on the set <M>\{1,\ldots, n\}</M>. 
        <Alt Not="Text">
        The symmetric inverse
        semigroup on <M>\{1,\ldots, n\}</M> is generated by the partial
        permutations:
        <Display>
\begin{pmatrix}
1&amp;2&amp;\cdots&amp;n-1&amp;n\\
2&amp;3&amp;\cdots&amp;n&amp;1
\end{pmatrix}, 
\quad
\begin{pmatrix}
1&amp;2&amp;3&amp;\cdots&amp;n-1&amp;n\\
2&amp;1&amp;3&amp;\cdots&amp;n-1&amp;n
\end{pmatrix}, 
\quad
\begin{pmatrix}
1&amp;2&amp;\cdots&amp;n-1&amp;n\\
1&amp;2&amp;\cdots&amp;n-1&amp;-
\end{pmatrix}
        </Display>
        and has <M>\sum_{r=0}^n\binom{n}{r}^2\cdot r!</M>
        elements. </Alt>

        <Example>
gap> S:=SymmetricInverseSemigp(15);
&lt;inverse semigroup with 3 generators>
gap> Size(S);
306827170866106</Example>
      </Description>
    </ManSection>
  </Section>

<Section Label="Catalogues"><Heading>The examples directory</Heading>
  <Index>&Citrus; examples</Index>
    
    The <C>examples</C> folder of the &Citrus; package directory contains
    catalogues of some naturally occurring semigroups of transformations and
    partial permutations. These files can be read into &GAP; using <Ref
      Func="ReadCitrus"/> and similar files can be created using <Ref
      Func="WriteCitrus"/>.<P/>

    Further examples can be downloaded from &vspace;<P/>

    <URL>http://tinyurl.com/jdmitchell/examples.html</URL>&vspace;<P/>

    &noindent; A summary of the available files, a desciption of their
    contents, and how they were created is given below.<P/>

    <List>
      <Mark>Endomorphisms of graphs</Mark>
      <Item>
        the files <C>eul<A>n</A>c.citrus.gz</C> with
        <M>n=3,...,10</M>; <C>graph<A>n</A>c.citrus.gz</C> with 
        <M>n=3,...,8</M>; and <C>selfcomp.citrus.gz</C>
        contain small generating sets for the endomorphism monoids of
        all connected Eulerian graphs, all connected graphs, and all self
        complimentary graphs with <M>n</M> vertices, respectively. 
        These files were created using the catalogues of
        such graphs available at:<P/>

        <URL>http://cs.anu.edu.au/~bdm/data/graphs.html</URL><P/>
       
        a C program written by Max Neunhoeffer which produces a relatively
        large list of endomorphisms containing a generating set for the
        endomorphism monoid, <Ref Meth="SmallGeneratingSet"/> and then
        <Ref Oper="IrredundantGeneratingSubset"/> in &Citrus;. 
        The monoid generated by the transformations output
        by <C>ReadCitrus("eul7c.citrus.gz", i);</C>, say, is the monoid of 
        endomorphisms of the <C>i</C>th graph in the file:<P/>

        <URL>http://cs.anu.edu.au/~bdm/data/eul7c.g6</URL>
      </Item>
      
      <Mark>Munn semigroups</Mark>
      <Item> 
        the file <C>munn.citrus.gz</C> contains generators for all the Munn
        semigroups of semilattices with 2 to 8 elements. The
        semilattices were obtained from the &Smallsemi; package using the
        command:
        
        <Log>AllSmallSemigroups([2..8], IsSemilatticeAsSemigroup, true);</Log>
        and the generators for the Munn semigroups were calculated using &GAP;
        code written jointly by J. D. Mitchell, Yann Peresse (St Andrews), 
        Yanhui Wang (York). More information is available at:<P/>
  
        <URL>http://tinyurl.com/jdmitchell/examples.html</URL>
      </Item>

      <Mark>Syntactic semigroups</Mark>
      <Item> 
        the files <C>syntactic.citrus.gz</C> contain generators for the
        syntactic semigroups of word acceptors of certain triangle groups,
        provided by Markus Pfeiffer (St Andrews).
        A <E>triangle group</E> is a group defined by a presentation of the 
        form 
        <Display> 
        \langle x, y | x^p, y^q, (xy)^r\rangle
        </Display>
        for some positive integers <M>p, q, r</M>. The file contains
        generators of the syntactic semigroups of word acceptors of triangle
        groups where <M>p</M> ranges from <M>1</M> to <M>94</M>, <M>q=3</M>,
        and <M>r=2</M>; <M>p=101</M>, <M>q</M> ranges from <M>3</M> to
        <M>99</M> and <M>r=2</M>;  
        <M>p=101</M>, <M>q=72</M>, and <M>r</M> ranges from <M>7</M> to
        <M>71</M>; and some further randomly chosen values of <M>p,q,r</M>.
      </Item>
      <Mark>Endomorphisms of groups</Mark>
      <Item>
        the files <C>nonabelian_groups_<A>n</A>.citrus.gz</C> with
        <M>n=6,....,64</M> contains small generating sets for the endomorphism
        monoids of all non-abelian groups with <A>n</A> elements. 
        These files were created using the Small Groups Library in &GAP;
        and the <Package>Sonata</Package> function <C>Endomorphisms</C>.
      </Item>
    </List>
  </Section>
</Chapter>

