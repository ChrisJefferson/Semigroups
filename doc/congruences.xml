#############################################################################
##
#W  congruences.xml
#Y  Copyright (C) 2015                                      Michael Torpey
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="SemigroupCongruence">
  <ManSection>
    <Func Name="SemigroupCongruence" Arg="S, pairs"/>
    <Returns>A semigroup congruence.</Returns>
    <Description>
      This function returns a semigroup congruence over the semigroup
      <A>S</A>.<P/>

      If <A>pairs</A> is a list of lists of size 2 with elements from <A>S</A>,
      then this function will return the semigroup congruence defined by these
      generating pairs.  The individual pairs may instead be given as separate
      arguments.<P/>

      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 1, 1, 2, 1 ] ), 
>                 Transformation( [ 3, 4, 3, 4, 4 ] ), 
>                 Transformation( [ 3, 4, 3, 4, 3 ] ),  
>                 Transformation( [ 4, 3, 3, 4, 4 ] ));;
gap> pair1 := [Transformation( [ 3, 4, 3, 4, 3 ] ),
>              Transformation( [ 1, 2, 1, 2, 1 ] )];;
gap> pair2 := [Transformation( [ 4, 3, 4, 3, 4 ] ),
>              Transformation( [ 3, 4, 3, 4, 3 ] )];;
gap> SemigroupCongruence(S, [pair1, pair2]);
<semigroup congruence over <simple transformation semigroup of 
 degree 5 with 4 generators> with linked triple (2,4,1)>
gap> SemigroupCongruence(S, pair1, pair2);
<semigroup congruence over <simple transformation semigroup of 
 degree 5 with 4 generators> with linked triple (2,4,1)>]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="LeftSemigroupCongruence">
  <ManSection>
    <Func Name="LeftSemigroupCongruence" Arg="S, pairs"/>
    <Returns>A left semigroup congruence.</Returns>
    <Description>
      This function returns a left semigroup congruence over the semigroup
      <A>S</A>.<P/>

      If <A>pairs</A> is a list of lists of size 2 with elements from <A>S</A>,
      then this function will return the least left semigroup congruence on
      <A>S</A> which contains these generating pairs.  The individual pairs may
      instead be given as separate arguments.<P/>

      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 1, 1, 2, 1 ] ), 
>                 Transformation( [ 3, 4, 3, 4, 4 ] ), 
>                 Transformation( [ 3, 4, 3, 4, 3 ] ),  
>                 Transformation( [ 4, 3, 3, 4, 4 ] ));;
gap> pair1 := [Transformation( [ 3, 4, 3, 4, 3 ] ),
>              Transformation( [ 1, 2, 1, 2, 1 ] )];;
gap> pair2 := [Transformation( [ 4, 3, 4, 3, 4 ] ),
>              Transformation( [ 3, 4, 3, 4, 3 ] )];;
gap> LeftSemigroupCongruence(S, [pair1, pair2]);
<LeftSemigroupCongruence with 2 generating pairs>
gap> LeftSemigroupCongruence(S, pair1, pair2);
<LeftSemigroupCongruence with 2 generating pairs>]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RightSemigroupCongruence">
  <ManSection>
    <Func Name="RightSemigroupCongruence" Arg="S, pairs"/>
    <Returns>A right semigroup congruence.</Returns>
    <Description>
      This function returns a right semigroup congruence over the semigroup
      <A>S</A>.<P/>

      If <A>pairs</A> is a list of lists of size 2 with elements from <A>S</A>,
      then this function will return the least right semigroup congruence on
      <A>S</A> which contains these generating pairs.  The individual pairs may
      instead be given as separate arguments.<P/>

      <Example><![CDATA[
gap> S:=Semigroup(Transformation( [ 2, 1, 1, 2, 1 ] ), 
>                 Transformation( [ 3, 4, 3, 4, 4 ] ), 
>                 Transformation( [ 3, 4, 3, 4, 3 ] ),  
>                 Transformation( [ 4, 3, 3, 4, 4 ] ));;
gap> pair1 := [Transformation( [ 3, 4, 3, 4, 3 ] ),
>              Transformation( [ 1, 2, 1, 2, 1 ] )];;
gap> pair2 := [Transformation( [ 4, 3, 4, 3, 4 ] ),
>              Transformation( [ 3, 4, 3, 4, 3 ] )];;
gap> RightSemigroupCongruence(S, [pair1, pair2]);
<RightSemigroupCongruence with 2 generating pairs>
gap> RightSemigroupCongruence(S, pair1, pair2);
<RightSemigroupCongruence with 2 generating pairs>]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="CongruencesOfSemigroup">
  <ManSection> 
    <Attr Name="CongruencesOfSemigroup" Arg="S"/>
    <Returns>The congruences of a semigroup.</Returns>
    <Description>
      This attribute gives a list of the congruences of the semigroup
      <A>S</A>. <P/>

      At present this only works for simple and 0-simple semigroups.
      <Example><![CDATA[
gap> s := ReesZeroMatrixSemigroup(SymmetricGroup(3), 
> [[(),(1,3,2)],[(1,2),0]]);;
gap> congs := CongruencesOfSemigroup(s);
[ <universal semigroup congruence over 
    <Rees 0-matrix semigroup 2x2 over Sym( [ 1 .. 3 ] )>>, 
  <semigroup congruence over <Rees 0-matrix semigroup 2x2 over 
      Sym( [ 1 .. 3 ] )> with linked triple (1,2,2)>, 
  <semigroup congruence over <Rees 0-matrix semigroup 2x2 over 
      Sym( [ 1 .. 3 ] )> with linked triple (3,2,2)>, 
  <semigroup congruence over <Rees 0-matrix semigroup 2x2 over 
      Sym( [ 1 .. 3 ] )> with linked triple (S3,2,2)> ]]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsLookupTable">
  <ManSection> 
    <Attr Name="AsLookupTable" Arg="cong"/>
    <Returns>A list.</Returns>
    <Description>
      This attribute describes the semigroup congruence <A>cong</A> as a list of
      positive integers with length the size of the semigroup over which
      <A>cong</A> is defined.<P/>

      Each position in the list corresponds to an element of the semigroup (in
      the order defined by <C>SSortedList</C>) and the integer at that position
      is a unique identifier for that element's congruence class under
      <A>cong</A>.  Hence, two elements are congruent if and only if they have
      the same number at their two positions in the list.<P/>
      <Example><![CDATA[
gap> S := Monoid([Transformation( [ 1, 2, 2 ] ),
>                 Transformation( [ 3, 1, 3 ] ) ]);;
gap> cong := SemigroupCongruence(S,
> [Transformation( [ 1, 2, 1 ] ), Transformation( [ 2, 1, 2 ] )]);;
gap> AsLookupTable(cong);
[ 1, 2, 3, 4, 5, 6, 2, 3, 6, 4, 5, 6 ]]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrEquivalenceClasses">
  <ManSection> 
    <Attr Name="NrEquivalenceClasses" Arg="eq"/>
    <Attr Name="NrCongruenceClasses" Arg="cong"/>
    <Returns>A positive integer.</Returns>
    <Description>
      If <A>eq</A> is an equivalence relation, then this attribute describes
      the number of equivalence classes it has. <P/>

      If <A>cong</A> is a semigroup congruence, then this attribute describes
      the number of congruence classes it has. <P/>

      <Example><![CDATA[
gap> S := ReesZeroMatrixSemigroup(SymmetricGroup(3), 
> [[ (), (1,3,2) ], [ (1,2), 0 ]]);;
gap> cong := CongruencesOfSemigroup(S)[3];;
gap> NrCongruenceClasses(cong);
9]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsSemigroupCongruenceByGeneratingPairs">
  <ManSection> 
    <Oper Name="AsSemigroupCongruenceByGeneratingPairs" Arg="cong"/>
    <Returns>A semigroup congruence.</Returns>
    <Description>
      This operation takes <A>cong</A>, a semigroup congruence, and returns the same
      congruence relation, but described by &GAP;'s default method of defining 
      semigroup congruences: a set of generating pairs for the congruence.
      <Example><![CDATA[
gap> S := ReesZeroMatrixSemigroup(SymmetricGroup(3), 
> [[ (), (1,3,2) ], [ (1,2), 0 ]]);;
gap> cong := CongruencesOfSemigroup(S)[3];;
gap> AsSemigroupCongruenceByGeneratingPairs(cong);
<semigroup congruence over <Rees 0-matrix semigroup 2x2 over 
  Sym( [ 1 .. 3 ] )> with 3 generating pairs>]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NonTrivialEquivalenceClasses">
  <ManSection>
    <Attr Name="NonTrivialEquivalenceClasses" Arg="eq"/>
    <Attr Name="NonTrivialCongruenceClasses" Arg="cong"/>
    <Returns>A list.</Returns>
    <Description>
      If <A>eq</A> is an equivalence relation, then this attribute returns a
      list of all equivalence classes of <A>eq</A> which contain more than one
      element. <P/>

      If <A>cong</A> is a semigroup congruence, then this attribute returns a
      list of all congruence classes of <A>cong</A> which contain more than one
      element.
      <Example><![CDATA[
gap> S := Monoid([Transformation( [ 1, 2, 2 ] ),
>                 Transformation( [ 3, 1, 3 ] )]);;
gap> cong := SemigroupCongruence(S, [Transformation( [ 1, 2, 1 ] ), 
>                                    Transformation( [ 2, 1, 2 ] )]);;
gap> NonTrivialCongruenceClasses(cong);
[ {Transformation( [ 1, 2, 2 ] )}, {Transformation( [ 3, 1, 3 ] )}, 
  {Transformation( [ 3, 1, 1 ] )}, {Transformation( [ 2, 1, 2 ] )}, 
  {Transformation( [ 3, 3, 3 ] )} ]]]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>
