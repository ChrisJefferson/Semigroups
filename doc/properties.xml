#############################################################################
##
#W  properties.xml
#Y  Copyright (C) 2011                             James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="GroupOfUnits">
  <ManSection>
    <Attr Name="GroupOfUnits" Arg="S"/>
    <Description>
      returns a permutation group isomorphic to the group of units of the 
      semigroup <A>S</A> if it exists and returns <K>fail</K> otherwise. <P/>
      
      If <A>S</A> has identity <C>e</C>, then the <E>group of units<</E> of
      <A>S</A>
      is the set of <C>s</C> in <A>S</A> such that there exists <C>t</C> in
      <A>S</A> where <C>s*t=t*s=e</C>. Equivanlently, the group of units is 
      the <Math>\mathcal{H}</Math>-class
      of the identity of <A>S</A>.<P/> 
      
      See also 
      <Ref Oper="GreensHClassOfElement" Label="CitrusHClass"/>,
      <Ref Oper="GreensHClassOfElement" BookName="ref"/>,
      <Ref Prop="IsMonoidAsSemigroup"/>, and
      <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/>.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IrredundantGeneratingSet">
  <ManSection>
    <Oper Name="IrredundantGeneratingSet" Arg="coll"/>
    <Description>
      returns a subset <Math>U</Math> of <A>coll</A> if <A>coll</A> is a 
      collection of
      transformations or <A>Generators(coll)</A> if <A>coll</A> is
      a transformation semigroup such that <Math>u\not\in \langle
      U\setminus \{u\}\rangle</Math> for all <Math>u\in U</Math> where
      <Math>\langle  U\setminus \{u\}\rangle</Math> denotes the semigroup
      generated by <Math>U\setminus \{u\}</Math>. <P/>
      
      See also <Ref Func="Generators"/> and <Ref
      Prop="IsTransformationCollection" BookName="ref"/>. 

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBand">
  <ManSection>
    <Prop Name="IsBand" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a band 
      and <K>false</K> otherwise.<P/>

      A semigroup \(S\) is a <E>band</E> if every element is an idempotent, 
      that is, \(x^2=x\) for all \(x\in S\).

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsBand(S);
true
      </Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBlockGroup">
  <ManSection>
    <Prop Name="IsBlockGroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a block 
      group and <K>false</K> otherwise.<P/> 
      
      A semigroup \(S\) is a
      <E>block group</E> if every <M>\mathcal{L}</M>-class and every
      <M>\mathcal{R}</M>-class of 
      <M>S</M> contains at most one idempotent.  
      <Example></Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCliffordSemigroup">
  <ManSection>
    <Prop Name="IsCliffordSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a 
      Clifford semigroup and <K>false</K> otherwise.<P/>

      A semigroup <M>S</M> is a <E>Clifford 
      semigroup</E> if it is regular and its idempotents are central, i.e.
      $$(\forall s\in S)(\exists t\in S)(sts=s)\wedge(\forall s, t\in S)
        (s^2=s\rightarrow st=ts).$$

      <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
> Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsCliffordSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCommutativeSemigroup">
  <ManSection>
    <Prop Name="IsCommutativeSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      commutative and <K>false</K> otherwise. The function 
      <Ref Prop="IsCommutative" BookName="ref"/> can also be used to test if a 
      semigroup is commutative.  <P/>

      A semigroup <A>S</A> is <E>commutative</E> if 
      <C>xy=yx</C> for all <C>x,y</C> in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCommutativeSemigroup(S);
true
gap> IsCommutative(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompletelyRegularSemigroup">
  <ManSection>
    <Prop Name="IsCompletelyRegularSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      completely regular and <K>false</K> otherwise.<P/>
      
      A semigroup is <E>completely regular</E> 
      if every element is contained in a subgroup.

      <Example>       
gap> gens:=[ Transformation( [ 1, 2, 4, 3, 6, 5, 4 ] ), 
>  Transformation( [ 1, 2, 5, 6, 3, 4, 5 ] ), 
>  Transformation( [ 2, 1, 2, 2, 2, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCompletelyRegularSemigroup(S);
true
gap> S:=RandomSemigroup(5,5);;
gap> IsSimpleSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGreensRTrivial">
  <ManSection><Heading>IsGreensXTrivial</Heading>
    <Prop Name="IsGreensRTrivial" Arg="S"/>
    <Prop Name="IsGreensLTrivial" Arg="S"/>
    <Prop Name="IsGreensHTrivial" Arg="S"/>
    <Prop Name="IsAperiodicSemigroup" Arg="S"/>
    <Prop Name="IsCombinatorialSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if Green's <M>\mathcal{R}</M>-relation, 
      <M>\mathcal{L}</M>-relation, or
      <M>\mathcal{H}</M>-relation, respectively, on the
      transformation semigroup <A>S</A> is trivial and <K>false</K> otherwise.
      These properies can be applied to a Green's class instead of
      transformation semigroup where applicable. 
      <P/> 

      A semigroup is <E>aperiodic</E> if its group <M>H</M>-classes are 
      trivial. A finite semigroup is aperiodic if and only if it is <M>H</M>-
      trivial. 
      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGroupAsSemigroup">
  <ManSection>
    <Prop Name="IsGroupAsSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a group 
      and <K>false</K> otherwise.

      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsGroupAsSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsIdempotentGenerated">
  <ManSection><Heading>IsIdempotentGenerated</Heading>
    <Prop Name="IsIdempotentGenerated" Arg="S"/>
    <Prop Name="IsSemiBand" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a 
      semiband and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is a <E>semiband</E> if it is generated by its 
      idempotent elements, that is, elements satisfying <C>x^2=x</C>.

      <Example>
gap> S:=FullTransformationSemigroup(4);;
gap> x:=Transformation( [ 1, 2, 3, 1 ] );;
gap> D:=GreensDClassOfElement(S, x);;
gap> T:=Semigroup(Elements(D));;
gap> IsSemiBand(T);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInverseSemigroup">
  <ManSection>
    <Prop Name="IsInverseSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is an inverse
      semigroup and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is an <E>inverse semigroup</E> if every element 
      <C>x</C> in <A>S</A> has a unique semigroup inverse, that is, a unique 
      element <C>y</C> such that <C>xyx=x</C> and <C>yxy=y</C>.

      <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
>Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsInverseSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<!-- the following does not currently exist! -->
<#GAPDoc Label="IsIrredundantGeneratingSet">
  <ManSection>
    <Oper Name="IsIrredundantGeneratingSet" Arg="[S, ]U"/>
    <Description>
      returns <K>true</K> if <C>u</C> is not an element of the subsemigroup 
      generated by <C>U</C> without <C>u</C> for all <C>u</C> in <C>U</C>.<P/>

      If the optional first argument is present, then 
      <C>IsIrredundantGeneratingSet</C> first checks that <C>U</C> generates 
      <A>S</A>.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftZeroSemigroup">
  <ManSection>
    <Prop Name="IsLeftZeroSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a left zero semigroup and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is a <E>left zero semigroup</E> if <C>xy=x</C> for
      all <C>x,y</C> in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
> Transformation( [ 1, 2, 3, 3, 3 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsLeftZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonoidAsSemigroup">
  <ManSection>
    <Prop Name="IsMonoidAsSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if <A>S</A> satisfies 
      <Ref Prop="IsTransformationMonoid" BookName="ref"/> or <A>S</A> satisfies
      <Ref Prop="IsTransformationSemigroup" BookName="ref"/> and <A>S</A> has
      an identity element. <P/>

      See also <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/> and
      <Ref Oper="IsomorphismTransformationMonoid"/>.
      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismTransformationMonoid">
  <ManSection>
    <Ope Name="IsomorphismTransformationMonoid" Arg="S"/>
    <Description>
      returns an isomorphism from the transformation semigroup <A>S</A>
      satisfying <Ref Prop="IsMonoidAsSemigroup"/> to a transformation monoid. 
      <P/>
      See also <Ref Prop="IsTransformationMonoid" BookName="ref"/> and
            <Ref Prop="IsTransformationSemigroup" BookName="ref"/>.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismPermGroup">
  <ManSection>
    <Ope Name="IsomorphismPermGroup" Arg="S"/>
    <Description>
      returns an isomorphism from the transformation semigroup <A>S</A>
      satisfying <Ref Prop="IsGroupAsSemigroup"/> to a permutation group. 
      <P/>

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsOrthodoxSemigroup">
  <ManSection>
    <Prop Name="IsOrthodoxSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      orthodox and <K>false</K> otherwise.<P/>

      A semigroup is an <E>orthodox semigroup</E> if it is regular and its  
      idempotent elements form a subsemigroup.<P/>

      See also <Ref Prop="IsRegularSemigroup"/> and 
      <Ref Prop="IsRegularSemigroup" BookName="ref"/>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 5, 4 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 2 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 3 ] ), 
>  Transformation( [ 5, 5, 5, 5, 5, 5 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsOrthodoxSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRectangularBand">
  <ManSection>
    <Prop Name="IsRectangularBand" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a 
      rectangular band and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is a <E>rectangular band</E> if for all <C>x,y,z</C> 
      in <A>S</A> we have that <C>x^2=x</C> and <C>xyz=xz</C>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRectangularBand(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularSemigroup">
  <ManSection>
    <Prop Name="IsRegularSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a regular
      semigroup and <K>false</K> otherwise. <P/>

      A semigroup <A>S</A> is <E>regular</E> if for all <C>x</C> in <A>S</A> 
      there exists <C>y</C> in <A>S</A> such that <C>xyx=x</C>.

      See also <Ref Prop="IsRegularDClass" BookName="ref"/>,
      <Ref Func="IsRegularDClass" Label="CitrusIsRegularDClass"/>,   
      <Ref Func="IsRegularTransformation" BookName="ref"/>, and
      <Ref Func="IsRegularTransformation" 
       Label="CitrusIsRegularTransformation"/>.
      
      <Example>
gap> IsRegularSemigroup(FullTransformationSemigroup(5));
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRightZeroSemigroup">
  <ManSection>
    <Prop Name="IsRightZeroSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a right zero semigroup and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is a <E>right zero semigroup</E> if <C>xy=y</C> for 
      all <C>x,y</C> in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
>  Transformation( [ 1, 2, 4, 4, 1 ] )];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemilatticeAsSemigroup">
  <ManSection>
    <Prop Name="IsSemilatticeAsSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the semigroup <A>S</A> is a semilattice 
      and <K>false</K> otherwise. <P/>
      
      A semigroup is a
      <E>semilattice</E> if it is commutative and every element is an 
      idempotent.
      <Example>
gap> a:=Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] );;
gap> b:=Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] );;
gap> s:=Semigroup(a,b);;                    
gap> Size(s);
631
gap> IsInverseSemigroup(s);
true
gap> e:=Semigroup(Idempotents(s)); 
&lt;semigroup with 32 generators>
gap> IsSemilatticeAsSemigroup(e);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleSemigroup">
  <ManSection><Heading>IsSimpleSemigroup</Heading>
    <Prop Name="IsSimpleSemigroup" Arg="S"/>
    <Prop Name="IsCompletelySimpleSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is simple 
      and <K>false</K> otherwise.<P/>

      A semigroup is <E>simple</E> if it has no proper
      2-sided ideals. A semigroup is <E>completely simple</E> if it is simple 
      and possesses minimal left and right ideals. A finite semigroup is simple 
      if and only if it is completely simple. 

      <Example>
gap> gens:=[ Transformation( [ 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 2 ] ), 
>  Transformation( [ 1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 3 ] ), 
>  Transformation( [ 1, 7, 3, 9, 5, 11, 7, 1, 9, 3, 11, 5, 5 ] ), 
>  Transformation( [ 7, 7, 9, 9, 11, 11, 1, 1, 3, 3, 5, 5, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsSimpleSemigroup(S);
true
gap> IsCompletelySimpleSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSynchronizingSemigroup">
  <ManSection>
    <Prop Name="IsSynchronizingSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> contains a
      constant transformation. 
      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroGroup">
  <ManSection>
    <Prop Name="IsZeroGroup" Arg="S"/>
    <Description> 
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a zero group and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is a <E>zero group</E> if there exists an 
      element <C>0</C> in <A>S</A> such that <A>S</A> without <C>0</C> is a
      group and <C>x0=0x=0</C> for all <C>x</C> in <A>S</A>.
      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSemigroup">
  <ManSection>
    <Prop Name="IsZeroSemigroup" Arg="S"/>
    <Description> 
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a zero semigroup. Otherwise <K>false</K> is returned.<P/>

      A semigroup <A>S</A> is a <E>zero semigroup</E> if there exists an 
      element <C>0</C> in <A>S</A> such that <C>xy=0</C> for all <C>x,y</C>
      in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 4, 7, 6, 3, 1, 5, 3, 6, 5, 9 ] ), 
> Transformation( [ 5, 3, 5, 1, 9, 3, 8, 7, 4, 3 ] ), 
> Transformation( [ 5, 10, 10, 1, 7, 6, 6, 8, 7, 7 ] ), 
> Transformation( [ 7, 4, 3, 3, 2, 2, 3, 2, 9, 3 ] ), 
> Transformation( [ 8, 1, 3, 4, 9, 6, 3, 7, 1, 6 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsZeroSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="MinimalIdeal">
  <ManSection>
    <Prop Name="MinimalIdeal" Arg="S"/>
    returns the minimal ideal of the transformation semigroup <A>S</A>. <P/>

    The minimal ideal of semigroup is the least ideal with respect to
    containment. <P/> 

    Currently, <C>MinimalIdeal</C> returns a transformation semigroup with as
    many generators as elements. There are plans to improve this in future
    versions of <Package>Citrus</Package>. <P/>

    Note that <C>MinimalIdeal</C> is significantly faster than finding the
    <M>\mathcal{D}</M>-class with minimum rank representative (which is also
    the minimal ideal). 

    See also <Ref Attr="PartialOrderOfDClasses"/> and 
    <Ref Oper="IsGreensLessThanOrEqual" BookName="ref"/>. 
    
    <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>
    
<#GAPDoc Label="MultiplicativeZero">
  <ManSection>
    <Prop Name="MultiplicativeZero" Arg="S"/>
    <Description> 
      returns the multiplicative zero of the transformation semigroup <A>S</A> 
      if it exists and returns <K>fail</K> otherwise. 

      <Example>
gap> s:=Semigroup( Transformation( [ 1, 4, 2, 6, 6, 5, 2 ] ), 
> Transformation( [ 1, 6, 3, 6, 2, 1, 6 ] ));;
gap> MultiplicativeZero(s);
Transformation( [ 1, 1, 1, 1, 1, 1, 1 ] )
s:=Semigroup(Transformation( [ 2, 8, 3, 7, 1, 5, 2, 6 ] ), 
> Transformation( [ 3, 5, 7, 2, 5, 6, 3, 8 ] ), 
> Transformation( [ 6, 7, 4, 1, 4, 1, 6, 2 ] ), 
> Transformation( [ 8, 8, 5, 1, 7, 5, 2, 8 ] ));;
gap> MultiplicativeZero(s);
fail</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallGeneratingSet">
  <ManSection>
    <Oper Name="SmallGeneratingSet" Arg="S"/>
    <Description>
      returns a generating set for the transformation semigroup <A>S</A> with
      a  relatively small number of elements. <P/>
      
      As neither irredundancy, nor 
      minimal length are proven <C>SmallGeneratingSet</C> usually returns an
      answer  much faster than 
      <Ref Oper="IrredundantGeneratingSubset"/>. It can be used whenever a
      small 
      generating set is desired which does not necessarily needs to be optimal.
      Note that 
      <C>SmallGeneratingSet</C> may return different result in different &GAP; 
      sessions.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

#EOF
