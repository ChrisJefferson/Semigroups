#############################################################################
##
#W  properties.xml
#Y  Copyright (C) 2011                             James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="GroupOfUnits">
  <ManSection>
    <Attr Name="GroupOfUnits" Arg="S"/>
    <Description>
      returns a permutation group isomorphic to the group of units of the 
      semigroup <A>S</A> if it exists and returns <K>fail</K> otherwise. <P/>
      
      If <A>S</A> has identity <C>e</C>, then the <E>group of units </E> of
      <A>S</A>
      is the set of <C>s</C> in <A>S</A> such that there exists <C>t</C> in
      <A>S</A> where <C>s*t=t*s=e</C>. Equivanlently, the group of units is 
      the <Math>\mathcal{H}</Math>-class
      of the identity of <A>S</A>.<P/> 
      
      See also 
      <Ref Oper="GreensHClassOfElement" BookName="ref"/>,
      <Ref Prop="IsMonoidAsSemigroup"/>, and
      <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/>.

      <Example>
gap> S:=Semigroup(Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),
>   Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),
>   Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),
>   Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),
>   Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) );;
gap> Size(S);
5304
gap> GroupOfUnits(S);
Group([ (1,8)(2,7)(3,4)(5,6), (1,4)(2,5)(3,8)(6,7), (1,8,5,2)(3,6,7,4), 
  (1,6)(2,3)(4,5)(7,8) ])
gap> StructureDescription(GroupOfUnits(S));
"C2 x S4"</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IrredundantGeneratingSubset">
  <ManSection>
    <Oper Name="IrredundantGeneratingSubset" Arg="coll"/>
    <Description>
      returns a subset <C>U</C> of <A>coll</A> or
      <C>Generators(<A>coll</A>)</C> such that no element of <C>U</C> is
      generated by the other elements of <C>U</C>. <P/>
      
      Note that <A>coll</A> should be either a list of transformations or a
      transformation semigroup. <P/>
  
      See also <Ref Func="Generators"/> and <Ref
      Prop="IsTransformationCollection" BookName="ref"/>. 

      <Example>
gap> l:=[ Transformation( [ 6, 1, 1, 6, 1, 6, 1 ] ), 
>  Transformation( [ 3, 3, 3, 3, 3, 3, 3 ] ), 
>  Transformation( [ 6, 6, 6, 6, 6, 6, 6 ] ), 
>  Transformation( [ 5, 2, 4, 5, 1, 4, 5 ] ), 
>  Transformation( [ 2, 2, 2, 2, 2, 2, 2 ] ) ];;
gap> IrredundantGeneratingSubset(l);
[ Transformation( [ 2, 2, 2, 2, 2, 2, 2 ] ), 
  Transformation( [ 3, 3, 3, 3, 3, 3, 3 ] ), 
  Transformation( [ 5, 2, 4, 5, 1, 4, 5 ] ), 
  Transformation( [ 6, 1, 1, 6, 1, 6, 1 ] ) ]
gap> gens:=[ Transformation( [ 5, 1, 4, 6, 2, 3 ] ),
> Transformation( [ 1, 2, 3, 4, 5, 6 ] ),
> Transformation( [ 4, 6, 3, 4, 2, 5 ] ),
> Transformation( [ 5, 4, 6, 3, 1, 3 ] ),
> Transformation( [ 2, 2, 6, 5, 4, 3 ] ),
> Transformation( [ 3, 5, 5, 1, 2, 4 ] ),
> Transformation( [ 6, 5, 1, 3, 3, 4 ] ),
> Transformation( [ 1, 3, 4, 3, 2, 1 ] ) ];;
gap> S:=Semigroup( Transformation( [ 5, 1, 4, 6, 2, 3 ] ),
> Transformation( [ 1, 2, 3, 4, 5, 6 ] ),
> Transformation( [ 4, 6, 3, 4, 2, 5 ] ),
> Transformation( [ 5, 4, 6, 3, 1, 3 ] ),
> Transformation( [ 2, 2, 6, 5, 4, 3 ] ),
> Transformation( [ 3, 5, 5, 1, 2, 4 ] ),
> Transformation( [ 6, 5, 1, 3, 3, 4 ] ),
> Transformation( [ 1, 3, 4, 3, 2, 1 ] ) );;
gap> IrredundantGeneratingSubset(S);
[ Transformation( [ 1, 3, 4, 3, 2, 1 ] ), 
  Transformation( [ 2, 2, 6, 5, 4, 3 ] ), 
  Transformation( [ 3, 5, 5, 1, 2, 4 ] ), 
  Transformation( [ 5, 1, 4, 6, 2, 3 ] ), 
  Transformation( [ 5, 4, 6, 3, 1, 3 ] ), 
  Transformation( [ 6, 5, 1, 3, 3, 4 ] ) ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBand">
  <ManSection>
    <Prop Name="IsBand" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a band 
      and <K>false</K> otherwise.<P/>

      A semigroup is a <E>band</E> if every element is an idempotent. 

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsBand(S);
true
      </Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBlockGroup">
  <ManSection>
    <Prop Name="IsBlockGroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a block 
      group and <K>false</K> otherwise.<P/> 
      
      A semigroup <M>S</M> is a
      <E>block group</E> if every <M>\mathcal{L}</M>-class and every
      <M>\mathcal{R}</M>-class of 
      <M>S</M> contains at most one idempotent.  
      <Example>
gap> S:=Semigroup(Transformation( [ 5, 6, 7, 3, 1, 4, 2, 8 ] ),
>   Transformation( [ 3, 6, 8, 5, 7, 4, 2, 8 ] ));;
gap> IsBlockGroup(S);
true
gap> S:=Semigroup(Transformation( [ 2, 1, 10, 4, 5, 9, 7, 4, 8, 4 ] ),
> Transformation( [ 10, 7, 5, 6, 1, 3, 9, 7, 10, 2 ] ));;
gap> IsBlockGroup(S);
false</Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCliffordSemigroup">
  <ManSection>
    <Prop Name="IsCliffordSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a 
      Clifford semigroup and <K>false</K> otherwise.<P/>

      A semigroup <M>S</M> is a <E>Clifford 
      semigroup</E> if it is regular and its idempotents are central, i.e.
      $$(\forall s\in S)(\exists t\in S)(sts=s)\wedge(\forall s, t\in S)
        (s^2=s\rightarrow st=ts).$$

      <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
> Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsCliffordSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCommutativeSemigroup">
  <ManSection>
    <Prop Name="IsCommutativeSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      commutative and <K>false</K> otherwise. The function 
      <Ref Prop="IsCommutative" BookName="ref"/> can also be used to test if a 
      semigroup is commutative.  <P/>

      A semigroup <A>S</A> is <E>commutative</E> if 
      <C>x*y=y*x</C> for all <C>x,y</C> in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCommutativeSemigroup(S);
true
gap> IsCommutative(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompletelyRegularSemigroup">
  <ManSection>
    <Prop Name="IsCompletelyRegularSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      completely regular and <K>false</K> otherwise.<P/>
      
      A semigroup is <E>completely regular</E> 
      if every element is contained in a subgroup.

      <Example>
gap> gens:=[ Transformation( [ 1, 2, 4, 3, 6, 5, 4 ] ), 
>  Transformation( [ 1, 2, 5, 6, 3, 4, 5 ] ), 
>  Transformation( [ 2, 1, 2, 2, 2, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCompletelyRegularSemigroup(S);
true
gap> S:=RandomTransformationSemigroup(5,5);;
gap> IsSimpleSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGreensRTrivial">
  <ManSection><Heading>IsGreensXTrivial</Heading>
    <Prop Name="IsGreensRTrivial" Arg="S"/>
    <Prop Name="IsGreensLTrivial" Arg="S"/>
    <Prop Name="IsGreensHTrivial" Arg="S"/>
    <Prop Name="IsAperiodicSemigroup" Arg="S"/>
    <Prop Name="IsCombinatorialSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if Green's <M>\mathcal{R}</M>-relation, 
      <M>\mathcal{L}</M>-relation, or
      <M>\mathcal{H}</M>-relation, respectively, on the
      transformation semigroup <A>S</A> is trivial and <K>false</K>
      otherwise.<P/>

      These properties can be applied to a Green's class instead of
      transformation semigroup where applicable. 
      <P/> 

      A semigroup is <E>aperiodic</E> if its contains no non-trivial
      subgroups (equivalently, all of its group <M>\mathcal{H}</M>-classes 
      are trivial). A finite semigroup is aperiodic if and only if it is 
      <M>\mathcal{H}</M>-trivial. <P/>

      <E>Combinatorial</E> is a synonym for aperiodic in this context. 
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 5, 1, 3, 7, 10, 6, 2, 7, 10 ] ), 
>  Transformation( [ 4, 4, 5, 6, 7, 7, 7, 4, 3, 10 ] ) );;
gap> IsGreensHTrivial(S);
true
gap> Size(S);
108
gap> IsGreensRTrivial(S);
false
gap> IsGreensLTrivial(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGroupAsSemigroup">
  <ManSection>
    <Prop Name="IsGroupAsSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a group 
      and <K>false</K> otherwise.

      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsGroupAsSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsIdempotentGenerated">
  <ManSection><Heading>IsIdempotentGenerated</Heading>
    <Prop Name="IsIdempotentGenerated" Arg="S"/>
    <Prop Name="IsSemiBand" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is
      generated by its idempotents and <K>false</K> otherwise.<P/>

      See <Ref Oper="Idempotents" Label="Citrus pkg"/>. <P/>

      A semigroup <A>S</A> is a <E>semiband</E> if it is generated by its 
      idempotent elements, i.e. semiband is a synonym of idempotent-generated
      in this context. 

      <Example>
gap> S:=FullTransformationSemigroup(4);;
gap> x:=Transformation( [ 1, 2, 3, 1 ] );;
gap> D:=GreensDClassOfElement(S, x);;
gap> T:=Semigroup(Elements(D));;
gap> IsIdempotentGenerated(T);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInverseSemigroup">
  <ManSection>
    <Prop Name="IsInverseSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is an inverse
      semigroup and <K>false</K> otherwise.<P/>

      A semigroup is an <E>inverse semigroup</E> if every element 
      <C>x</C> has a unique semigroup inverse, that is, an 
      element <C>y</C> such that <C>x*y*x=x</C> and <C>y*x*y=y</C>.

      <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
> Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsInverseSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<!-- the following does not currently exist! -->
<#GAPDoc Label="IsIrredundantGeneratingSet">
  <ManSection>
    <Oper Name="IsIrredundantGeneratingSet" Arg="[S, ]U"/>
    <Description>
      returns <K>true</K> if <C>u</C> is not an element of the subsemigroup 
      generated by <C>U</C> without <C>u</C> for all <C>u</C> in <C>U</C>.<P/>

      If the optional first argument is present, then 
      <C>IsIrredundantGeneratingSet</C> first checks that <C>U</C> generates 
      <A>S</A>.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftZeroSemigroup">
  <ManSection>
    <Prop Name="IsLeftZeroSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a left zero semigroup and <K>false</K> otherwise.<P/>

      A semigroup is a <E>left zero semigroup</E> if <C>x*y=x</C> for
      all <C>x,y</C>.

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
> Transformation( [ 1, 2, 3, 3, 3 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsLeftZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonoidAsSemigroup">
  <ManSection>
    <Prop Name="IsMonoidAsSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if <A>S</A> satisfies 
      <Ref Prop="IsTransformationMonoid" BookName="ref"/> or <A>S</A> satisfies
      <Ref Prop="IsTransformationSemigroup" BookName="ref"/> and <A>S</A> has
      an identity element. <P/>

      See also <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/> and
      <Ref Oper="IsomorphismTransformationMonoid"/>.
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsMonoidAsSemigroup(S);
true
gap> MultiplicativeNeutralElement(S);
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 ] )
gap> S:=Monoid(Transformation( [ 8, 2, 8, 9, 10, 6, 2, 8, 7, 8 ] ),
  Transformation( [ 9, 2, 6, 3, 6, 4, 5, 5, 3, 2 ] ));;
gap> IsMonoidAsSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismTransformationMonoid">
  <ManSection>
    <Oper Name="IsomorphismTransformationMonoid" Arg="S"/>
    <Description>
      returns an isomorphism from the transformation semigroup <A>S</A>
      satisfying <Ref Prop="IsMonoidAsSemigroup"/> to a transformation monoid. 
      <P/>
      See also <Ref Prop="IsTransformationMonoid" BookName="ref"/> and
            <Ref Prop="IsTransformationSemigroup" BookName="ref"/>.

      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsTransformationMonoid(S);
false
gap> IsMonoidAsSemigroup(S);
true
gap> M:=Range(IsomorphismTransformationMonoid(S));
&lt;monoid with 2 generators>
gap> IsTransformationMonoid(M);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismPermGroup">
  <ManSection>
    <Oper Name="IsomorphismPermGroup" Arg="S"/>
    <Description>
      returns an isomorphism from the transformation semigroup <A>S</A>
      satisfying <Ref Prop="IsGroupAsSemigroup"/> to a permutation group. 

      <Example>
gap> S:=Semigroup( Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4 ] ) );;
gap> IsGroupAsSemigroup(S);
true
gap> IsomorphismPermGroup(S); 
MappingByFunction( &lt;semigroup with 2 generators>, Group([ (5,6,8), (2,3,8,4) 
 ]), &lt;Operation "AsPermutation"> )
gap> StructureDescription(Range(IsomorphismPermGroup(S)));
"S6"</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsOrthodoxSemigroup">
  <ManSection>
    <Prop Name="IsOrthodoxSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      orthodox and <K>false</K> otherwise.<P/>

      A semigroup is an <E>orthodox semigroup</E> if it is regular and its  
      idempotent elements form a subsemigroup.<P/>

      See also <Ref Prop="IsRegularSemigroup"/> and 
      <Ref Prop="IsRegularSemigroup" BookName="ref"/>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 5, 4 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 2 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 3 ] ), 
>  Transformation( [ 5, 5, 5, 5, 5, 5 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsOrthodoxSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRectangularBand">
  <ManSection>
    <Prop Name="IsRectangularBand" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a 
      rectangular band and <K>false</K> otherwise.<P/>

      A semigroup <A>S</A> is a <E>rectangular band</E> if for all <C>x,y,z</C> 
      in <A>S</A> we have that <C>x^2=x</C> and <C>xyz=xz</C>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRectangularBand(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularSemigroup">
  <ManSection>
    <Prop Name="IsRegularSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is a regular
      semigroup and <K>false</K> otherwise. <P/>

      A semigroup <C>S</C> is <E>regular</E> if for all <C>x</C> in <C>S</C> 
      there exists <C>y</C> in <C>S</C> such that <C>x*y*x=x</C>.

      See also <Ref Prop="IsRegularDClass" BookName="ref"/>,
      <Ref Func="IsRegularDClass" Label="CitrusIsRegularDClass"/>,   
      and <Ref Func="IsRegularTransformation"/>.
      
      <Example>
gap> IsRegularSemigroup(FullTransformationSemigroup(5));
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRightZeroSemigroup">
  <ManSection>
    <Prop Name="IsRightZeroSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a right zero semigroup and <K>false</K> otherwise.<P/>

      A semigroup <C>S</C> is a <E>right zero semigroup</E> if <C>x*y=y</C> for 
      all <C>x,y</C> in <C>S</C>.

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
>  Transformation( [ 1, 2, 4, 4, 1 ] )];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemilatticeAsSemigroup">
  <ManSection>
    <Prop Name="IsSemilatticeAsSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the semigroup <A>S</A> is a semilattice 
      and <K>false</K> otherwise. <P/>
      
      A semigroup is a
      <E>semilattice</E> if it is commutative and every element is an 
      idempotent.
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;                    
gap> Size(S);
631
gap> IsInverseSemigroup(S);
true
gap> E:=Semigroup(Idempotents(S)); 
&lt;semigroup with 32 generators>
gap> IsSemilatticeAsSemigroup(E);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleSemigroup">
  <ManSection><Heading>IsSimpleSemigroup</Heading>
    <Prop Name="IsSimpleSemigroup" Arg="S"/>
    <Prop Name="IsCompletelySimpleSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> is simple 
      and <K>false</K> otherwise.<P/>

      A semigroup is <E>simple</E> if it has no proper
      2-sided ideals. A semigroup is <E>completely simple</E> if it is simple 
      and possesses minimal left and right ideals. A finite semigroup is simple 
      if and only if it is completely simple. 

      <Example>
gap> gens:=[ Transformation( [ 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 2 ] ), 
>  Transformation( [ 1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 3 ] ), 
>  Transformation( [ 1, 7, 3, 9, 5, 11, 7, 1, 9, 3, 11, 5, 5 ] ), 
>  Transformation( [ 7, 7, 9, 9, 11, 11, 1, 1, 3, 3, 5, 5, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsSimpleSemigroup(S);
true
gap> IsCompletelySimpleSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSynchronizingSemigroup">
  <ManSection>
    <Prop Name="IsSynchronizingSemigroup" Arg="S"/>
    <Description>
      returns <K>true</K> if the transformation semigroup <A>S</A> contains a
      constant transformation. 

      See also <Ref Oper="ConstantTransformation"/>. 
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 1, 8, 7, 6, 6, 4, 1, 8, 9 ] ), 
  Transformation( [ 5, 8, 7, 6, 10, 8, 7, 6, 9, 7 ] ) );;
gap> IsSynchronizingSemigroup(S);
true
gap> S:=Semigroup( Transformation( [ 3, 8, 1, 1, 9, 9, 8, 7, 9, 6 ] ), 
>  Transformation( [ 7, 6, 8, 7, 5, 6, 8, 7, 8, 9 ] ) );;
gap> IsSynchronizingSemigroup(S);
false
gap> Representative(MinimalIdeal(S));
Transformation( [ 7, 7, 8, 7, 7, 7, 8, 7, 8, 7 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroGroup">
  <ManSection>
    <Prop Name="IsZeroGroup" Arg="S"/>
    <Description> 
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a zero group and <K>false</K> otherwise.<P/>

      A semigroup <C>S</C> is a <E>zero group</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>S</C> without <C>z</C> is a
      group and <C>x*z=z*x=z</C> for all <C>x</C> in <C>S</C>.
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5, 9 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4, 9 ] ),
> ConstantTransformation(9, 9));;
gap> IsZeroGroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSemigroup">
  <ManSection>
    <Prop Name="IsZeroSemigroup" Arg="S"/>
    <Description> 
      returns <K>true</K> if the transformation semigroup <A>S</A> is 
      a zero semigroup and <K>false</K> otherwise.<P/>

      A semigroup <C>S</C> is a <E>zero semigroup</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>x*y=z</C> for all <C>x,y</C>
      in <C>S</C>.

      <Example>
gap> S:=Semigroup( Transformation( [ 4, 7, 6, 3, 1, 5, 3, 6, 5, 9 ] ), 
> Transformation( [ 5, 3, 5, 1, 9, 3, 8, 7, 4, 3 ] ) );;
gap> IsZeroSemigroup(S);
false
gap> S:=Semigroup( Transformation( [ 7, 8, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 8, 5, 7, 8, 8 ] ), 
>  Transformation( [ 8, 7, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 7, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 7, 8, 5, 8, 8, 8 ] ) );;
gap> IsZeroSemigroup(S);
true
gap> MultiplicativeZero(S);
Transformation( [ 8, 8, 8, 8, 5, 8, 8, 8 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="MinimalIdeal">
  <ManSection>
    <Attr Name="MinimalIdeal" Arg="S"/>
    <Description>
    returns the minimal ideal of the transformation semigroup <A>S</A>. <P/>

    The minimal ideal of a semigroup is the least ideal with respect to
    containment. <P/> 

    Currently, <C>MinimalIdeal</C> returns a transformation semigroup with as
    many generators as elements. There are plans to improve this in future
    versions of <Package>Citrus</Package>. <P/>

    Note that <C>MinimalIdeal</C> is significantly faster than finding the
    <M>\mathcal{D}</M>-class with minimum rank representative (which is also
    the minimal ideal). 

    See also <Ref Attr="PartialOrderOfDClasses"/> and 
    <Ref Oper="IsGreensLessThanOrEqual" BookName="ref"/>. 
    
    <Example>
gap> S:=Semigroup( Transformation( [ 3, 4, 1, 3, 6, 3, 4, 6, 10, 1 ] ), 
> Transformation( [ 8, 2, 3, 8, 4, 1, 3, 4, 9, 7 ] ));;
gap> MinimalIdeal(S);
&lt;semigroup with 5 generators>
gap> Elements(MinimalIdeal(S));
[ Transformation( [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), 
  Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] ), 
  Transformation( [ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ] ), 
  Transformation( [ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 ] ), 
  Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] ) ]
gap> f:=Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] );;
gap> D:=DClass(S, f);
{Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] )}
gap> ForAll(GreensDClasses(S), x-> IsGreensLessThanOrEqual(D, x));
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>
    
<#GAPDoc Label="MultiplicativeZero">
  <ManSection>
    <Prop Name="MultiplicativeZero" Label="Citrus pkg" Arg="S"/>
    <Description> 
      returns the multiplicative zero of the transformation semigroup <A>S</A> 
      if it exists and returns <K>fail</K> otherwise.<P/> 

      See also <Ref Attr="MultiplicativeZero" BookName="ref"/>.
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 2, 6, 6, 5, 2 ] ), 
> Transformation( [ 1, 6, 3, 6, 2, 1, 6 ] ));;
gap> MultiplicativeZero(S);
Transformation( [ 1, 1, 1, 1, 1, 1, 1 ] )
S:=Semigroup(Transformation( [ 2, 8, 3, 7, 1, 5, 2, 6 ] ), 
> Transformation( [ 3, 5, 7, 2, 5, 6, 3, 8 ] ), 
> Transformation( [ 6, 7, 4, 1, 4, 1, 6, 2 ] ), 
> Transformation( [ 8, 8, 5, 1, 7, 5, 2, 8 ] ));;
gap> MultiplicativeZero(S);
fail</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallGeneratingSet">
  <ManSection>
    <Oper Name="SmallGeneratingSet" Arg="S"/>
    <Description>
      returns a generating set for the transformation semigroup <A>S</A> with
      a  relatively small number of elements. <P/>
      
      As neither irredundancy, nor 
      minimal length are proven, <C>SmallGeneratingSet</C> usually returns an
      answer  much faster than 
      <Ref Oper="IrredundantGeneratingSubset"/>. It can be used whenever a
      small 
      generating set is desired which does not necessarily needs to be optimal.
      Note that 
      <C>SmallGeneratingSet</C> may return different result in different &GAP; 
      sessions.

      <Example>
gap> S:=Semigroup( Transformation( [ 1, 2, 3, 2, 4 ] ), 
> Transformation( [ 1, 5, 4, 3, 2 ] ),
> Transformation( [ 2, 1, 4, 2, 2 ] ), Transformation( [ 2, 4, 4, 2, 1 ] ),
> Transformation( [ 3, 1, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ),
> Transformation( [ 4, 4, 3, 3, 5 ] ), Transformation( [ 5, 1, 5, 5, 3 ] ),
> Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 5, 5, 4, 5, 5 ] ) );;
gap> SmallGeneratingSet(S);                  
[ Transformation( [ 1, 5, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ), 
  Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 1, 2, 3, 2, 4 ] ), 
  Transformation( [ 4, 4, 3, 3, 5 ] ) ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

#EOF
