#############################################################################
##
#W  properties.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="AntiIsomorphismTransformationSemigroup">
  <ManSection>
    <Oper Name="AntiIsomorphismTransformationSemigroup" Arg="S"/>
    <Returns>An anti-isomorphism. 
    </Returns>
    <Description> 
      If <A>S</A> is a semigroup, then
      <C>AntiIsomorphismTransformationSemigroup</C> returns an anti-isomorphism
      from <A>S</A> to a transformation semigroup. At present, the degree of the
      resulting transformation semigroup equals the size of <A>S</A> plus 
      <M>1</M>, and, consequently, this function is of limited use. <P/>

      See also <Ref Oper="IsomorphismTransformationSemigroup" BookName="ref"/>. 

      <Example>
gap> file:=Concatenation(CitrusDir(), "/examples/selfcomp.citrus.gz");;
gap> S:=Semigroup(ReadCitrus(file, 34));;
gap> Size(S);
1016
gap> AntiIsomorphismTransformationSemigroup(S); 
MappingByFunction( &lt;semigroup with 7 generators>, &lt;semigroup with 
7 generators>, function( a ) ... end )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GroupOfUnits">
  <ManSection>
    <Attr Name="GroupOfUnits" Arg="S"/>
    <Returns>The group of units of a semigroup.</Returns>
    <Description>
      <C>GroupOfUnits</C> returns the group of units of the semigroup of
      transformations or partial permutations <A>S</A> as a subsemigroup of
      <A>S</A> if it exists and returns <K>fail</K> if it does not. Use <Ref
        Oper="IsomorphismPermGroup"/> if you require a permutation
      representation of the group of units.<P/>

      If a semigroup <A>S</A> has an identity <C>e</C>, then the <E>group of
        units</E> of <A>S</A> is the set of those <C>s</C> in <A>S</A> such that
      there exists <C>t</C> in <A>S</A> where <C>s*t=t*s=e</C>. Equivalently,
      the group of units is the &H;-class of the identity of <A>S</A>.<P/> 
      
      See also 
      <Ref Oper="GreensHClassOfElement" BookName="ref"/>,
      <Ref Prop="IsMonoidAsSemigroup"/>, and
      <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/>.

      <Example>
gap> S:=Semigroup(Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),
>   Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),
>   Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),
>   Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),
>   Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) );;
gap> Size(S);
5304
gap> StructureDescription(GroupOfUnits(S));
"C2 x S4"
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], 
> [ 2, 4, 5, 3, 6, 7, 10, 9, 8, 1 ] ),
> PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 10 ], 
> [ 8, 2, 3, 1, 4, 5, 10, 6, 9 ] ) );;
gap> StructureDescription(GroupOfUnits(S));
"C8"
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 3, 4 ], [ 4, 3, 5 ] ),
> PartialPermNC( [ 1, 2, 3, 5 ], [ 3, 1, 5, 2 ] ) );;
gap> GroupOfUnits(S);
fail</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IdempotentGeneratedSubsemigp">
  <ManSection>
    <Oper Name="IdempotentGeneratedSubsemigp" Arg="S"/>
    <Returns>A transformation semigroup.  
    </Returns>
    <Description> 
      <C>IdempotentGeneratedSubsemigp</C> returns the subsemigroup of the
      transformation semigroup <A>S</A> generated by the idempotents of 
      <A>S</A>.<P/>
      
      See also <Ref Attr="Idempotents"/> and <Ref Attr="SmallGeneratingSet"/>.
<Example>
gap> file:=Concatenation(CitrusDir(), "/examples/graph8c.citrus.gz");;
gap> S:=Semigroup(ReadCitrus(file, 13));;
gap> IdempotentGeneratedSubsemigp(S);
&lt;semigroup with 652 generators></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InjectionPrincipalFactor">
<ManSection>
  <Oper Name="InjectionPrincipalFactor" Arg="D"/>
  <Oper Name="IsomorphismReesMatrixSemigroup" Arg="D"/>
  <Returns>A injective mapping.</Returns>
  <Description> 
    If <A>D</A> is a &D;-class of a semigroup <C>S</C> and <A>D</A> is a
    subsemigroup of <C>S</C>, then 
    the <E>principal factor</E> of <A>D</A> is just <A>D</A> itself.
    If <A>D</A> is not a subsemigroup of <C>S</C>, then 
    the principal factor of <A>D</A> is 
    the semigroup with elements <A>D</A> and a new element <C>0</C> with
    multiplication of <M>x,y\in D</M> defined by:
    <Alt Not="Text">
      <Display>
        xy=\left\{\begin{array}{ll}
        x*y\ (\textrm{in }S)&amp;\textrm{if }x*y\in D\\
        0&amp;\textrm{if }xy\not\in D.
        \end{array}\right.
      </Display>
    </Alt>
    <Alt Only="Text">
      <C>xy</C> equals the product of <C>x</C> and <C>y</C> if it belongs to
      <A>D</A> and <C>0</C> if it does not. <P/>
    </Alt>
    <C>InjectionPrincipalFactor</C> returns an injective function
    from the &D;-class <A>D</A> to a Rees matrix semigroup, which
    contains the principal factor of <A>D</A> as a subsemigroup. <P/>

    If <A>D</A> is a subsemigroup of its parent semigroup, then the
    function returned by <C>InjectionPrincipalFactor</C> or
    <C>IsomorphismReesMatrixSemigroup</C> 
    is an isomorphism from <A>D</A> to a Rees matrix semigroup; see
    <Ref Func="ReesMatrixSemigroup" BookName="ref"/>.<P/>

    If <A>D</A> is not a semigroup, then the function returned by
    <C>InjectionPrincipalFactor</C> is an
    injective function from <A>D</A> to a Rees 0-matrix semigroup isomorphic
    to the principal factor of <A>D</A>; see 
    <Ref Func="ReesZeroMatrixSemigroup" BookName="ref"/>. In this case, 
    <C>IsomorphismReesMatrixSemigroup</C> returns an error.
    
    <Example>
gap> S:=InverseSemigroup(
> PartialPermNC( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] ),
> PartialPermNC( [ 1, 2, 3, 4, 6, 7, 8, 10 ], 
> [ 3, 8, 1, 9, 4, 10, 5, 6 ] ) );;
gap> f:=PartialPermNC([ 1, 2, 5, 6, 7, 9 ], [ 1, 2, 5, 6, 7, 9 ]);;
gap> d:=GreensDClassOfElement(S, f);
{&lt;identity on [ 1, 2, 5, 6, 7, 9 ]>}
gap> InjectionPrincipalFactor(d);
MappingByFunction( {&lt;identity on [ 1, 2, 5, 6, 7, 9 
 ]>}, Rees Zero Matrix Semigroup over &lt;zero group with 
2 generators>, function( f ) ... end, function( x ) ... end )
gap> rms:=Range(last);
Rees Zero Matrix Semigroup over &lt;zero group with 2 generators>
gap> SandwichMatrixOfReesZeroMatrixSemigroup(rms);
[ [ (), 0, 0 ], [ 0, (), 0 ], [ 0, 0, () ] ]
gap> Size(rms);
10
gap> Size(d);
9</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IrredundantGeneratingSubset">
  <ManSection>
    <Oper Name="IrredundantGeneratingSubset" Arg="coll"/>
    <Returns>    
    A list of transformations.
    </Returns>
    <Description>
      If <A>coll</A> is a transformation collection, then this function returns
      a subset <C>U</C> of <A>coll</A> or <C>Generators(<A>coll</A>)</C> such
      that no element of <C>U</C> is generated by the other elements of
      <C>U</C>.  <P/>

      See also <Ref Func="Generators"/>, 
      <Ref Prop="IsTransformationCollection" BookName="ref"/>, and 
      <Ref Oper="SmallGeneratingSet"/>.

      <Example>
gap> l:=[ Transformation( [ 6, 1, 1, 6, 1, 6, 1 ] ), 
>  Transformation( [ 3, 3, 3, 3, 3, 3, 3 ] ), 
>  Transformation( [ 6, 6, 6, 6, 6, 6, 6 ] ), 
>  Transformation( [ 5, 2, 4, 5, 1, 4, 5 ] ), 
>  Transformation( [ 2, 2, 2, 2, 2, 2, 2 ] ) ];;
gap> IrredundantGeneratingSubset(l);
[ Transformation( [ 2, 2, 2, 2, 2, 2, 2 ] ), 
  Transformation( [ 3, 3, 3, 3, 3, 3, 3 ] ), 
  Transformation( [ 5, 2, 4, 5, 1, 4, 5 ] ), 
  Transformation( [ 6, 1, 1, 6, 1, 6, 1 ] ) ]
gap> S:=Semigroup( Transformation( [ 5, 1, 4, 6, 2, 3 ] ),
> Transformation( [ 1, 2, 3, 4, 5, 6 ] ),
> Transformation( [ 4, 6, 3, 4, 2, 5 ] ),
> Transformation( [ 5, 4, 6, 3, 1, 3 ] ),
> Transformation( [ 2, 2, 6, 5, 4, 3 ] ),
> Transformation( [ 3, 5, 5, 1, 2, 4 ] ),
> Transformation( [ 6, 5, 1, 3, 3, 4 ] ),
> Transformation( [ 1, 3, 4, 3, 2, 1 ] ) );;
gap> IrredundantGeneratingSubset(S);
[ Transformation( [ 1, 3, 4, 3, 2, 1 ] ), 
  Transformation( [ 2, 2, 6, 5, 4, 3 ] ), 
  Transformation( [ 3, 5, 5, 1, 2, 4 ] ), 
  Transformation( [ 5, 1, 4, 6, 2, 3 ] ), 
  Transformation( [ 5, 4, 6, 3, 1, 3 ] ), 
  Transformation( [ 6, 5, 1, 3, 3, 4 ] ) ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<!-- JDM improve --> 
<#GAPDoc Label="IsAbundantSemigroup">
  <ManSection>
    <Prop Name="IsAbundantSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is abundant
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A transformation semigroup is <E>abundant</E> if and only if for all
      <M>f\in S</M> there exists an idempotent <M>e\in S</M> such that
      <M>\textrm{ker}(f)=\textrm{ker}(e)</M>.  <!-- hmm is this right, or do we
      require the existence of an idempotent e' such that im(e')=im(f) too? --> 
      <Example>
gap> gens:=[ Transformation( [ 1, 3, 2, 3 ] ),
>  Transformation( [ 1, 4, 1, 2 ] ),
>  Transformation( [ 2, 4, 1, 1 ] ),
>  Transformation( [ 3, 4, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsAbundantSemigroup(S);
true
gap> IsRegularSemigroup(S);
false</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsAdequateSemigroup">
  <ManSection>
    <Prop Name="IsAdequateSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is adequate
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A transformation semigroup is <E>adequate</E> if it is abundant and its
      idempotents commute. See <Ref Prop="IsAbundantSemigroup"/> and 
      <Ref Prop="IsBlockGroup"/>.
      <Example>
gap> S:=Semigroup(Transformation( [ 1, 7, 3, 8, 4, 2, 6, 5, 9 ] ),
>   Transformation( [ 1, 8, 6, 2, 3, 7, 4, 5, 9 ] ),
>   Transformation( [ 1, 9, 9, 9, 5, 6, 7, 9, 9 ] ));;
gap> IsAdequateSemigroup(S);
true
gap> S:=Semigroup( Transformation( [ 1, 3, 2, 3 ] ),
>  Transformation( [ 1, 4, 1, 2 ] ),
>  Transformation( [ 2, 4, 1, 1 ] ),
>  Transformation( [ 3, 4, 2, 2 ] ) );;
gap> IsAdequateSemigroup(S);
false</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBand">
  <ManSection>
    <Prop Name="IsBand" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is a band
          and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup is a <E>band</E> if every element is an idempotent. 
      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsBand(S);
true</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBlockGroup">
  <ManSection>
    <Prop Name="IsBlockGroup" Arg="S"/>
    <Prop Name="IsSemigroupWithCommutingIdempotents" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is a block
          group and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup <M>S</M> is a
      <E>block group</E> if every &L;-class and every
      &R;-class of 
      <M>S</M> contains at most one idempotent.  
      <Example>
gap> S:=Semigroup(Transformation( [ 5, 6, 7, 3, 1, 4, 2, 8 ] ),
>   Transformation( [ 3, 6, 8, 5, 7, 4, 2, 8 ] ));;
gap> IsBlockGroup(S);
true
gap> S:=Semigroup(Transformation( [ 2, 1, 10, 4, 5, 9, 7, 4, 8, 4 ] ),
> Transformation( [ 10, 7, 5, 6, 1, 3, 9, 7, 10, 2 ] ));;
gap> IsBlockGroup(S);
false</Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBrandtSemigroup">
  <ManSection>
    <Prop Name="IsBrandtSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is a Brandt
          group and <K>false</K> if it is not.</Returns>
    <Description>
      A semigroup <M>S</M> is a <E>Brandt semigroup</E> if and only if it is a 
       0-simple, inverse semigroup. 
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 8, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 5, 8, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 3, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 6, 8, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 1, 8, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 1, 8, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 4, 8, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 8, 7, 8, 8 ] ),
> Transformation( [ 8, 8, 8, 8, 8, 8, 2, 8 ] ));;
gap> IsBrandtSemigroup(S);
true</Example>
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCliffordSemigroup">
  <ManSection>
    <Prop Name="IsCliffordSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is a
          Clifford semigroup and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup <M>S</M> is a <E>Clifford 
      semigroup</E> if it is regular and its idempotents are central.

      <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
> Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsCliffordSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCommutativeSemigroup">
  <ManSection>
    <Prop Name="IsCommutativeSemigroup" Arg="S"/>
    <Returns> <K>true</K> if the transformation semigroup <A>S</A> is
          commutative and <K>false</K> if it is not. 
    </Returns> 
            <Description>
      The function 
      <Ref Prop="IsCommutative" BookName="ref"/> can also be used to test if a 
      semigroup is commutative.  <P/>

      A semigroup <A>S</A> is <E>commutative</E> if 
      <C>x*y=y*x</C> for all <C>x,y</C> in <A>S</A>.

      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCommutativeSemigroup(S);
true
gap> IsCommutative(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCompletelyRegularSemigroup">
  <ManSection>
    <Prop Name="IsCompletelyRegularSemigroup" Arg="S"/>
    <Returns>
      <K>true</K> if the transformation semigroup <A>S</A> is
          completely regular and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup is <E>completely regular</E> 
      if every element is contained in a subgroup.

      <Example>
gap> gens:=[ Transformation( [ 1, 2, 4, 3, 6, 5, 4 ] ), 
>  Transformation( [ 1, 2, 5, 6, 3, 4, 5 ] ), 
>  Transformation( [ 2, 1, 2, 2, 2, 2, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsCompletelyRegularSemigroup(S);
true
gap> S:=RandomTransformationSemigroup(5,5);;
gap> IsSimpleSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRTrivial">
  <ManSection><Heading>IsXTrivial</Heading>
    <Prop Name="IsRTrivial" Arg="S"/>
    <Prop Name="IsLTrivial" Arg="S"/>
    <Prop Name="IsHTrivial" Arg="S"/>
    <Prop Name="IsDTrivial" Arg="S"/>
    <Prop Name="IsAperiodicSemigroup" Arg="S"/>
    <Prop Name="IsCombinatorialSemigroup" Arg="S"/>
    <Returns>
      <K>true</K> if Green's &R;-relation, &L;-relation, &H;-relation,
      &D;-relation, respectively, on the
      transformation semigroup <A>S</A> is trivial and <K>false</K>
      if it is not.
    </Returns>
    <Description>
      These properties can be applied to a Green's class instead of a
      transformation semigroup where applicable. 
      <P/> 

      A semigroup is <E>aperiodic</E> if its contains no non-trivial
      subgroups (equivalently, all of its group &H;-classes 
      are trivial). A finite semigroup is aperiodic if and only if it is 
      &H;-trivial. <P/>

      <E>Combinatorial</E> is a synonym for aperiodic in this context. 
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 5, 1, 3, 7, 10, 6, 2, 7, 10 ] ), 
>  Transformation( [ 4, 4, 5, 6, 7, 7, 7, 4, 3, 10 ] ) );;
gap> IsHTrivial(S);
true
gap> Size(S);
108
gap> IsRTrivial(S);
false
gap> IsLTrivial(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsFactorisableSemigroup">
<ManSection>
  <Prop Name="IsFactorisableSemigroup" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    An inverse monoid is <E>factorisable</E> if every element is the product
    of an element of the group of units and an idempotent; see also 
    <Ref Attr="GroupOfUnits"/> and <Ref Attr="Idempotents"/>. Hence an
    inverse semigroup of partial permutations is factorisable if and only if
    each of its generators is the restriction of some element in the group of
    units. 
    <Example>
gap> S:=InverseSemigroup( PartialPermNC( [ 1, 2, 4 ], [ 3, 1, 4 ] ),
> PartialPermNC( [ 1, 2, 3, 5 ], [ 4, 1, 5, 2 ] ) );;
gap> IsFactorisableSemigroup(S);
false
gap> IsFactorisableSemigroup(SymmetricInverseSemigp(5)); 
true</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGroupAsSemigroup">
  <ManSection>
    <Prop Name="IsGroupAsSemigroup" Arg="S"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      If the semigroup of transformations or partial permutations <A>S</A>
      is actually a group, then <C>IsGroupAsSemigroup</C> returns <K>true</K>.
      If it is not a group, then <K>false</K> is returned.
      <Example>
gap> gens:=[ Transformation( [ 2, 4, 5, 3, 7, 8, 6, 9, 1 ] ), 
>  Transformation( [ 3, 5, 6, 7, 8, 1, 9, 2, 4 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsGroupAsSemigroup(S);
true
gap> g:=SymmetricGroup(5);;
gap> s:=Range(IsomorphismPartialPermSemigroup(g));
&lt;inverse semigroup with 2 generators>
gap> IsGroupAsSemigroup(s);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsIdempotentGenerated">
  <ManSection><Heading>IsIdempotentGenerated</Heading>
    <Prop Name="IsIdempotentGenerated" Arg="S"/>
    <Prop Name="IsSemiBand" Arg="S"/>
    <Returns> 
    <K>true</K> if the transformation semigroup <A>S</A> is
          generated by its idempotents and <K>false</K> if it is not. 
    </Returns>
    <Description>
      See also <Ref Oper="Idempotents"/>. <P/>

      A semigroup <A>S</A> is a <E>semiband</E> if it is generated by its 
      idempotent elements, i.e. semiband is a synonym of idempotent-generated
      in this context. 

      <Example>
gap> S:=FullTransformationSemigroup(4);;
gap> x:=Transformation( [ 1, 2, 3, 1 ] );;
gap> D:=GreensDClassOfElement(S, x);;
gap> T:=Semigroup(Elements(D));;
gap> IsIdempotentGenerated(T);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInverseSemigroup">
<ManSection>
  <Prop Name="IsInverseSemigroup" Arg="S"/>
  <Prop Name="IsInverseMonoid" Arg="S"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    If <A>S</A> is a semigroup of transformations or partial permutations, then
    <C>IsInverseSemigroup</C> returns <K>true</K> if <A>S</A> is an inverse
    semigroup and <K>false</K> if it is not. If <A>S</A> is monoid of
    transformations or partial permutations, then <C>IsInverseMonoid</C>
    returns <K>true</K> if <A>S</A> is an inverse semigroup and <K>false</K> if
    it is not.<P/>

    A semigroup is an <E>inverse semigroup</E> if every element 
    <C>x</C> has a unique semigroup inverse, that is, a unique
    element <C>y</C> such that <C>x*y*x=x</C> and <C>y*x*y=y</C>.

    <Example>
gap> gens:=[Transformation([1,2,4,5,6,3,7,8]),
> Transformation([3,3,4,5,6,2,7,8]),
> Transformation([1,2,5,3,6,8,4,4])];;
gap> S:=Semigroup(gens);;
gap> IsInverseSemigroup(S);
true</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<!-- the following does not currently exist! -->
<#GAPDoc Label="IsIrredundantGeneratingSet">
  <ManSection>
    <Oper Name="IsIrredundantGeneratingSet" Arg="[S, ]U"/>
    <Description>
      returns <K>true</K> if <C>u</C> is not an element of the subsemigroup 
      generated by <C>U</C> without <C>u</C> for all <C>u</C> in <C>U</C>.<P/>

      If the optional first argument is present, then 
      <C>IsIrredundantGeneratingSet</C> first checks that <C>U</C> generates 
      <A>S</A>.

      <Example></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftSimple">
  <ManSection>
    <Prop Name="IsLeftSimple" Arg="S"/>
    <Prop Name="IsRightSimple" Arg="S"/>
    <Returns> <K>true</K> if the transformation semigroup <A>S</A> has only one
    &L;-class or one &R;-class,
    respectively, and returns <K>false</K> if it has more than one. 
    </Returns>
<Description>
<Example>
gap> S:=Semigroup( Transformation( [ 6, 7, 9, 6, 8, 9, 8, 7, 6 ] ), 
>  Transformation( [ 6, 8, 9, 6, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 8, 9, 7, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 9, 8, 6, 7, 9, 7, 8, 6 ] ), 
>  Transformation( [ 6, 9, 9, 6, 8, 8, 7, 9, 6 ] ), 
>  Transformation( [ 6, 9, 9, 7, 8, 8, 6, 9, 7 ] ), 
>  Transformation( [ 7, 8, 8, 7, 9, 9, 7, 8, 6 ] ), 
>  Transformation( [ 7, 9, 9, 7, 6, 9, 6, 8, 7 ] ), 
>  Transformation( [ 8, 7, 6, 9, 8, 6, 8, 7, 9 ] ), 
>  Transformation( [ 9, 6, 6, 7, 8, 8, 7, 6, 9 ] ), 
>  Transformation( [ 9, 6, 6, 7, 9, 6, 9, 8, 7 ] ), 
>  Transformation( [ 9, 6, 7, 9, 6, 6, 9, 7, 8 ] ), 
>  Transformation( [ 9, 6, 8, 7, 9, 6, 9, 8, 7 ] ), 
>  Transformation( [ 9, 7, 6, 8, 7, 7, 9, 6, 8 ] ), 
>  Transformation( [ 9, 7, 7, 8, 9, 6, 9, 7, 8 ] ), 
>  Transformation( [ 9, 8, 8, 9, 6, 7, 6, 8, 9 ] ) );;
gap> IsRightSimple(S);
false
gap> IsLeftSimple(S);
true
gap> IsGroupAsSemigroup(S);
false
gap> NrRClasses(S);
16</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsLeftZeroSemigroup">
  <ManSection>
    <Prop Name="IsLeftZeroSemigroup" Arg="S"/>
    <Returns>  <K>true</K> if the transformation semigroup <A>S</A> is
          a left zero semigroup and <K>false</K> if it is not. 
    </Returns>
    <Description>
      A semigroup is a <E>left zero semigroup</E> if <C>x*y=x</C> for
      all <C>x,y</C>.

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
> Transformation( [ 1, 2, 3, 3, 3 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsLeftZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonogenicSemigroup">
  <ManSection>
    <Prop Name="IsMonogenicSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is monogenic
          and returns <K>false</K> if it is not.
   </Returns> 
    <Description>
      A semigroup is <E>monogenic</E> if it is generated by a single element.
      See also <Ref Attr="IndexPeriodOfTransformation"/>.
<Example>
gap> S:=Semigroup(
> Transformation( [ 2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10 ] ),
> Transformation( [ 2, 2, 2, 8, 11, 15, 11, 10, 2, 10, 11, 2, 10, 4, 7 ] ), 
> Transformation( [ 2, 2, 2, 11, 10, 8, 10, 11, 2, 11, 10, 2, 11, 11, 10 ] ),
> Transformation( [ 2, 2, 12, 7, 8, 14, 8, 11, 2, 11, 10, 2, 11, 15, 4 ] ));;
gap> IsMonogenicSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMonoidAsSemigroup">
  <ManSection>
    <Prop Name="IsMonoidAsSemigroup" Arg="S"/>
    <Returns><K>true</K> if <A>S</A> satisfies 
    <Ref Prop="IsTransformationMonoid" BookName="ref"/> or <A>S</A> satisfies
    <Ref Prop="IsTransformationSemigroup" BookName="ref"/> and <A>S</A> has
    an identity element and <K>false</K> if it does not. <P/>
    </Returns>
    <Description>
      See also <Ref Attr="MultiplicativeNeutralElement" BookName="ref"/> and
      <Ref Oper="IsomorphismTransformationMonoid"/>.
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsMonoidAsSemigroup(S);
true
gap> MultiplicativeNeutralElement(S);
Transformation( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 9 ] )
gap> S:=Monoid(Transformation( [ 8, 2, 8, 9, 10, 6, 2, 8, 7, 8 ] ),
> Transformation( [ 9, 2, 6, 3, 6, 4, 5, 5, 3, 2 ] ));;
gap> IsMonoidAsSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismTransformationMonoid">
<ManSection>
  <Oper Name="IsomorphismTransformationMonoid" Arg="S"/>
  <Oper Name="IsomorphismTransformationSemigroup" Arg="S"/>
  <Returns>An isomorphism.
  </Returns>
  <Description>
  <C>IsomorphismTransformationSemigroup(<A>S</A>)</C>
   returns an isomorphism from the semigroup <A>S</A> to an
   semigroup of transformations.<P/>

   <C>IsomorphismTransformationMonoid(<A>S</A>)</C> returns an isomorphism from
   the monoid <A>S</A> to a monoid of transformations. <P/>
   
   We only describe <C>IsomorphismTransformationMonoid</C>,
   the corresponding statements for <C>IsomorphismTransformationSemigroup</C>
   also hold.

   <List>

     <Mark>Partial permutation semigroup</Mark>
     <Item>
       If <A>S</A> is a partial permutation monoid, then
       <C>IsomorphismTransformationMonoid(<A>S</A>)</C> returns an isomorphism
       from <A>S</A> to a monoid of partial permutations on
       <C>[1..LargestMovedPoint(<A>S</A>)+1]</C> obtained using <Ref
         Func="AsTransformation"/>. The inverse of this isomorphism is obtained
       using <Ref Func="AsPartialPerm"/>; see <Ref Attr="LargestMovedPoint"
         Label="for a partial perm"/>, 
       <Ref Func="InverseMonoid"/> and <Ref Func="Monoid" BookName="ref"/>.
     </Item>
     
    <Mark>Permutation groups</Mark>
    <Item>
      If <A>S</A> is a permutation group, then
      <C>IsomorphismTransformationMonoid</C> returns an isomorphism from
      <A>S</A> to a transformation monoid acting on the set
      <C>[1..NrMovedPoints(<A>S</A>)]</C> obtained using 
      <Ref Func="AsTransformation"/>; see 
      <Ref Attr="NrMovedPoints" BookName="ref"/>.
    </Item>

    <Mark>Transformation semigroups</Mark>
    <Item>
      If <A>obj</A> is a transformation semigroup satisfying <Ref
      Prop="IsMonoidAsSemigroup"/>, then this function returns an isomorphism
      from <A>obj</A> to a transformation monoid. <P/>
    </Item>
  </List>

  <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 6, 2, 5, 3, 7, 8, 9, 9 ] ),
> Transformation( [ 6, 3, 2, 7, 5, 1, 8, 8, 9, 9 ] ) );;
gap> IsTransformationMonoid(S);
false
gap> IsMonoidAsSemigroup(S);
true
gap> M:=Range(IsomorphismTransformationMonoid(S));
&lt;monoid with 2 generators>
gap> IsTransformationMonoid(M);
true
MORE EXAMPLES</Example>
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismPartialPermSemigroup">
<ManSection>
  <Oper Name="IsomorphismPartialPermMonoid" Arg="S"/>
  <Oper Name="IsomorphismPartialPermSemigroup" Arg="S"/>
  <Returns>An isomorphism.</Returns>
  <Description>
    <C>IsomorphismPartialPermSemigroup(<A>S</A>)</C>
     returns an isomorphism from the inverse semigroup or group <A>S</A> to an
     inverse semigroup of partial permutations.<P/>

     <C>IsomorphismPartialPermMonoid(<A>S</A>)</C> returns an isomorphism from
     the inverse monoid or group <A>S</A> to an inverse monoid of partial
     permutations.<P/> 
     
     We only describe <C>IsomorphismPartialPermMonoid</C>,
     the corresponding statements for <C>IsomorphismPartialPermSemigroup</C>
     also hold.

     <List>

       <Mark>Partial permutation semigroups</Mark>
       <Item>
         If <A>S</A> is a partial permutation semigroup that does not satisfy
         <Ref Prop="IsMonoid" BookName="ref"/> but does satisfy <Ref
           Prop="IsMonoidAsSemigroup"/>, then
         <C>IsomorphismPartialPermMonoid(<A>S</A>)</C> returns an isomorphism
         from <A>S</A> to an inverse monoid of partial permutations; see
         <Ref Func="InverseMonoid"/>.
       </Item>
       
      <Mark>Permutation groups</Mark>
      <Item>
        If <A>S</A> is a permutation group, then
        <C>IsomorphismPartialPermMonoid</C> returns an isomorphism from
        <A>S</A> to an inverse monoid of partial permutations on the set
        <C>MovedPoints(<A>S</A>)</C> obtained using <Ref Func="AsPartialPerm"/>.
        The inverse of this isomorphism is obtained using <Ref
          Func="AsPermutation"/>; see <Ref Attr="MovedPoints" BookName="ref"/>.
      </Item>
      <Mark>Transformation semigroups</Mark>
      <Item>
        If <A>S</A> is a transformation semigroup satisfying <Ref
          Prop="IsInverseMonoid"/>, then
        <C>IsomorphismPartialPermMonoid</C> returns an isomorphism from
        <A>S</A> to an inverse monoid of partial permutations on a subset of
        <C>[1..DegreeOfTransformationSemigroup(<A>S</A>)]</C>.
      </Item>
    </List>
    <Example>
gap> s:=InverseSemigroup( 
> PartialPermNC( [ 1, 2, 3, 4, 5 ], [ 4, 2, 3, 1, 5 ] ),
> PartialPermNC( [ 1, 2, 4, 5 ], [ 3, 1, 4, 2 ] ) );;
gap> IsMonoid(s); 
false
gap> IsMonoidAsSemigroup(s);
true
gap> iso:=IsomorphismPartialPermMonoid(s)
MappingByFunction( &lt;inverse semigroup with 
2 generators>, &lt;inverse monoid with 
2 generators>, function( x ) ... end, function( x ) ... end )
gap> Size(s);
508
gap> Size(Range(iso));
508
gap> g:=Group((1,2)(3,8)(4,6)(5,7), (1,3,4,7)(2,5,6,8), (1,4)(2,6)(3,7)(5,8));;
gap> IsomorphismPartialPermSemigroup(g);
MappingByFunction( Group([ (1,2)(3,8)(4,6)(5,7), (1,3,4,7)(2,5,6,8),
  (1,4)(2,6)(3,7)(5,8) ]), &lt;inverse semigroup with
3 generators>, function( p ) ... end, function( f ) ... end )
gap> s:=Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;
gap> iso:=IsomorphismPartialPermMonoid(s);
MappingByFunction( &lt;inverse monoid with 2 generators>, &lt;inverse monoid with 
2 generators>, function( f ) ... end, function( x ) ... end )
gap> MovedPoint(Range(iso));
[ 1, 2, 3, 5, 6, 7 ]</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsomorphismPermGroup">
<ManSection>
  <Oper Name="IsomorphismPermGroup" Arg="S"/>
  <Returns>An isomorphism.
  </Returns>
  <Description>
    If the semigroup of transformations or partial permutations <A>S</A>
    satisfies <Ref Prop="IsGroupAsSemigroup"/>, then
    <C>IsomorphismPermGroup</C> returns an isomorphism to a permutation
    group.<P/> 
   
    If <A>S</A> does not satisfy <Ref Prop="IsGroupAsSemigroup"/>,
    then an error is given.

<Example>
gap> S:=Semigroup( Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4 ] ) );;
gap> IsGroupAsSemigroup(S);
true
gap> IsomorphismPermGroup(S); 
MappingByFunction( &lt;semigroup with 2 generators>, Group([ (5,6,8), (2,3,8,4) 
]), &lt;Operation "AsPermutation"> )
gap> StructureDescription(Range(IsomorphismPermGroup(S)));
"S6"
gap> s:=Range(IsomorphismPartialPermSemigroup(SymmetricGroup(4)));
&lt;inverse semigroup with 2 generators>
gap> IsomorphismPermGroup(s);
MappingByFunction( &lt;inverse semigroup with 2 generators>, Group(
[ (1,2,3,4), (1,2) ]), &lt;Operation "AsPermutation">, function( x ) ... end )</Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsOrthodoxSemigroup">
  <ManSection>
    <Prop Name="IsOrthodoxSemigroup" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is 
      orthodox and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup is <E>orthodox</E> if it is regular and its  
      idempotent elements form a subsemigroup.<P/>

      See also <Ref Prop="IsRegularSemigroup"/> and 
      <Ref Prop="IsRegularSemigroup" BookName="ref"/>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 5, 4 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 2 ] ), 
>  Transformation( [ 1, 2, 3, 1, 1, 3 ] ), 
>  Transformation( [ 5, 5, 5, 5, 5, 5 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsOrthodoxSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRectangularBand">
  <ManSection>
    <Prop Name="IsRectangularBand" Arg="S"/>
    <Returns>
      <K>true</K> if the transformation semigroup <A>S</A> is a 
      rectangular band and <K>false</K> if it is not.
      </Returns>
    <Description>
      A semigroup <A>S</A> is a <E>rectangular band</E> if for all <C>x,y,z</C> 
      in <A>S</A> we have that <C>x^2=x</C> and <C>xyz=xz</C>.

      <Example>
gap> gens:=[ Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 1 ] ), 
> Transformation( [ 2, 2, 2, 5, 5, 5, 8, 8, 8, 2 ] ), 
> Transformation( [ 3, 3, 3, 6, 6, 6, 9, 9, 9, 3 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 4 ] ), 
> Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRectangularBand(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularSemigroup">
  <ManSection>
    <Prop Name="IsRegularSemigroup" Arg="S"/>
    <Returns>
      <K>true</K> if the transformation semigroup <A>S</A> is regular
       and <K>false</K> if it is not. <P/>
    </Returns>
    <Description>
      A semigroup <C>S</C> is <E>regular</E> if for all <C>x</C> in <C>S</C> 
      there exists <C>y</C> in <C>S</C> such that <C>x*y*x=x</C>.

      See also <Ref Prop="IsRegularDClass" BookName="ref"/>,
      <Ref Func="IsRegularDClass"/>,   
      and <Ref Func="IsRegularTransformation"/>.
      
      <Example>
gap> IsRegularSemigroup(FullTransformationSemigroup(5));
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRightZeroSemigroup">
  <ManSection>
    <Prop Name="IsRightZeroSemigroup" Arg="S"/>
    <Returns>
    <K>true</K> if the transformation semigroup <A>S</A> is 
      a right zero semigroup and <K>false</K> if it is not.
    </Returns>

    <Description>
      A semigroup <C>S</C> is a <E>right zero semigroup</E> if <C>x*y=y</C> for 
      all <C>x,y</C> in <C>S</C>.

      <Example>
gap> gens:=[ Transformation( [ 2, 1, 4, 3, 5 ] ), 
>  Transformation( [ 3, 2, 3, 1, 1 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
false
gap> gens:=[Transformation( [ 1, 2, 3, 3, 1 ] ), 
>  Transformation( [ 1, 2, 4, 4, 1 ] )];;
gap> S:=Semigroup(gens);;
gap> IsRightZeroSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSemilatticeAsSemigroup">
  <ManSection>
    <Prop Name="IsSemilatticeAsSemigroup" Arg="S"/>
    <Returns>
    <K>true</K> if the semigroup <A>S</A> is a semilattice 
      and <K>false</K> if it is not.
    </Returns>
      
    <Description>
      A semigroup is a
      <E>semilattice</E> if it is commutative and every element is an 
      idempotent.
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 5, 1, 7, 3, 7, 7 ] ), 
> Transformation( [ 3, 6, 5, 7, 2, 1, 7 ] ) );;                    
gap> Size(S);
631
gap> IsInverseSemigroup(S);
true
gap> A:=Semigroup(Idempotents(S)); 
&lt;semigroup with 32 generators>
gap> IsSemilatticeAsSemigroup(A);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleSemigroup">
  <ManSection><Heading>IsSimpleSemigroup</Heading>
    <Prop Name="IsSimpleSemigroup" Arg="S"/>
    <Prop Name="IsCompletelySimpleSemigroup" Arg="S"/>
    <Returns>
    <K>true</K> if the transformation semigroup <A>S</A> is simple 
      and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup is <E>simple</E> if it has no proper
      2-sided ideals. A semigroup is <E>completely simple</E> if it is simple 
      and possesses minimal left and right ideals. A finite semigroup is simple 
      if and only if it is completely simple. 

      <Example>
gap> gens:=[ Transformation( [ 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 2 ] ), 
>  Transformation( [ 1, 1, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11, 3 ] ), 
>  Transformation( [ 1, 7, 3, 9, 5, 11, 7, 1, 9, 3, 11, 5, 5 ] ), 
>  Transformation( [ 7, 7, 9, 9, 11, 11, 1, 1, 3, 3, 5, 5, 7 ] ) ];;
gap> S:=Semigroup(gens);;
gap> IsSimpleSemigroup(S);
true
gap> IsCompletelySimpleSemigroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSynchronizingSemigroup">
  <ManSection>
    <Prop Name="IsSynchronizingSemigroup" Arg="S"/>
    <Returns>
      <K>true</K> if the transformation semigroup <A>S</A> contains a
      constant transformation. 
    </Returns>
    <Description>
      See also <Ref Oper="ConstantTransformation"/>. 
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 1, 8, 7, 6, 6, 4, 1, 8, 9 ] ), 
>  Transformation( [ 5, 8, 7, 6, 10, 8, 7, 6, 9, 7 ] ) );;
gap> IsSynchronizingSemigroup(S);
true
gap> S:=Semigroup( Transformation( [ 3, 8, 1, 1, 9, 9, 8, 7, 9, 6 ] ), 
>  Transformation( [ 7, 6, 8, 7, 5, 6, 8, 7, 8, 9 ] ) );;
gap> IsSynchronizingSemigroup(S);
false
gap> Representative(MinimalIdeal(S));
Transformation( [ 7, 7, 8, 7, 7, 7, 8, 7, 8, 7 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroGroup">
  <ManSection>
    <Prop Name="IsZeroGroup" Arg="S"/>
    <Returns>
    <K>true</K> if the transformation semigroup <A>S</A> is 
      a zero group and <K>false</K> if it is not.
    </Returns>
    <Description> 
      A semigroup <C>S</C> is a <E>zero group</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>S</C> without <C>z</C> is a
      group and <C>x*z=z*x=z</C> for all <C>x</C> in <C>S</C>.
      <Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 3, 4, 6, 8, 5, 5, 9 ] ),
> Transformation( [ 3, 3, 8, 2, 5, 6, 4, 4, 9 ] ),
> ConstantTransformation(9, 9));;
gap> IsZeroGroup(S);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroRectangularBand">
  <ManSection>
    <Prop Name="IsZeroRectangularBand" Arg="S"/>
    <Returns><K>true</K> if the transformation semigroup <A>S</A> is a zero
          rectangular band and <K>false</K> if it is not.
    </Returns>
    <Description>
      A semigroup a <E>zero rectangular band</E> if it is zero simple and
      &H;-trivial; see also <Ref Prop="IsZeroSimpleSemigroup"/>
      and <Ref Prop="IsHTrivial"/>.
<Example>
gap> S:=Semigroup( 
>  Transformation( [ 1, 3, 7, 9, 1, 12, 13, 1, 15, 9, 1, 18, 1, 1, 13, 1, 1, 
>      21, 1, 1, 1, 1, 1, 25, 26, 1 ] ),
> Transformation( [ 1, 5, 1, 5, 11, 1, 1, 14, 1, 16, 17, 1, 1, 19, 1, 11, 1,
>      1, 1, 23, 1, 16, 19, 1, 1, 1 ] ),
> Transformation( [ 1, 4, 8, 1, 10, 1, 8, 1, 1, 1, 10, 1, 8, 10, 1, 1, 20, 1,
>      22, 1, 8, 1, 1, 1, 1, 1 ] ),
> Transformation( [ 1, 6, 6, 1, 1, 1, 6, 1, 1, 1, 1, 1, 6, 1, 6, 1, 1, 6, 1,
>      1, 24, 1, 1, 1, 1, 6 ] ) );;
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[9]))); 
true
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[3])));
true
gap> IsZeroRectangularBand(Semigroup(Elements(GreensDClasses(S)[1])));
false</Example>
    </Description>
  </ManSection>  
<#/GAPDoc>

<#GAPDoc Label="IsZeroSemigroup">
  <ManSection>
    <Prop Name="IsZeroSemigroup" Arg="S"/>
    <Returns> <K>true</K> if the transformation semigroup <A>S</A> is 
      a zero semigroup and <K>false</K> if it is not.
    </Returns>
    <Description> 
      A semigroup <C>S</C> is a <E>zero semigroup</E> if there exists an 
      element <C>z</C> in <C>S</C> such that <C>x*y=z</C> for all <C>x,y</C>
      in <C>S</C>.

      <Example>
gap> S:=Semigroup( Transformation( [ 4, 7, 6, 3, 1, 5, 3, 6, 5, 9 ] ), 
> Transformation( [ 5, 3, 5, 1, 9, 3, 8, 7, 4, 3 ] ) );;
gap> IsZeroSemigroup(S);
false
gap> S:=Semigroup( Transformation( [ 7, 8, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 8, 5, 7, 8, 8 ] ), 
>  Transformation( [ 8, 7, 8, 8, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 8, 7, 5, 8, 8, 8 ] ), 
>  Transformation( [ 8, 8, 7, 8, 5, 8, 8, 8 ] ) );;
gap> IsZeroSemigroup(S);
true
gap> MultiplicativeZero(S);
Transformation( [ 8, 8, 8, 8, 5, 8, 8, 8 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsZeroSimpleSemigroup">
  <ManSection>
    <Prop Name="IsZeroSimpleSemigroup" Arg="S"/>
    <Returns> 
     <K>true</K> if the transformation semigroup <A>S</A> is
      a zero simple semigroup and <K>false</K> if it is not.
    </Returns>

    <Description>
      A semigroup is a <E>zero simple semigroup</E> if it has no two-sided 
      ideals other than itself and the set containing the zero element; see
      also <Ref Attr="MultiplicativeZero"/>. 

      <Example>
gap> S:=Semigroup( 
>  Transformation( [ 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 5, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 17, 11, 17, 17, 17, 17, 17, 17, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 17, 17, 17, 17, 17, 17, 17, 4, 17, 
>  17, 17, 17, 17, 17 ] ), 
>  Transformation( [ 1, 17, 17, 5, 17, 17, 17, 17, 17, 17, 17, 17, 
>  17, 17, 17, 17, 17 ] ));;
gap> IsZeroSimpleSemigroup(S);
true
gap> S:=Semigroup(
> Transformation( [ 2, 3, 4, 5, 1, 8, 7, 6, 2, 7 ] ),
> Transformation([ 2, 3, 4, 5, 6, 8, 7, 1, 2, 2 ] ));;
gap> IsZeroSimpleSemigroup(S);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="MinimalIdeal">
  <ManSection>
    <Attr Name="MinimalIdeal" Arg="S"/>
    <Returns> 
    The minimal ideal of the transformation semigroup <A>S</A>. 
    </Returns>
    <Description>
    The minimal ideal of a semigroup is the least ideal with respect to
    containment. <P/> 

    Currently, <C>MinimalIdeal</C> returns a transformation semigroup with as
    many generators as elements. There are plans to improve this in future
    versions of <Package>Citrus</Package>. <P/>

    Note that <C>MinimalIdeal</C> is significantly faster than finding the
    &D;-class with minimum rank representative (which is also
    the minimal ideal). 

    See also <Ref Attr="PartialOrderOfDClasses"/> and 
    <Ref Oper="IsGreensLessThanOrEqual" BookName="ref"/>. 
    
    <Example>
gap> S:=Semigroup( Transformation( [ 3, 4, 1, 3, 6, 3, 4, 6, 10, 1 ] ), 
> Transformation( [ 8, 2, 3, 8, 4, 1, 3, 4, 9, 7 ] ));;
gap> MinimalIdeal(S);
&lt;semigroup with 5 generators>
gap> Elements(MinimalIdeal(S));
[ Transformation( [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ] ), 
  Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] ), 
  Transformation( [ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ] ), 
  Transformation( [ 6, 6, 6, 6, 6, 6, 6, 6, 6, 6 ] ), 
  Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] ) ]
gap> f:=Transformation( [ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 ] );;
gap> D:=DClass(S, f);
{Transformation( [ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 ] )}
gap> ForAll(GreensDClasses(S), x-> IsGreensLessThanOrEqual(D, x));
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>
    
<#GAPDoc Label="MultiplicativeZero">
  <ManSection>
    <Attr Name="MultiplicativeZero" Arg="S"/>
    <Returns>
     The multiplicative zero of the transformation semigroup <A>S</A> 
      if it exists and <K>fail</K> if it does not.<P/> 
    </Returns>
    <Description>
      See also <Ref Attr="MultiplicativeZero" BookName="ref"/>.
      <Example>
gap> S:=Semigroup( Transformation( [ 1, 4, 2, 6, 6, 5, 2 ] ), 
> Transformation( [ 1, 6, 3, 6, 2, 1, 6 ] ));;
gap> MultiplicativeZero(S);
Transformation( [ 1, 1, 1, 1, 1, 1, 1 ] )
gap> S:=Semigroup(Transformation( [ 2, 8, 3, 7, 1, 5, 2, 6 ] ), 
> Transformation( [ 3, 5, 7, 2, 5, 6, 3, 8 ] ), 
> Transformation( [ 6, 7, 4, 1, 4, 1, 6, 2 ] ), 
> Transformation( [ 8, 8, 5, 1, 7, 5, 2, 8 ] ));;
gap> MultiplicativeZero(S);
fail</Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NaturalPartialOrder">
<ManSection>
  <Oper Name="NaturalPartialOrder" Arg="S"/>
  <Returns>The natural partial order on an inverse semigroup.</Returns>
  <Description>
    The <E>natural partial order</E> <M>\leq</M> on an inverse semigroup
    <M>S</M> is defined by <M>s\leq</M><M>t</M> if there exists an idempotent
    <M>e</M> in <M>S</M> such that <M>s=et</M>. Hence if <A>f</A> and
    <A>g</A> are partial permutations, then <A>f</A><M>\leq</M><A>g</A> if
    and only if <A>f</A> is a restriction of <A>g</A>;
    see <Ref Oper="RestrictedPartialPerm"/>.<P/> 

    <C>NaturalPartialOrder</C> returns the natural partial order on the inverse
    semigroup of partial permutations <A>S</A> as a list of sets of positive
    integers where entry <C>i</C> in <C>NaturalPartialOrder(<A>S</A>)</C> is
    the set of positions in <C>Elements(<A>S</A>)</C> of elements less than
    <C>Elements(<A>S</A>)[i]</C>. See also 
    <Ref Func="NaturalLeqPartialPerm"/>.<P/>
  
    <Example>
gap> S:=InverseSemigroup([ PartialPermNC( [ 1, 3 ], [ 1, 3 ] ),
> PartialPermNC( [ 1, 2 ], [ 3, 2 ] ) ] );
&lt;inverse semigroup with 2 generators>
gap> Size(S);
11
gap> NaturalPartialOrder(S);
[ [  ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 1 ], [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], 
  [ 1, 2, 6 ], [ 1, 4, 5 ], [ 1, 4, 6 ] ]
gap> NaturalLeqPartialPerm(Elements(S)[4], Elements(S)[10]);
true
gap> NaturalLeqPartialPerm(Elements(S)[4], Elements(S)[9]); 
false</Example>
  </Description>
</ManSection>
<#/GAPDoc>

</ManSection>
<#GAPDoc Label="NrElementsOfRank">
  <ManSection>
    <Attr Name="NrElementsOfRank" Arg="S, n"/>
    <Returns>the number of elements of a given rank. </Returns>
    <Description><C>NrElementsOfRank</C> returns the number of elements of the
    transformation semigroup <A>S</A> with rank <A>n</A>; see 
    <Ref Func="Rank" Label="for a transformation"/>, 
    <Ref Func="RankOfPartialPerm"/> and
    <Ref Attr="RankOfTransformation" BookName="ref"/>.

    <Example>
gap> S:=Semigroup( Transformation( [ 1, 3, 4, 1, 3 ] ), 
> Transformation( [ 2, 4, 1, 5, 5 ] ), 
> Transformation( [ 2, 5, 3, 5, 3 ] ), 
> Transformation( [ 4, 1, 2, 2, 1 ] ), 
>  Transformation( [ 5, 5, 1, 1, 3 ] ) );;
gap> NrElementsOfRank(S, 1);
5
gap> NrElementsOfRank(S, 2);
260
gap> NrElementsOfRank(S, 3);
336
gap> NrElementsOfRank(S, 4);
1
gap> NrElementsOfRank(S, 5);
0
gap> NrElementsOfRank(S, 10);
0
gap> Size(S);
602
gap> List([1..5], x-> NrElementsOfRank(S, x));
[ 5, 260, 336, 1, 0 ]
gap> Sum(last);
602
gap> T:=FullTransformationSemigroup(5);;
gap> List([1..5], x-> NrElementsOfRank(T, x));
[ 5, 300, 1500, 1200, 120 ]
gap> Sum(last);
3125</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SmallGeneratingSet">
  <ManSection>
    <Attr Name="SmallGeneratingSet" Arg="S"/>
      <Returns>
      A generating set for the transformation semigroup <A>S</A> with
      a relatively small number of elements. <P/>
      </Returns>
    <Description>
      As neither irredundancy, nor minimal length are proven,
      <C>SmallGeneratingSet</C> usually returns an answer  much faster than
      <Ref Oper="IrredundantGeneratingSubset"/>. It can be used whenever a
      small generating set is desired which does not necessarily needs to be
      optimal.  Note that <C>SmallGeneratingSet</C> may return different
      results in different &GAP; sessions.

      <Log>
gap> S:=Semigroup( Transformation( [ 1, 2, 3, 2, 4 ] ), 
> Transformation( [ 1, 5, 4, 3, 2 ] ),
> Transformation( [ 2, 1, 4, 2, 2 ] ), Transformation( [ 2, 4, 4, 2, 1 ] ),
> Transformation( [ 3, 1, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ),
> Transformation( [ 4, 4, 3, 3, 5 ] ), Transformation( [ 5, 1, 5, 5, 3 ] ),
> Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 5, 5, 4, 5, 5 ] ) );;
gap> SmallGeneratingSet(S);                  
[ Transformation( [ 1, 5, 4, 3, 2 ] ), Transformation( [ 3, 2, 3, 4, 1 ] ), 
  Transformation( [ 5, 4, 3, 5, 2 ] ), Transformation( [ 1, 2, 3, 2, 4 ] ), 
  Transformation( [ 4, 4, 3, 3, 5 ] ) ]</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

#EOF
