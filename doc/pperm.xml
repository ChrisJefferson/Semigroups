#############################################################################
##
#W  pperm.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="PartialPerm"/>
  <ManSection>
    <Func Name="PartialPerm" Arg="dom, ran"/>
    <Func Name="PartialPerm" Arg="list"/>
    <Func Name="PartialPermNC" Arg="dom, ran"/>
    <Func Name="PartialPermNC" Arg="list"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      Partial permutations can be created in two ways: by giving the domain
      and the range, or the dense range list. <P/>

      The partial permutation defined by a domain <A>dom</A> and range
      <A>ran</A>, where <A>dom</A> is a set of positive integers and
      <A>ran</A> is a duplicate free list of positive integers, maps
      <A>dom</A><C>[i]</C> to <A>ran</A><C>[i]</C>. For example,
      the partial permutation mapping <M>1</M> and <M>5</M> to <M>20</M> and
      <M>2</M> can be created using: 
      <Log>PartialPermNC([1,5],[20,2]); </Log> <P/>

      The partial permutation defined by a dense range list <A>list</A>, maps
      the positive integer <C>i</C> to <A>list</A><C>[i]</C> if
      <A>list</A><C>[i]&lt;&gt;>0</C> and is undefined at <C>i</C> if 
      <A>list</A><C>[i]=0</C>.  For example, the partial permutation mapping
      <M>1</M> and <M>5</M> to <M>20</M> and <M>2</M> can be created
      using: <Log>PartialPermNC([20,0,0,0,2]);</Log><P/>

      Regardless of which of these two methods are used to create a partial
      permutation in &GAP; the internal representation is the same. <P/>

      If the largest point in the domain is larger than the
      rank of the partial permutation, then using the dense range list to
      define the partial permutation will require less typing; otherwise
      using the domain and the range will require less typing. For example,
      the partial permutation mapping <M>10000</M> to <M>1</M> can be defined
      using:
      <Log>PartialPermNC([10000], [1]);</Log>
      but using the dense range list would require a list with <M>9999</M>
      entries equal to <M>0</M> and the final entry equal to <M>1</M>. 
      On the other hand, the identity on <C>[1,2,3,4,6]</C> can be defined
      using:
      <Log>PartialPermNC([1,2,3,4,0,6]);</Log>
      <P/>
      
      <C>PartialPerm</C> checks that the argument defines a partial
      permatutation whereas <C>PartialPermNC</C> does not.
      <C>PartialPermNC</C> is a kernel function written in C, which performs
      no checks on it argument, and so if the argument does not define a
      partial permutation, then the results can be unpredictable, and it
      could even potentially cause &GAP; to crash. <P/>

      It is currently only possible to create partial permutations acting 
      on positive integers not greater than <M>65535</M>. Note that this
      might cause some unexpected behaviour when multiplying partial
      permutations by permutations. For example, if
      <C>f:=PartialPerm([1,2,3]);</C>, then 
      <C>f*(1,100000)*(1,100000)</C> will return an error since the result of
      <C>f*(1,100000)</C> would be a partial permutation acting on too many
      points. However, the product <C>f*((1,100000)*(1,100000))</C> is just
      <C>f</C> and no error is given.
      <P/>

      Please note that a partial permutation in &GAP; is never a permutation
      nor is a permutation ever a partial permutation. For example, the
      permutation <C>(1,4,2)</C> fixes <C>3</C> but the partial permutation
      <C>PartialPerm([4,1,0,2]);</C> is not defined on <C>3</C>. 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DomainOfPartialPerm"/>
  <ManSection>
    <Oper Name="DomainOfPartialPerm" Arg="f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      The <E>domain</E> of a partial permutation <A>f</A> is the set of
      positive integers where <A>f</A> is defined. 
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );;
gap> DomainOfPartialPerm(f);
[ 1, 2, 3, 6, 8, 10 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RangeOfPartialPerm"/>
  <ManSection>
    <Oper Name="RangeOfPartialPerm" Arg="f"/>
    <Returns>A duplicate-free list of positive integers.</Returns>
    <Description>
      The <E>range</E> of a partial permutation <A>f</A> is the list of images
      of the elements of the domain <A>f</A> where
      <C>RangeOfPartialPerm(f)[i]=DomainOfPartialPerm(f)[i]^f.</C>
<Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 5, 8, 10 ], [ 7, 1, 4, 3, 2, 6, 5 ] );;
gap> RangeOfPartialPerm(f);
[ 7, 1, 4, 3, 2, 6, 5 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RangeSetOfPartialPerm"/>
  <ManSection>
    <Oper Name="RangeSetOfPartialPerm" Arg="f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      The range of a partial permutation <A>f</A> is the list of images of the
      elements of the domain <A>f</A>. <C>RangeSetOfPartialPerm</C> returns the
      range of a partial permutation sorted into increasing order. 
      <Example>
gap>f:=PartialPermNC( [ 1, 2, 3, 5, 7, 10 ], [ 10, 2, 3, 5, 7, 6 ] );;
gap> RangeSetOfPartialPerm(f);
[ 2, 3, 5, 6, 7, 10 ]</Example>
    </Description> 
  </ManSection> 
<#/GAPDoc>

<#GAPDoc Label="OnIntegerSetsWithPartialPerm"/>
  <ManSection>
    <Oper Name="OnIntegerSetsWithPartialPerm" Arg="set, f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      <C>OnIntegerSetsWithPartialPerm</C> is a special method for <Ref
        Func="OnSets" BookName="ref"/> for a set of positive integers
      <A>set</A> and a partial permutation <A>f</A>.
      <Example>
gap> f:=PartialPermNC([ 1, 2, 4, 5, 6, 8, 9, 10, 11, 15, 16, 17, 18 ],
> [ 13, 20, 2, 14, 18, 7, 3, 19, 9, 11, 5, 16, 8 ]);;
gap> OnSets([1,2,3], f);
[ 13, 20, fail ]
gap> OnIntegerSetsWithPartialPerm([1,2,3], f);
[ 13, 20 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="LeftOne"/>
  <ManSection>
    <Func Name="LeftOne" Arg="f"/>
    <Func Name="RightOne" Arg="f"/>
    <Returns>The idempotent partial permutation <A>f</A><C>*</C><A>f^-1</A> or
      <A>f^-1</A><C>*</C><A>f</A>.
    </Returns>
    <Description>
      <C>LeftOne</C> returns the identity partial permutation on
      <C>DomainOfPartialPerm(<A>f</A>)</C>, which is equal to
      <A>f</A><C>*</C><A>f^-1</A>; see <Ref Func="DomainOfPartialPerm"/>.<P/>

      <C>RightOne</C> returns the idenpartial permutation on
      <C>RangeOfPartialPerm(<A>f</A>)</C>, which is equal to 
      <A>f^-1</A><C>*</C><A>f</A>; see <Ref Func="RangeOfPartialPerm"/>.<P/>

      The methods for <C>LeftOne</C> and <C>RightOne</C> are more efficient
      than composing <A>f</A> with <A>f^-1</A> or vice versa. 
      
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ], 
[ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ] );;
gap> LeftOne(f);
&lt;identity on [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ]>
gap> RightOne(f);
&lt;identity on [ 2, 3, 4, 5, 8, 9, 10, 11, 12, 14, 15, 17, 18, 19, 20 ]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="FixedPointsOfPartialPerm"/>
  <ManSection>
    <Oper Name="FixedPointsOfPartialPerm" Arg="f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      A positive integer <C>i</C> is fixed by a partial permutation <A>f</A> if
      <C>i^</C><A>f</A><C>=i</C>. <C>FixedPointsOfPartialPerm</C> returns the
      set of points fixed by the partial permutation <A>f</A>.
      <Example>
gap> f:=PartialPermNC( 
> [ 1, 2, 3, 5, 6, 8, 10, 11, 14, 17, 20, 21, 22, 24, 25, 26, 32 ], 
> [ 30, 20, 29, 24, 9, 14, 26, 5, 25, 15, 11, 6, 35, 2, 10, 19, 23 ] );;
gap> FixedPointsOfPartialPerm(f);
[  ]
gap> f:=PartialPermNC([1..10]);
&lt;identity on [ 1 .. 10 ]>
gap> FixedPointsOfPartialPerm(f);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RestrictedPartialPerm"/>
  <ManSection>
    <Oper Name="RestrictedPartialPerm" Arg="f, set"/>
    <Oper Name="RestrictedPartialPermNC" Arg="f, set"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      <C>RestrictedPartialPerm</C> returns a new partial permutation that acts
      on the points in the set of positive integers <A>set</A> in  the  same
      way as the partial permutation <A>f</A>, and that is undefined on those
      points that are not in <A>set</A>.<P/>

      <C>RestrictedPartialPermNC</C> does not check whether <A>set</A> is a set
      of positive integers, if it is not, then the results of this function
      are unpredictable.

      <Example>
gap> f:=PartialPermNC( [ 1, 3, 4, 7, 8, 9 ], [ 9, 4, 1, 6, 2, 8 ] );;
gap> RestrictedPartialPerm(f, [2,3,6,10]);
[ 3 ] -> [ 4 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NaturalLeqPP"/>
  <ManSection>
    <Func Name="NaturalLeqPP" Arg="f, g"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      The <E>natural partial order</E> <M>\leq</M> on an inverse semigroup
      <M>S</M> is defined by <M>s\leq</M><M>t</M> if there exists an idempotent
      <M>e</M> in <M>S</M> such that <M>s=et</M>. Hence if <A>f</A> and
      <A>g</A> are partial permutations, then <A>f</A><M>\leq</M><A>g</A> if
      and only if <A>f</A> is a restriction of <A>g</A>; 
      see <Ref Oper="RestrictedPartialPerm"/>. <C>NaturalLeqPP</C>
      returns <K>true</K> if <A>f</A> is a restriction of <A>g</A> and
      <K>false</K> if it is not. 
      <Example> 
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ], 
[ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ] );;
gap> gap> set:=[ 1, 2, 3, 9, 13, 20 ];;
gap> g:=RestrictedPartialPerm(f, set);
[ 1 .. 3 ] -> [ 3, 12, 14 ]
gap> NaturalLeqPP(g,f);
true
gap> NaturalLeqPP(f,g);
false
gap> g:=PartialPermNC( [ 1, 2, 3, 4, 5, 8, 10 ], [ 7, 1, 4, 3, 2, 6, 5 ] );;
gap> NaturalLeqPP(f, g);
false
gap> NaturalLeqPP(g, f);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsPartialPerm"/>
  <ManSection>
    <Filt Name="IsPartialPerm" Arg="obj" Type="category"/>
    <Filt Name="IsPartialPermCollection" Arg="obj" Type="category"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      Each <E>partial permutation</E> in &GAP; lies in the category
      <C>IsPartialPerm</C>. Basic operations for partial permutations are 
      <Ref Oper="DomainOfPartialPerm"/>, <Ref Oper="RangeOfPartialPerm"/>, 
      <Ref Oper="RangeSetOfPartialPerm"/>, <Ref Oper="RankOfPartialPerm"/>,
      <Ref Oper="DegreeOfPartialPerm"/>, multiplication of two partial 
      permutations is via <K>*</K>, and exponentiation with the first argument
      a positive integer <C>i</C> and second argument a partial permutation
      <C>f</C> where the result is the image <C>i^f</C> of the point <C>i</C>
      under <C>f</C>.<P/>

      <C>IsPartialPermCollection</C> is the category of collections of partial
      permutations. For example, a semigroup of partial permutations belongs
      in <C>IsPartialPermCollection</C>.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomPartialPerm"/>
  <ManSection>
    <Func Name="RandomPartialPerm" Arg="n"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      <C>RandomPartialPerm</C> returns a randomly chosen partial permutation
      where points in the domain and range are bounded above by the
      positive integer <A>n</A>. Points are chosen in the dense range list of
      the returned partial permutation with the probability of a value being
      undefined equal to the probability of it being defined. Thus the
      expected rank of the returned partial permutation is approximately
      <C>n/2</C>. 
      <Log>gap> f:=RandomPartialPerm(10);  
[ 1, 2, 3, 4, 7, 8, 9 ] -> [ 5, 9, 1, 7, 2, 8, 4 ]</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DenseRangeList"/>
  <ManSection>
    <Func Name="DenseRangeList" Arg="f"/>
    <Returns>A list of positive integers.</Returns>
    <Description>
      The <E>dense range list</E> of a partial permutation <A>f</A> is a list of
      positive integers <C>list</C> such that <C>list[i]=i^</C><A>f</A> 
      where <C>i^</C><A>f</A><C>=0</C> if <A>f</A> is undefined on <C>i</C>.  
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 8, 9, 10 ], [ 5, 8, 9, 7, 2, 6, 10 ] );;
gap> DenseRangeList(f);
[ 5, 8, 9, 7, 0, 0, 0, 2, 6, 10 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DegreeOfPartialPerm"/>
  <ManSection>
    <Func Name="DegreeOfPartialPerm" Arg="f"/>
    <Func Name="Degree" Arg="f"/>
    <Returns>A positive integer.</Returns>
    <Description>
      The <E>degree</E> of a partial permutation <A>f</A> is the largest
      positive integer in the union of its domain and range. 
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 6, 10 ], [ 1, 8, 2, 3, 4, 9 ] );;
gap> DegreeOfPartialPerm(f);
10</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RankOfPartialPerm"/>
  <ManSection>
    <Func Name="RankOfPartialPerm" Arg="f"/>
    <Func Name="Rank" Arg="f"/>
    <Returns>A positive integer.</Returns>
    <Description>
      The <E>rank</E> of a partial permutation <A>f</A> is the number of points
      in its domain (or equivalently its range). 
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 5, 6 ], [ 10, 3, 9, 1, 5, 8 ] );;
gap> RankOfPartialPerm(f);
6</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsPartialPerm"/>
  <ManSection>
    <Func Name="AsPartialPerm" Arg="f [, set]"/>
    <Func Name="AsPartialPermNC" Arg="f [, set]"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      <List>
        <Mark>For permutations:</Mark>
        <Item><C>AsPartialPerm</C> and <C>AsPartialPermNC</C> return the 
          partial permutation that equals <A>f</A> on the set of positive
          integers <A>set</A> and is undefined elsewhere. 
          If the optional second argument <A>set</A> is not specfied, then
          <C>MovedPoints(f)</C> is used; see <Ref Attr="MovedPoints"
            BookName="ref"/>.<P/>
          
          If the optional second argument <A>set</A> is specified, then 
          <C>AsPartialPerm</C> first checks that <A>set</A> is a set of
          positive integers and then calls <C>AsPartialPermNC</C>. If the
          optional second argument is not specified, 
          then <C>AsPartialPerm</C> simply calls <C>AsPartialPermNC</C> and no
          further checks are performed. 
          <P/>
          
          Note that as explained in <Ref Func="PartialPerm"/> <E>a permutation 
          is never a partial permutation</E> in &GAP;, please keep this in mind
        when using <C>AsPartialPerm</C>.
        </Item>
        <Mark>For transformations:</Mark>
        <Item>
          If <A>f</A> is a transformation such that
          <C>Degree(<A>f</A>)^<A>f</A>=Degree(<A>f</A>)</C>
          and <A>f</A> is injective except on those <C>i</C> such that
          <C>i^<A>f</A>=Degree(f)</C>, then <C>AsPartialPerm</C> returns
          the corresponding partial permutation.<P/>
          <C>AsPartialPerm</C> first
          verifies that <A>f</A> has the required form, whereas
          <C>AsPartialPermNC</C> does not. There is currently no method for
          <C>AsPartialPerm</C> or <C>AsPartialPermNC</C> with two arguments. 
        </Item>
      </List>
      <Example>
gap> f:=(2,8,19,9,14,10,20,17,4,13,12,3,5,7,18,16);;
gap> AsPartialPerm(f);
[ 2, 3, 4, 5, 7, 8, 9, 10, 12, 13, 14, 16, 17, 18, 19, 20 ] -> 
[ 8, 5, 13, 7, 18, 19, 14, 20, 3, 12, 10, 2, 4, 16, 9, 17 ]
gap> AsPartialPerm(f, [1,2,3]);
[ 1 .. 3 ] -> [ 1, 8, 5 ]
gap> f:=Transformation( [ 8, 3, 5, 9, 6, 2, 9, 7, 9 ] );
Transformation( [ 8, 3, 5, 9, 6, 2, 9, 7, 9 ] )
gap> AsPartialPerm(f);
[ 1, 2, 3, 5, 6, 8 ] -> [ 8, 3, 5, 6, 2, 7 ]
gap> AsPartialPermNC(f);
[ 1, 2, 3, 5, 6, 8 ] -> [ 8, 3, 5, 6, 2, 7 ]
gap> f:=Transformation( [ 2, 10, 2, 4, 4, 7, 6, 9, 10, 1 ] )
gap> AsPartialPerm(f);
fail</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IndexPeriodOfPartialPerm">
  <ManSection>
    <Func Name="IndexPeriodOfPartialPerm" Arg="f"/>
    <Returns>A pair of positive integers.</Returns>
    <Description>
      Returns the least positive integers <C>m, r</C> such that
      <C><A>f</A>^(m+r)=<A>f</A>^m</C>, which are 
      known as the <E>index</E> and <E>period</E> of the transformation
      <A>f</A>. 
      <Example>
gap> f:=PartialPermNC([ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ], 
> [ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ]);;
gap> IndexPeriodOfPartialPerm(f);                                    
[ 5, 2 ]
gap> f^5=f^7;
true</Example> 
    </Description>
  </ManSection>
  <#/GAPDoc>
  
  <#GAPDoc Label="One"/>
<ManSection><Heading>One (for a partial permutation)</Heading>
    <Func Name="One" Arg="f"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      As described in the reference manual <Ref Attr="OneImmutable"
        BookName="ref"/>, 
      <C>One</C> returns the multiplicative neutral element of the partial
      permutation <A>f</A>, which is the identity partial permutation on the
      union of the domain and range of <A>f</A>; see <Ref
        Func="DomainOfPartialPerm"/> and <Ref Func="RangeOfPartialPerm"/>.
      <Example>
gap> f:=PartialPermNC([ 1, 2, 3, 4, 5, 7, 10 ], [ 3, 7, 9, 6, 1, 10, 2 ]);;
gap> One(f);
&lt;identity on [ 1, 2, 3, 4, 5, 6, 7, 9, 10 ]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

  <#GAPDoc Label="PrettyPrintPP"/>
<ManSection>
    <Func Name="PrettyPrintPP" Arg="f"/>
    <Returns>Nothing.</Returns>
    <Description>
      <C>PrettyPrintPP</C> will print the partial permutation <A>f</A> as a
      product of disjoint permutations and open cycles (for lack of a better
      word). An <E>open cycle</E> is a list <C>X</C> of length <C>n</C> such
      that:
      <List><Item>
          <C>X[1]</C> is an element of the domain of <A>f</A> but not the
          range</Item>
        <Item><C>X[i]^<A>f</A>=X[i+1]</C> for all <C>n</C> in <M>\{1,\ldots,
            n-1\}</M></Item> 
        <Item><C>X[n]</C> is in the range of <A>f</A> but not the
          domain.</Item>
      </List>
      In the display, permutations are displayed as they usually are in &GAP;,
      fixed points are displayed enclosed in round brackets, and open cycles
      are displayed enclosed in square brackets.

      <Example>
gap> f:=RandomPartialPerm(20);                                        
[ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ] -> 
[ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ]
gap> PrettyPrintPP(f);
[1,3,14][16,8,2,12,15](4)(5,11)[6,18,10,9][7,17,20](19)</Example>
    </Description> 
  </ManSection> 
<#/GAPDoc>


