#############################################################################
##
#W  pperm.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="PartialPerm"/>
  <ManSection>
    <Func Name="PartialPerm" Arg="dom, ran"/>
    <Func Name="PartialPerm" Arg="list"/>
    <Func Name="PartialPermNC" Arg="dom, ran"/>
    <Func Name="PartialPermNC" Arg="list"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      Partial permutations can be created in two ways: by giving the domain
      and the range, or the dense range list. <P/>

      The partial permutation defined by a domain <A>dom</A> and range
      <A>ran</A>, where <A>dom</A> is a set of positive integers and
      <A>ran</A> is a duplicate free list of positive integers, maps
      <A>dom</A><C>[i]</C> to <A>ran</A><C>[i]</C>. For example,
      the partial permutation mapping <M>1</M> and <M>5</M> to <M>20</M> and
      <M>2</M> can be created using: 
      <Log>PartialPermNC([1,5],[20,2]); </Log> <P/>

      The partial permutation defined by a dense range list <A>list</A>, maps
      the positive integer <C>i</C> to <A>list</A><C>[i]</C> if
      <A>list</A><C>[i]&lt;&gt;>0</C> and is undefined at <C>i</C> if 
      <A>list</A><C>[i]=0</C>.  For example, the partial permutation mapping
      <M>1</M> and <M>5</M> to <M>20</M> and <M>2</M> can be created
      using: <Log>PartialPermNC([20,0,0,0,2]);</Log><P/>

      Regardless of which of these two methods are used to create a partial
      permutation in &GAP; the internal representation is the same. <P/>

      If the largest point in the domain is larger than the
      rank of the partial permutation, then using the dense range list to
      define the partial permutation will require less typing; otherwise
      using the domain and the range will require less typing. For example,
      the partial permutation mapping <M>10000</M> to <M>1</M> can be defined
      using:
      <Log>PartialPermNC([10000], [1]);</Log>
      but using the dense range list would require a list with <M>9999</M>
      entries equal to <M>0</M> and the final entry equal to <M>1</M>. 
      On the other hand, the identity on <C>[1,2,3,4,6]</C> can be defined
      using:
      <Log>PartialPermNC([1,2,3,4,0,6]);</Log>
      <P/>
      
      <C>PartialPerm</C> checks that the argument defines a partial
      permatutation whereas <C>PartialPermNC</C> does not.
      <C>PartialPermNC</C> is a kernel function written in C, which performs
      no checks on it argument, and so if the argument does not define a
      partial permutation, then the results can be unpredictable, and it
      could even potentially cause &GAP; to crash. <P/>

      It is currently only possible to create partial permutations acting 
      on positive integers not greater than <M>65535</M>. Note that this
      might cause some unexpected behaviour when multiplying partial
      permutations by permutations. For example, if
      <C>f:=PartialPerm([1,2,3]);</C>, then 
      <C>f*(1,100000)*(1,100000)</C> will return an error since the result of
      <C>f*(1,100000)</C> would be a partial permutation acting on too many
      points. However, the product <C>f*((1,100000)*(1,100000))</C> is just
      <C>f</C> and no error is given.
      <P/>

      Please note that a partial permutation in &GAP; is never a permutation
      nor is a permutation ever a partial permutation. For example, the
      permutation <C>(1,4,2)</C> fixes <C>3</C> but the partial permutation
      <C>PartialPerm([4,1,0,2]);</C> is not defined on <C>3</C>. 

    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DomainOfPartialPerm"/>
  <ManSection>
    <Oper Name="DomainOfPartialPerm" Arg="f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      The <E>domain</E> of a partial permutation <A>f</A> is the set of
      positive integers where <A>f</A> is defined. 
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 6, 8, 10 ], [ 2, 6, 7, 9, 1, 5 ] );;
gap> DomainOfPartialPerm(f);
[ 1, 2, 3, 6, 8, 10 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RangeOfPartialPerm"/>
  <ManSection>
    <Oper Name="RangeOfPartialPerm" Arg="f"/>
    <Returns>A duplicate-free list of positive integers.</Returns>
    <Description>
      The <E>range</E> of a partial permutation <A>f</A> is the list of images
      of the elements of the domain <A>f</A> where
      <Log>RangeOfPartialPerm(f)[i]=DomainOfPartialPerm(f)[i]^f.</Log>
<Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 5, 8, 10 ], [ 7, 1, 4, 3, 2, 6, 5 ] );;
gap> RangeOfPartialPerm(f);
[ 7, 1, 4, 3, 2, 6, 5 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RangeSetOfPartialPerm"/>
  <ManSection>
    <Oper Name="RangeSetOfPartialPerm" Arg="f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      The range of a partial permutation <A>f</A> is the list of images of the
      elements of the domain <A>f</A>. <C>RangeSetOfPartialPerm</C> returns the
      range of a partial permutation sorted into increasing order. 
      <Example>
gap>f:=PartialPermNC( [ 1, 2, 3, 5, 7, 10 ], [ 10, 2, 3, 5, 7, 6 ] );;
gap> RangeSetOfPartialPerm(f);
[ 2, 3, 5, 6, 7, 10 ]</Example>
    </Description> 
  </ManSection> 
<#/GAPDoc>

<#GAPDoc Label="OnIntegerSetsWithPP"/>
  <ManSection>
    <Func Name="OnIntegerSetsWithPP" Arg="set, f"/>
    <Oper Name="OnIntegerSetsWithPartialPerm" Arg="set, f"/>
    <Returns>The inverse of <A>f</A>.</Returns>
    <Description>
      Blah.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="LeftOne"/>
  <ManSection>
    <Func Name="LeftOne" Arg="f"/>
    <Oper Name="RightOne" Arg="f"/>
    <Returns>The idempotent partial permutation <A>f</A><C>*</C><A>f^-1</A> or
      <A>f^-1</A><C>*</C><A>f</A>.
    </Returns>
    <Description>
      Blah.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="FixedPointsOfPartialPerm"/>
  <ManSection>
    <Oper Name="FixedPointsOfPartialPerm" Arg="f"/>
    <Returns>A set of positive integers.</Returns>
    <Description>
      A positive integer <C>i</C> is fixed by a partial permutation <A>f</A> if
      <C>i^</C><A>f</A><C>=i</C>. <C>FixedPointsOfPartialPerm</C> returns the
      set of points fixed by the partial permutation <A>f</A>.
      <Example>
gap> f:=PartialPermNC( 
> [ 1, 2, 3, 5, 6, 8, 10, 11, 14, 17, 20, 21, 22, 24, 25, 26, 32 ], 
> [ 30, 20, 29, 24, 9, 14, 26, 5, 25, 15, 11, 6, 35, 2, 10, 19, 23 ] );;
gap> FixedPointsOfPartialPerm(f);
[  ]
gap> f:=PartialPermNC([1..10]);
&lt;identity on [ 1 .. 10 ]>
gap> FixedPointsOfPartialPerm(f);
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RestrictedPartialPerm"/>
  <ManSection>
    <Oper Name="RestrictedPartialPerm" Arg="f, set"/>
    <Oper Name="RestrictedPartialPermNC" Arg="f, set"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      <C>RestrictedPartialPerm</C> returns a new partial permutation that acts
      on the points in the set of positive integers <A>set</A> in  the  same
      way as the partial permutation <A>f</A>, and that is undefined on those
      points that are not in <A>set</A>.<P/>

      <C>RestrictedPartialPermNC</C> does not check whether <A>set</A> is a set
      of positive integers. 

      <Example>
gap> f:=PartialPermNC( [ 1, 3, 4, 7, 8, 9 ], [ 9, 4, 1, 6, 2, 8 ] );;
gap> RestrictedPartialPerm(f, [2,3,6,10]);
[ 3 ] -> [ 4 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NaturalLeqPP"/>
  <ManSection>
    <Func Name="NaturalLeqPP" Arg="f, g"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      Blah.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsPartialPerm"/>
  <ManSection>
    <Filt Name="IsPartialPerm" Arg="obj" Type="category"/>
    <Filt Name="IsPartialPermCollection" Arg="obj" Type="category"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
      Each <E>partial permutation</E> in &GAP; lies in the category
      <C>IsPartialPerm</C>. Basic operations for partial permutations are 
      <Ref Oper="DomainOfPartialPerm"/>, <Ref Oper="RangeOfPartialPerm"/>, 
      <Ref Oper="RangeSetOfPartialPerm"/>, <Ref Oper="RankOfPartialPerm"/>,
      <Ref Oper="DegreeOfPartialPerm"/>, multiplication of two partial 
      permutations is via <K>\*</K>, and exponentiation with the first argument
      a positive integer <C>i</C> and second arugment a partial permutation
      <C>f</C> where the result is the image <C>i^f</C> of the point <C>i</C>
      under <C>f</C>.<P/>

      <C>IsPartialPermCollection</C> is the category of collections of partial
      permutations. For example, a semigroup of partial permutations is belongs
      in <C>IsPartialPermCollection</C>.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomPartialPerm"/>
  <ManSection>
    <Func Name="RandomPartialPerm" Arg="n"/>
    <Returns>A partial permutation.</Returns>
    <Description>
      <C>RandomPartialPerm</C> returns a randomly chosen partial permutation
      where points in the domain and range are bounded above by the
      positive integer <A>n</A>. Points are chosen in the dense range list of
      the returned partial permutation with the probability of a value being
      undefined equal to the probability of it being defined. Thus the
      expected rank of the returned partial permutation is approximately
      <C>n/2</C>. 
      <Log>gap> f:=RandomPartialPerm(10);  
[ 1, 2, 3, 4, 7, 8, 9 ] -> [ 5, 9, 1, 7, 2, 8, 4 ]</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="PartialPermFamily"/>
  <ManSection>
    <Var Name="PartialPermFamily"/>
    <Var Name="PartialPermType"/>
    <Returns>?</Returns>
    <Description>
      Blah.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DenseRangeList"/>
  <ManSection>
    <Func Name="DenseRangeList" Arg="f"/>
    <Returns>A list of positive integers.</Returns>
    <Description>
      The <E>dense range list</E> of a partial permutation <A>f</A> is a list of
      positive integers <C>list</C> such that <C>list[i]=i^</C><A>f</A> 
      where <C>i^</C><A>f</A><C>=0</C> if <A>f</A> is undefined on <C>i</C>.  
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 8, 9, 10 ], [ 5, 8, 9, 7, 2, 6, 10 ] );;
gap> DenseRangeList(f);
[ 5, 8, 9, 7, 0, 0, 0, 2, 6, 10 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DegreeOfPartialPerm"/>
  <ManSection>
    <Func Name="DegreeOfPartialPerm" Arg="f"/>
    <Func Name="Degree" Arg="f"/>
    <Returns>A positive integer.</Returns>
    <Description>
      The <E>degree</E> of a partial permutation <A>f</A> is the largest
      positive integer in the union of its domain and range. 
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 6, 10 ], [ 1, 8, 2, 3, 4, 9 ] );;
gap> DegreeOfPartialPerm(f);
10</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RankOfPartialPerm"/>
  <ManSection>
    <Func Name="RankOfPartialPerm" Arg="f"/>
    <Func Name="Rank" Arg="f"/>
    <Returns>A positive integer.</Returns>
    <Description>
      The <E>rank</E> of a partial permutation <A>f</A> is the number of points
      in its domain (or equivalently its range). 
      <Example>
gap> f:=PartialPermNC( [ 1, 2, 3, 4, 5, 6 ], [ 10, 3, 9, 1, 5, 8 ] );;
gap> RankOfPartialPerm(f);
6</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsPartialPerm"/>
  <ManSection>
    <Func Name="AsPartialPerm" Arg="obj"/>
    <Returns>A positive integer.</Returns>
    <Description>
      Blah.
    </Description>
  </ManSection>
<#/GAPDoc>

<ManSection>
  <Meth Name="\^" Arg="f, i"> 
  <Description>
    This method is for an operation with a tricky name.
  </Description>
</ManSection>
