
<#GAPDoc Label="GradedImagesOfTransSemigroup">
  <ManSection><Heading>Graded images and kernels</Heading>
  <Attr Name="GradedImagesOfTransSemigroup" Arg="S"/>
  <Attr Name="GradedKernelsOfTransSemigroup" Arg="S"/>
  <Returns> a list where the <C>i</C>th
    entry is a list of all the images or kernels of transformations in 
    <A>S</A> with rank <C>i</C>.
  </Returns>
  <Description>
  <C>GradedImagesOfTransSemigroup</C> returns a list where the <C>i</C>th 
  entry is a list of all the images of transformations in <A>S</A> with rank 
  <C>i</C>.  
  <P/>
  
  <C>GradedKernelsOfTransSemigroup</C> returns a list where the <C>i</C>th 
  entry is a list of the values of <Ref Func="CanonicalTransSameKernel"/> for
  all transformations in <A>S</A> with rank <C>i</C>.
  <P/>

  See also <Ref Attr="ImagesOfTransSemigroup"/> and 
  <Ref Attr="KernelsOfTransSemigroup"/>.
  <Example>
gap> S:=Semigroup(Transformation( [ 1, 5, 1, 1, 1 ] ), 
> Transformation( [ 4, 4, 5, 2, 2 ] ));;
gap> GradedImagesOfTransSemigroup(S);
[ [ [ 1 ], [ 4 ], [ 2 ], [ 5 ] ], [ [ 1, 5 ], [ 2, 4 ] ], [ [ 2, 4, 5 ] ], 
  [  ], [  ] ]
gap> GradedKernelsOfTransSemigroup(S);
[ [ [ 1, 1, 1, 1, 1 ] ], [ [ 1, 2, 1, 1, 1 ], [ 1, 1, 1, 2, 2 ] ], 
  [ [ 1, 1, 2, 3, 3 ] ], [  ], [  ] ]</Example> 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ImagesOfTransSemigroup">
  <ManSection><Heading>Images and kernels</Heading>
  <Attr Name="ImagesOfTransSemigroup" Arg="S[, n]"/>
  <Attr Name="KernelsOfTransSemigroup" Arg="S[, n]"/>
  <Returns>the orbit of images or kernels of the transformation semigroup
  <A>S</A>.
  </Returns>
  <Description>
  <C>ImagesOfTransSemigroup</C> returns the  
  <Ref Func="Orb" BookName="orb"/> object:
  <Log>Orb(S, [1..Degree(S)], OnSets);</Log>
  <P/>
  
  <C>KernelsOfTransSemigroup</C> returns the <Ref Func="Orb" BookName="orb"/>
  object:
  <Log>Orb(S, [1,..Degree(S)], OnKernelsAntiAction);</Log>
  <P/>
  If the optional second argument <A>n</A> (a positive integer) is present, 
  then only the images or kernels of size at least <A>n</A> are found.<P/>
 
  Note that the image/kernel <C>[1..Degree(S)]</C> always occurs in both orbits
  even if there is no element of <A>S</A> with image/kernel equal to
  <C>[1..Degree(S)]</C>.<P/>

  See also <Ref Func="GradedImagesOfTransSemigroup"/>,
  <Ref Func="GradedKernelsOfTransSemigroup"/>,
  <Ref Func="OnKernelsAntiAction"/>, and 
  <Ref Func="CanonicalTransSameKernel"/>
  <Example>
gap>  S:=Semigroup( Transformation( [ 6, 4, 4, 4, 6, 1 ] ), 
> Transformation( [ 6, 5, 1, 6, 2, 2 ] ) );;
gap> o:=ImagesOfTransSemigroup(S, 6); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 1 points with Schreier tree with grading>
[ [ 1 .. 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 5); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 1 points with Schreier tree with grading>
[ [ 1 .. 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 4); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 2 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 2, 5, 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 3); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 4 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 5, 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 2); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 8 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 6 ], [ 2, 5, 6 ], [ 1, 4 ],
  [ 2, 5 ], [ 4, 6 ] ]
gap> o:=ImagesOfTransSemigroup(S, 1); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree with grading>
&lt;closed orbit, 13 points with Schreier tree with grading>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 6 ], [ 2, 5, 6 ], [ 1, 4 ],
  [ 2, 5 ], [ 4, 6 ], [ 6 ], [ 1 ], [ 2 ], [ 4 ], [ 5 ] ]
gap> o:=ImagesOfTransSemigroup(S); Enumerate(o); AsList(o);
&lt;open orbit, 1 points with Schreier tree>
&lt;closed orbit, 13 points with Schreier tree>
[ [ 1 .. 6 ], [ 1, 4, 6 ], [ 1, 2, 5, 6 ], [ 2, 6 ], [ 2, 5, 6 ], [ 1, 4 ],
  [ 2, 5 ], [ 4, 6 ], [ 6 ], [ 1 ], [ 2 ], [ 4 ], [ 5 ] ]</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnKernelsAntiAction">
  <ManSection> 
    <Oper Name="OnKernelsAntiAction" Arg="ker, f"/>
    <Returns>
      <C>CanonicalTransSameKernel(f*g)</C> when <A>f</A> is a
      transformation and <A>g</A> is a transformation with
      <C>CanonicalTransSameKernel(<A>g</A>)=ker</C>.
    </Returns>
    <Description>
    See also <Ref Func="CanonicalTransSameKernel"/>.
    <Example>
gap> f:=Transformation( [ 3, 6, 9, 2, 4, 2, 2, 2, 8, 2 ] );;
gap> g:=Transformation( [ 7, 1, 4, 3, 2, 7, 7, 6, 6, 5 ] );;
gap> ker:=CanonicalTransSameKernel(f);
[ 1, 2, 3, 4, 5, 4, 4, 4, 6, 4 ]
gap> OnKernelsAntiAction(ker, g);
[ 1, 2, 1, 3, 4, 1, 1, 1, 1, 5 ]
gap> CanonicalTransSameKernel(g*f);
[ 1, 2, 1, 3, 4, 1, 1, 1, 1, 5 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OrbSCC">
  <ManSection>
    <Func Name="OrbSCC" Arg="o"/>
    <Returns>the strongly connected components of an orbit.</Returns>
    <Description>
      If <A>o</A> is an orbit created by the <Package>Orb</Package> 
      package with the
      option <C>orbitgraph=true</C>, then <C>OrbSCC</C> returns a set of sets
      of positions in <A>o</A> corresponding to its strongly connected
      components. <P/>
      
      See also <Ref Func="OrbSCCLookup"/> and <Ref Func="OrbSCCTruthTable"/>.
      
<Example>
gap> S:=FullTransformationSemigroup(4);;
gap> o:=ImagesOfTransSemigroup(S);;
gap> OrbSCC(o);
[ [ 1 ], [ 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10, 11 ], [ 12, 13, 14, 15 ] ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OrbSCCLookup">
  <ManSection>
    <Func Name="OrbSCCLookup" Arg="o"/>
    <Returns>a lookup table for the strongly connected components of an orbit.
    </Returns>
    <Description>
      If <A>o</A> is an orbit created by the <Package>Orb</Package> 
      package with the
      option <C>orbitgraph=true</C>, then <C>OrbSCCLookup</C> returns a lookup
      table for its strongly connected
      components. More precisely, <C>OrbSCCLookup(o)[i]</C> equals the index of
      the strongly connected component containing <C>o[i]</C>.
      <P/>

      See also <Ref Func="OrbSCC"/> and <Ref Func="OrbSCCTruthTable"/>.
      
<Example>
gap> S:=FullTransformationSemigroup(4);;
gap> o:=ImagesOfTransSemigroup(S);;
gap> OrbSCC(o);
[ [ 1 ], [ 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10, 11 ], [ 12, 13, 14, 15 ] ]
gap> OrbSCCLookup(o);
[ 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 ]
gap> OrbSCCLookup(o)[1]; OrbSCCLookup(o)[4]; OrbSCCLookup(o)[7]; 
1
2
3</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OrbSCCTruthTable">
  <ManSection>
    <Func Name="OrbSCCTruthTable" Arg="o"/>
    <Returns>truth tables for strongly connected components of an orbit.
    </Returns>
    <Description>
      If <A>o</A> is an orbit created by the <Package>Orb</Package> 
      package with the
      option <C>orbitgraph=true</C>, then <C>OrbSCCTruthTable</C> returns 
      a list of boolean lists such that <C>OrbSCCTruthTable(o)[i][j]</C> is
      <K>true</K> if <C>j</C> belongs to <C>OrbSCC(o)[i]</C>.<P/>
      
      See also <Ref Func="OrbSCC"/> and <Ref Func="OrbSCCLookup"/>.
      
<Example>
gap> S:=FullTransformationSemigroup(4);;
gap> o:=ImagesOfTransSemigroup(S);;
gap> OrbSCC(o);
[ [ 1 ], [ 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10, 11 ], [ 12, 13, 14, 15 ] ]
gap> OrbSCCTruthTable(o);
[ [ true, false, false, false, false, false, false, false, false, false, 
      false, false, false, false, false ], 
  [ false, true, true, true, true, false, false, false, false, false, false, 
      false, false, false, false ], 
  [ false, false, false, false, false, true, true, true, true, true, true, 
      false, false, false, false ], 
  [ false, false, false, false, false, false, false, false, false, false, 
      false, true, true, true, true ] ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ReverseSchreierTreeOfSCC">
  <ManSection>
    <Func Name="ReverseSchreierTreeOfSCC" Arg="o, i"/>
    <Returns>the reverse Schreier tree corresponding to the <A>i</A>th strongly
    connected component of an orbit. </Returns>
    <Description> 
    If <A>o</A> is an orbit created by the <Package>Orb</Package> 
    package with the option <C>orbitgraph=true</C> and action <C>act</C>, and 
    <A>i</A> is a positive
    integer, then <C>ReverseSchreierTreeOfSCC(<A>o</A>, <A>i</A>)</C> returns 
    a pair <C>[ gen, pos ]</C> of lists with <C>Length(o)</C> entries such that 
    <Log>act(o[j], o!.gens[gen[j]])=o[pos[j]].</Log> 
    The pair <C>[ gen, pos ]</C> corresponds to a tree with root
    <C>OrbSCC(o)[i][1]</C> and a path from every element
    of <C>OrbSCC(o)[i]</C> to the root. <P/>

    See also <Ref Func="OrbSCC"/>, <Ref Func="TraceSchreierTreeOfSCCBack"/>, 
    <Ref Func="SchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCForward"/>.
<Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 1, 4, 4 ] ), 
> Transformation( [ 3, 3, 3, 4, 5 ] ),
> Transformation( [ 5, 1, 4, 5, 5 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3, 5, 6, 7, 11 ], [ 4 ], [ 8 ], [ 9 ], [ 10, 12 ] ]
gap> ReverseSchreierTreeOfSCC(o, 3);
[ [ fail, fail, fail, fail, 2, 1, 2, fail, fail, fail, 1, fail ], 
  [ fail, fail, fail, fail, 3, 5, 3, fail, fail, fail, 7, fail ] ]
gap> ReverseSchreierTreeOfSCC(o, 7);
[ [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 3 ], 
  [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 10 ] ]
gap> OnSets(o[11], Generators(S)[1]);
[ 1, 4 ]
gap> Position(o, last);
7</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SchreierTreeOfSCC">
  <ManSection>
    <Func Name="SchreierTreeOfSCC" Arg="o, i"/>
    <Returns>the Schreier tree corresponding to the <A>i</A>th strongly
    connected component of an orbit. </Returns>

    <Description> 
    If <A>o</A> is an orbit created by the <Package>Orb</Package> 
    package with the option <C>orbitgraph=true</C> and action <C>act</C>, and 
    <A>i</A> is a positive
    integer, then <C>SchreierTreeOfSCC(<A>o</A>, <A>i</A>)</C> returns 
    a pair <C>[ gen, pos ]</C> of lists with <C>Length(o)</C> entries such that 
    <Log>act(o[pos[j]], o!.gens[gen[j]])=o[j].</Log> 
    The pair <C>[ gen, pos ]</C> corresponds to a tree with root
    <C>OrbSCC(o)[i][1]</C> and a path from the root to every element of
     <C>OrbSCC(o)[i]</C>. <P/>

    See also <Ref Func="OrbSCC"/>, <Ref Func="TraceSchreierTreeOfSCCBack"/>, 
    <Ref Func="ReverseSchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCForward"/>.
<Example>
gap> S:=Semigroup(Transformation( [ 2, 2, 1, 4, 4 ] ), 
> Transformation( [ 3, 3, 3, 4, 5 ] ),
> Transformation( [ 5, 1, 4, 5, 5 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3, 5, 6, 7, 11 ], [ 4 ], [ 8 ], [ 9 ], [ 10, 12 ] ]
gap> SchreierTreeOfSCC(o, 3);
[ [ fail, fail, fail, fail, 1, 3, 1, fail, fail, fail, 2, fail ], 
  [ fail, fail, fail, fail, 7, 5, 3, fail, fail, fail, 6, fail ] ]
gap> SchreierTreeOfSCC(o, 7);
[ [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 1 ], 
  [ fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, fail, 10 ] ]
gap> OnSets(o[6], Generators(S)[2]);
[ 3, 5 ]
gap> Position(o, last);
11</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="TraceSchreierTreeOfSCCBack"/>
  <ManSection> 
    <Oper Name="TraceSchreierTreeOfSCCBack" Arg="orb, m, nr"/>
    <Returns>A word in the generators.</Returns>

    <Description>
    <A>orb</A>  must  be  an  orbit  object  with  a Schreier tree and orbit
    graph, that is, 
    the options <C>schreier</C> and <C>orbitgraph</C> must have been set to
    <K>true</K> during the 
    creation of the orbit, <A>m</A> must be the number of a strongly connected
    component of <A>orb</A>, and <C>nr</C> must be the number of a point in  
    the  <A>m</A>th strongly connect component of <A>orb</A>. This
    operation traces the result of <Ref Func="ReverseSchreierTreeOfSCC"/> and
     with arguments <A>orb</A> and <A>m</A> and returns a
    word in the generators that maps the point with number
    <A>nr</A> to the first point in the <A>m</A>th strongly connected 
    component of <A>orb</A>.  
    Here, a word is a list of integers, where positive integers
    are numbers of  generators.

    See also <Ref Func="OrbSCC"/>,<Ref Func="EvaluateWord"/>, 
    <Ref Func="ReverseSchreierTreeOfSCC"/>, 
    <Ref Func="SchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCForward"/>.
    <Example>
gap> S:=Semigroup(Transformation( [ 1, 3, 4, 1 ] ), 
> Transformation( [ 2, 4, 1, 2 ] ),
> Transformation( [ 3, 1, 1, 3 ] ), 
> Transformation( [ 3, 3, 4, 1 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3 ], [ 4, 5, 6, 7, 8 ], [ 9, 10, 11, 12 ] ]
gap> ReverseSchreierTreeOfSCC(o, 4);               
[ [ fail, fail, fail, fail, 4, 1, 1, 3, fail, fail, fail, fail ], 
  [ fail, fail, fail, fail, 4, 4, 4, 4, fail, fail, fail, fail ] ]
gap> TraceSchreierTreeOfSCCBack(o, 4, 7);
[ 1 ]
gap> TraceSchreierTreeOfSCCBack(o, 4, 8);
[ 3 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="TraceSchreierTreeOfSCCForward"/>
  <ManSection> 
    <Oper Name="TraceSchreierTreeOfSCCForward" Arg="orb, m, nr"/>
    <Returns>A word in the generators.</Returns>

    <Description>
    <A>orb</A>  must  be  an  orbit  object  with  a Schreier tree and orbit
    graph, that is, 
    the options <C>schreier</C> and <C>orbitgraph</C> must have been set to
    <K>true</K> during the 
    creation of the orbit, <A>m</A> must be the number of a strongly connected
    component of <A>orb</A>, and <C>nr</C> must be the number of a point in  
    the  <A>m</A>th strongly connect component of <A>orb</A>. This
    operation traces the result of <Ref Func="SchreierTreeOfSCC"/> and
     with arguments <A>orb</A> and <A>m</A> and returns a
    word in the generators that maps the first point in the <A>m</A>th strongly 
    connected component of <A>orb</A> to the point with number <A>nr</A>.  
    Here, a word is a list of integers, where positive integers
    are numbers of  generators.

    See also <Ref Func="OrbSCC"/>, <Ref Func="EvaluateWord"/>, 
    <Ref Func="ReverseSchreierTreeOfSCC"/>, 
    <Ref Func="SchreierTreeOfSCC"/>, and 
    <Ref Func="TraceSchreierTreeOfSCCBack"/>.
    <Example>
gap> S:=Semigroup(Transformation( [ 1, 3, 4, 1 ] ), 
> Transformation( [ 2, 4, 1, 2 ] ),
> Transformation( [ 3, 1, 1, 3 ] ), 
> Transformation( [ 3, 3, 4, 1 ] ) );;
gap> o:=Orb(S, [1..4], OnSets, rec(orbitgraph:=true, schreier:=true));;
gap> OrbSCC(o);
[ [ 1 ], [ 2 ], [ 3 ], [ 4, 5, 6, 7, 8 ], [ 9, 10, 11, 12 ] ]
gap> SchreierTreeOfSCC(o, 4);
[ [ fail, fail, fail, fail, 1, 2, 2, 4, fail, fail, fail, fail ], 
  [ fail, fail, fail, fail, 4, 4, 6, 4, fail, fail, fail, fail ] ]
gap> TraceSchreierTreeOfSCCForward(o, 4, 8);
[ 4 ]
gap> TraceSchreierTreeOfSCCForward(o, 4, 7);
[ 2, 2 ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

