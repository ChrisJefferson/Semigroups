#############################################################################
##
#W  transform.xml
#Y  Copyright (C) 2011-12                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="AsPermutation">
<ManSection>
<!-- JDM remove transformations --> 
    <Oper Name="AsPermutation" Arg="f  [, set]"/>
    <Returns>A permutation.</Returns>
    <Description>
      If the partial permutation <A>f</A> is a permutation of
      the set of positive integers <A>set</A>, then <C>AsPermutation</C>
      returns this permutation;  see <Ref Func="Permutation"
        BookName="ref"/>.<P/>

      If the optional argument <A>set</A> is not specified, then the image set
      of <A>f</A> is used by default for transformations and the range of
      <A>f</A> is used by default for partial permutations; see 
      <Ref Attr="ImageSetOfTransformation" BookName="ref"/> and 
      <Ref Func="RangeSetOfPartialPerm"/>.

<Example>
gap> f:=Transformation( [ 5, 8, 3, 5, 8, 6, 2, 2, 7, 8 ] );;
gap> AsPermutation(f);
fail
gap> f:=Transformation( [ 8, 2, 10, 2, 4, 4, 7, 6, 9, 10 ] );;
gap> AsPermutation(f);
fail
gap> f:=Transformation( [ 1, 3, 6, 6, 2, 10, 2, 3, 10, 5 ] );;
gap> AsPermutation(f);
(2,3,6,10,5)
gap> f:=Transformation( [ 5, 2, 8, 4, 1, 8, 10, 3, 5, 7 ] );;
gap> AsPermutation(f);       
(1,5)(3,8)(7,10)
gap> AsPermutation(f, [1,5]);
(1,5)
gap> AsPermutation(f, [3,8,7,10]);
(3,8)(7,10)
gap> f:=PartialPerm([ 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 16, 17, 18, 19 ],
> [ 3, 12, 14, 4, 11, 18, 17, 2, 9, 5, 15, 8, 20, 10, 19 ]);;
gap> AsPermutation(f);
fail
gap> AsPermutation(f, [4,5,11]);
(5,11)
gap> f:=RandomPartialPerm(20);;
gap> AsPermutation(f^-1*f);
()</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsTransformation">
  <ManSection>
    <Oper Name="AsTransformation" Arg="f [, n]"/>
    <Returns>A transformation.</Returns>
    <Description>
      If <A>f</A> is a partial permutation and <C>m</C> is the largest point in
      the union of the domain and range of <A>f</A>, then
      <C>AsTransformation</C> returns the transformation <C>g</C> such that
      <C>i^g=i^f</C> for all <C>i</C> in the domain of <A>f</A> and
      <C>i^g=m+1</C> for all <C>i</C> in <M>\{1,\ldots, m+1\}</M> that is not
      in the domain of <A>f</A>. <P/>

      If the optional second argument <A>n</A> is a positive integer greater
      than the largest point in the union of the domain and range of <A>f</A>,
      then the transformation obtained is defined by replacing <C>m</C> in the
      definition of <C>g</C> in previous paragraph by <C>n</C>. <P/>

      It is also possible to use <C>AsTransformation</C> to convert
      permutations and binary relations into transformations; see 
      <Ref Func="AsTransformation" BookName="ref"/>.

      <Example>
gap> f:=PartialPerm([ 1, 2, 3, 4, 5, 8, 10 ], [ 3, 1, 4, 2, 5, 6, 7 ]);;
gap> AsTransformation(f);
Transformation( [ 3, 1, 4, 2, 5, 11, 11, 6, 11, 7, 11 ] )
gap> AsTransformation(f, 12);
Transformation( [ 3, 1, 4, 2, 5, 12, 12, 6, 12, 7, 12, 12 ] )
gap> AsTransformation(f, 14);
Transformation( [ 3, 1, 4, 2, 5, 14, 14, 6, 14, 7, 14, 14, 14, 14 ] )</Example>
    </Description> 
  </ManSection> 
<#/GAPDoc>

<#GAPDoc Label="EvaluateWord">
  <ManSection> 
    <Oper Name="EvaluateWord" Arg="gens, w"/>
    <Returns>A transformation.</Returns>
    <Description> 
      The argument <A>gens</A> should be a list of transformations or partial
      permutations and the
      argument <A>w</A> should be a list of positive integers less than or
      equal to the length of <A>gens</A>.  This operation evaluates the word
      <A>w</A> in the generators <A>gens</A>. More precisely,
      <C>EvaluateWord</C> returns the equivalent of: 
      <Log>Product(List(w, i-> gens[i]));</Log> 
      see also <Ref Meth="Factorization"/>.<P/>

      Note that <C>EvaluateWord(<A>gens</A>, [])</C> returns
      <C>One(<A>gens</A>)</C>. 
<Example>
gap> gens:=[ Transformation( [ 2, 4, 4, 6, 8, 8, 6, 6 ] ), 
> Transformation( [ 2, 7, 4, 1, 4, 6, 5, 2 ] ), 
> Transformation( [ 3, 6, 2, 4, 2, 2, 2, 8 ] ), 
> Transformation( [ 4, 3, 6, 4, 2, 1, 2, 6 ] ), 
> Transformation( [ 4, 5, 1, 3, 8, 5, 8, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> f:=Transformation( [ 1, 4, 6, 1, 7, 2, 7, 6 ] );;
gap> Factorization(S, f);
[ 4, 2 ]
gap> EvaluateWord(gens, last);
Transformation( [ 1, 4, 6, 1, 7, 2, 7, 6 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Factorization">
<ManSection> 
  <Meth Name="Factorization" Arg="S, f"/>
    <Returns>A word in the generators.</Returns>
      <Description> 
        If <A>S</A> is a transformation or partial perm semigroup and <A>f</A>
        is an element of <A>S</A>, then <C>Factorization</C> returns
        a word in the generators of <A>S</A> that is equal to <A>f</A>. Here, a
        word is a list of positive integers where <C>i</C> corresponds to
        <C>GeneratorsOfSemigroups(S)[i]</C>. More specifically,
      <Log>EvaluateWord(GeneratorsOfSemigroup(S), Factorization(S, f))=f;</Log>
      <P/>

        Note that <C>Factorization</C> does not return a word of minimum
        length.<P/> 

        See also <Ref Func="EvaluateWord"/> and 
        <Ref Func="GeneratorsOfSemigroup" BookName="ref"/>.
<Example>
gap> gens:=[ Transformation( [ 2, 2, 9, 7, 4, 9, 5, 5, 4, 8 ] ), 
> Transformation( [ 4, 10, 5, 6, 4, 1, 2, 7, 1, 2 ] ) ];;
gap> S:=Semigroup(gens);;
gap> f:=Transformation( [ 1, 10, 2, 10, 1, 2, 7, 10, 2, 7 ] );;
gap> Factorization(S, f);
[ 2, 2, 1, 2 ]
gap> EvaluateWord(gens, last);
Transformation( [ 1, 10, 2, 10, 1, 2, 7, 10, 2, 7 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Idempotent">
  <ManSection><Heading>Idempotent</Heading>
    <Func Name="Idempotent" Arg="ker, img"/>
    <Func Name="IdempotentNC" Arg="ker, img"/>
    <Returns>An idempotent transformation.</Returns>
    <Description>
      This function returns an idempotent with <Ref
      Func="CanonicalTransSameKernel"/> equal to <A>ker</A> and image set equal
      to <A>img</A> after first checking that <Ref
      Func="IsInjectiveTransOnList"/> holds with argument <A>ker, img</A>.  <P/>

     <C>IdempotentNC</C> returns an idempotent with 
     <Ref Func="CanonicalTransSameKernel"/>
     equal to <A>ker</A> and image set equal to <A>img</A> without
     checking that <Ref Func="IsInjectiveTransOnList"/> holds.
      <Example>
gap> f:=Transformation( [ 10, 2, 3, 10, 5, 10, 7, 2, 5, 6 ] );;
gap> ker:=CanonicalTransSameKernel(f);
[ 1, 2, 3, 1, 4, 1, 5, 2, 4, 6 ]
gap> img:=ImageSetOfTransformation(f);
[ 2, 3, 5, 6, 7, 10 ]
gap> Idempotent(ker, img);
Transformation( [ 6, 2, 3, 6, 5, 6, 7, 2, 5, 10 ] )</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InversesOfTransformation">
  <ManSection><Heading>InversesOfTransformation</Heading>
    <Oper Name="InversesOfTransformation" Arg="S, f"/>
    <Oper Name="InversesOfTransformationNC" Arg="S, f"/>
    <Returns>A list of transformations.</Returns>
    <Description>
      <C>InversesOfTransformation</C> returns a list of the inverses of the 
      transformation <A>f</A> in the transformation semigroup <A>S</A> after
      first checking that <A>f</A> is an element of <A>S</A>. <P/>
     
     A transformation <C>g</C> in <A>S</A> is an <E>inverse</E> of <A>f</A> if 
      <C><A>f</A>*g*<A>f</A>=<A>f</A></C> and <C>g*<A>f</A>*g=g</C>.<P/>
      
      The function <C>InversesOfTransformationNC</C> does not check that 
      <A>f</A> is an element of <A>S</A>.
      <Example>
gap> S:=Semigroup([ Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] ), 
>  Transformation( [ 5, 7, 8, 8, 7, 5, 9, 1, 9 ] ), 
>  Transformation( [ 7, 6, 2, 8, 4, 7, 5, 8, 3 ] ) ]);;
gap> f:=Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] );;
gap> InversesOfTransformationNC(S, f);
[  ]
gap> IsRegularSemigroupElement(S, f);
false
gap> f:=Transformation( [ 1, 9, 7, 5, 5, 1, 9, 5, 1 ] );;
gap> InversesOfTransformation(S, f);
[ Transformation( [ 1, 5, 1, 2, 5, 1, 3, 2, 2 ] ), 
  Transformation( [ 1, 2, 3, 5, 5, 1, 3, 5, 2 ] ), 
  Transformation( [ 1, 5, 1, 1, 5, 1, 3, 1, 2 ] ) ]
gap> IsRegularSemigroupElement(S, f);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsInjectiveTransOnList">
  <ManSection>
    <Oper Name="IsInjectiveTransOnList" Arg="obj, list"/>
    <Returns><K>true</K> or <K>false</K>.
    </Returns>
    <Description>
      The argument <A>obj</A> should be a transformation or the list of images
      of a transformation and <A>list</A> should be a list of positive
      integers.  If <A>obj</A> is a transformation, then we define
      <C>f:=<A>obj</A></C> and if <A>obj</A> is the image list of a
      transformation we define <C>f:=Transformation(<A>obj</A>)</C>.
      <C>IsInjectiveTransOnList</C> returns <K>true</K> if <C>f</C> is injective
      on <A>list</A> and <K>false</K> if it is not. If <A>list</A> is not
      duplicate free, then <K>false</K> is returned. <P/>

      See also <Ref Attr="ImageListOfTransformation" BookName="ref"/> and 
      <Ref Oper="Transformation" BookName="ref"/>.
      <Example>
gap> f:=Transformation( [ 2, 6, 7, 2, 6, 9, 9, 1, 1, 5 ] );;
gap> IsInjectiveTransOnList(f, [1,5]);
true
gap> IsInjectiveTransOnList(f, [5,1]);
true
gap> IsInjectiveTransOnList(f, [5,1,5,1,1,]);
false
gap> IsInjectiveTransOnList([1,2,3,4,5], [5,1,2,3]);   
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>
      

<#GAPDoc Label="IsRegularTransformation">
  <ManSection>
    <Oper Name="IsRegularTransformation" Arg="S, f"/>
    <Returns><K>true</K> or <K>false</K>.
    </Returns>
    <Description>
      This function returns <K>true</K> if <A>f</A> is a regular element of the 
      transformation semigroup <A>S</A> and <K>false</K> if it is not.<P/> 

      A transformation <A>f</A> is <E>regular</E> in a transformation semigroup
      <A>S</A> if it lies inside a regular &D;-class; see <Ref
      Attr="IsRegularDClass" BookName="ref"/> or <Ref
      Attr="IsRegularClass"/>.  Equivalently <A>f</A> is regular if the orbit
      of the image of <A>f</A> containing a transversal of the kernel of
      <A>f</A>; see <Ref Oper="Transformation" BookName="ref"/> and <Ref
      Attr="ImageSetOfTransformation" BookName="ref"/>.

      <Example>
gap> S:=Monoid(Transformation([2,2,4,4,5,6]),Transformation([5,3,4,4,6,6]));;
gap> f:=Generators(S)[1];;
gap> IsRegularTransformation(S, f);
true
gap> img:=ImageSetOfTransformation(f);
[ 2, 4, 5, 6 ]
gap> o:=Orb(S, img, OnSets);; Enumerate(o);
&lt;closed orbit, 3 points>
gap> ForAny(o, x-> IsInjectiveTransOnList(f, x));
true
gap> IsRegularTransformation(S, Generators(S)[2]);
false
gap> IsRegularTransformation(FullTransformationSemigroup(6), Generators(S)[2]);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Random">
  <ManSection>
    <Meth Name="Random" Arg="S" Label="for a semigroup"/>
    <Returns>A transformation or a partial permutation.</Returns>
    <Description>
      This function returns a random element of the semigroup of
      transformations or partial permutations <A>S</A>.  If
      the &R;-class structure of <A>S</A> has not been calculated, then a short
      product (at most <C>2*Length(GeneratorsOfSemigroup(<A>S</A>))</C>) of
      generators is returned.  If the &R;-class structure of <A>S</A> is known,
      then a random element of a randomly chosen &R;-class is returned.  
    </Description> 
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomIdempotent">
  <ManSection><Heading>RandomIdempotent</Heading>
    <Oper Name="RandomIdempotent" Arg="img, m"/>
    <Oper Name="RandomIdempotentNC" Arg="img, m"/>
    <Returns>An idempotent transformation.</Returns>
    <Description>
      Returns a random idempotent with image set <A>img</A> of degree <A>m</A>
      after checking that the maximum value in <A>img</A> is at most <A>m</A>. 
      <P/>

      <C>RandomIdempotentNC</C> returns a random idempotent with image set
      <A>img</A> of degree <A>m</A> without checking that the maximum value in
      <A>img</A> is at most <A>m</A>.

      <Log>
gap> RandomIdempotent([ 1, 2, 3 ], 5);
Transformation( [ 1, 2, 3, 1, 3 ] )
gap> RandomIdempotent([ 1, 2, 3 ], 4);
Transformation( [ 1, 2, 3, 3 ] )
gap> RandomIdempotent([ 1, 2, 3 ], 3);            
Transformation( [ 1, 2, 3 ] )
gap> RandomIdempotent([ 1, 2, 4, 5, 6 ], 10);
Transformation( [ 1, 2, 6, 4, 5, 6, 2, 5, 1, 6 ] )</Log>
    </Description>
  </ManSection>
<#/GAPDoc>

#EOF
