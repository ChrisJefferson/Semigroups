#############################################################################
##
#W  bipartition.xml
#Y  Copyright (C) 2011-13                                James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="IsBlockBijection">
  <ManSection>
    <Filt Name="IsBlockBijection" Arg='f'/>
    <Description>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="BipartitionFamily">
  <ManSection>
    <Fam Name="BipartitionFamily"/>
    <Description>
      The family of all bipartitions is <C>BipartitionFamily</C>.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBipartition">
  <ManSection>
    <Filt Name="IsBipartition" Arg='obj' Type='Category'/>
    <Description>
   Every bipartition in &GAP; belongs to the category
    <C>IsBipartition</C>. Basic operations for bipartitions are
    <Ref Attr="RightBlocks"/>,
    <Ref Attr="LeftBlocks"/>,
    <Ref Attr="ExtRepOfBipartition"/>,
    <Ref Attr="LeftProjection"/>,
    <Ref Attr="RightProjection"/>,
    <Ref Oper="InverseOp" Label="for a bipartition"/>, 
    <Ref Attr="DegreeOfBipartition"/>,
    <Ref Attr="RankOfBipartition"/>,
    multiplication of two bipartitions of equal degree is 
    via <K>*</K>. 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsBipartitionCollection">
  <ManSection>
    <Filt Name="IsBipartitionCollection" Arg='obj' Type='Category'/>
    <Description>
       Every collection of bipartitions belongs to the category
     <C>IsBipartitionCollection</C>. For example, bipartition semigroups
     belong to <C>IsBipartitionCollection</C>. 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsTransformation">
  <ManSection>
    <Oper Name="AsTransformation" Arg="f" Label="for a bipartition"/>
    <Oper Name="AsTransformationNC" Arg="f" Label="for a bipartition"/>
    <Returns>A transformation or <K>fail</K>.</Returns>
    <Description>
      When the argument <A>f</A> is a bipartition, that mathematically defines
      a transformation, this function returns that transformation. A
      bipartition <A>f</A> defines a transformation if and only if its right
      blocks are the image list of a permutation of <C>[1..n]</C> where
      <C>n</C> is the degere of <A>f</A>. <P/>
      
      <C>AsTransformation</C> verifies that its argument defines a
      transformation and <C>AsTransformationNC</C> does not. See 
      <Ref Oper="IsTransBipartition"/>. 
      <Example>
gap> f:=Bipartition([[ 1, -3 ], [ 2, -2 ], [ 3, 5, 10, -7 ], [ 4, -12 ], 
> [ 6, 7, -6 ], [ 8, -5 ], [ 9, -11 ], [ 11, 12, -10 ], [ -1 ], [ -4 ], 
> [ -8 ], [ -9 ]]);;
gap> AsTransformation(f);
Transformation( [ 3, 2, 7, 12, 7, 6, 6, 5, 11, 7, 10, 10 ] )
gap> IsTransBipartition(f);
true
gap> f:=Bipartition([[ 1, 5 ], [ 2, 4, 8, 10 ], [ 3, 6, 7, -1, -2 ], 
> [ 9, -4, -6, -9 ], [ -3, -5 ], [ -7, -8 ], [ -10 ]]);;
gap> AsTransformation(f);
fail</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsBipartition">
  <ManSection>
    <Oper Name="AsBipartition" Arg="f[, n]"/>
    <Returns>A bipartition.</Returns>
  <Description>
  <C>AsBipartition</C> 
  returns the bipartition, permutation, transformation, or partial permutation,
  as a bipartition. 
  
  There are several possible arguments for <C>AsBipartition</C>:
  <List>
    <Mark>permutations</Mark>
    <Item>
      If <A>f</A> is a permutation and <A>n</A> is a positive integer, then 
      <C>AsBipartition(<A>f</A>, <A>n</A>)</C> returns the bipartition
      on <C>[1..<A>n</A>]</C> with classes <C>[i, i^<A>f</A>]</C>
      for all <C>i=1..n</C>.<P/>
      
      If no positive integer <A>n</A> is specified, then
      the largest moved point of <A>f</A> is used as the value for <A>n</A>; see
      <Ref Func="LargestMovedPoint" Label="for a permutation" BookName="ref"/>.
    </Item>
    <Mark>transformations</Mark>      
    <Item>
      If <A>f</A> is a transformation and <A>n</A> is a positive integer
      such that <A>f</A> is a transformation of <C>[1..<A>n</A>]</C>, then
      <C>AsTransformation</C> returns the bipartition with classes
      <M>(i)f^-1\cup \{i\}</M> for all <C>i</C> in the image of <A>f</A>.
      
      If the positive integer <A>n</A> is not specified, then the
      internal degree of <A>f</A> is used as the value for <A>n</A>.
    </Item> 
    <Mark>partial permutations</Mark>
    <Item>
      If <A>f</A> is a partial permutation <A>f</A> and <A>n</A> is a
      positive integer, then <C>AsBipartition</C> returns the bipartition 
      with classes <C>[i, i^<A>f</A>]</C> for <C>i</C> in <C>[1..<A>n</A>]</C>. 
      Thus the degree of the returned bipartition is the maximum of <A>n</A>
      and the values <C>i^<A>f</A></C> where <C>i</C> in <C>[1..<A>n</A>]</C>.

      If the optional argument <A>n</A> is not present, then the default value
      of the maximum of the largest moved point and the largest image of a
      moved point of <A>f</A> plus <C>1</C> is used.
    </Item>
    <Mark>bipartitions</Mark>
    <Item>
      not yet implemented.
    </Item>
  </List>
  <Example>
gap> f:=Transformation( [ 3, 5, 3, 4, 1, 2 ] );;
gap> AsBipartition(f, 5);
&lt;bipartition: [ 1, 3, -3 ], [ 2, -5 ], [ 4, -4 ], [ 5, -1 ], [ -2 ]>
gap> AsBipartition(f);  
&lt;bipartition: [ 1, 3, -3 ], [ 2, -5 ], [ 4, -4 ], [ 5, -1 ], 
[ 6, -2 ], [ -6 ]>
gap> AsBipartition(f, 10);
&lt;bipartition: [ 1, 3, -3 ], [ 2, -5 ], [ 4, -4 ], [ 5, -1 ], 
[ 6, -2 ], [ 7, -7 ], [ 8, -8 ], [ 9, -9 ], [ 10, -10 ], [ -6 ]>
gap> AsBipartition((1, 3)(2, 4));
&lt;bipartition: [ 1, -3 ], [ 2, -4 ], [ 3, -1 ], [ 4, -2 ]>
gap> AsBipartition((1, 3)(2, 4), 10);
&lt;bipartition: [ 1, -3 ], [ 2, -4 ], [ 3, -1 ], [ 4, -2 ], [ 5, -5 ], 
[ 6, -6 ], [ 7, -7 ], [ 8, -8 ], [ 9, -9 ], [ 10, -10 ]>
gap> f:=PartialPerm( [ 1, 2, 3, 4, 5, 6 ], [ 6, 7, 1, 4, 3, 2 ] );;
gap> AsBipartition(f, 11);            
&lt;bipartition: [ 1, -6 ], [ 2, -7 ], [ 3, -1 ], [ 4, -4 ], [ 5, -3 ], 
[ 6, -2 ], [ 7 ], [ 8 ], [ 9 ], [ 10 ], [ 11 ], [ -5 ], [ -8 ], 
[ -9 ], [ -10 ], [ -11 ]>
gap> AsBipartition(f);
&lt;bipartition: [ 1, -6 ], [ 2, -7 ], [ 3, -1 ], [ 4, -4 ], [ 5, -3 ], 
[ 6, -2 ], [ 7 ], [ -5 ]>
gap> AsBipartition(Transformation( [ 1, 1, 2 ] ), 1);
&lt;bipartition: [ 1, -1 ]></Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsTransBipartition">
  <ManSection>
    <Prop Name="IsTransBipartition" Arg="f"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
    If the bipartition <A>f</A> defines a transformation, then
    <C>IsTransBipartition</C> returns <K>true</K>, and if not, then
    <K>false</K> is returned.<P/>

    A bipartition <A>f</A> defines a transformation if and only if the right
    blocks of <A>f</A> corresponds to a permutation of <C>[1..n]</C>, where
    <C>n</C> is the degree of <A>f</A>.
    <Example>
gap> f:=Bipartition( [ [ 1, 4, -2 ], [ 2, 5, -6 ], [ 3, -7 ], [ 6, 7, -9 ], 
> [ 8, 9, -1 ], [ 10, -5 ], [ -3 ], [ -4 ], [ -8 ], [ -10 ] ] );;
gap> IsTransBipartition(f);
true
gap> f:=Bipartition( [ [ 1, 4, -3, -6 ], [ 2, 5, -4, -5 ], [ 3, 6, -1 ], 
> [ -2 ] ] );;
gap> IsTransBipartition(f);
false
gap> Number(PartitionMonoid(3), IsTransBipartition);
27</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsPermBipartition">
  <ManSection>
    <Prop Name="IsPermBipartition" Arg="f"/>
    <Returns><K>true</K> or <K>false</K>.</Returns>
    <Description>
    If the bipartition <A>f</A> defines a permutation, then
    <C>IsPermBipartition</C> returns <K>true</K>, and if not, then
    <K>false</K> is returned.<P/>

    A bipartition <A>f</A> defines a permutation if and only if the left blocks
    of <A>f</A> are singletons and the right blocks of <A>f</A> correspond to a
    permutation of <C>[1..n]</C>, where <C>n</C> is the degree of <A>f</A>.
  
  <Example>
gap> f:=Bipartition( [ [ 1, 4, -1 ], [ 2, -3 ], [ 3, 6, -5 ], 
> [ 5, -2, -4, -6 ] ] );;
gap> IsPermBipartition(f);
false
gap> f:=Bipartition( [ [ 1, -3 ], [ 2, -4 ], [ 3, -6 ], [ 4, -1 ], [ 5, -5 ], 
> [ 6, -2 ], [ 7, -8 ], [ 8, -7 ] ] );;
gap> IsPermBipartition(f);
true</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="BipartitionByIntRep">
  <ManSection>
    <Oper Name="BipartitionByIntRep" Arg="list"/>
    <Oper Name="BipartitionByIntRepNC" Arg="list"/>
    <Returns>A bipartition.</Returns>
    <Description>
      It is possible to create a bipartition using from its internal
      representation. The argument <A>list</A> must be a list of positive
      integers not greater than <C>n</C>, of length <C>2*n</C>, and where
      <C>i</C> appears in the list only if <C>i-1</C> occurs earlier in the
      list. <P/>

      For example, the internal representation of the bipartition with blocks
      <Log>[ 1, -1 ], [ 2, 3, -2 ], [ -3 ]</Log> has
      internal representation 
      <Log>[ 1, 2, 2, 1, 2, 3 ]</Log> 
      The internal representation indicates that the number <C>1</C> is in
      class <C>1</C>, the number <C>2</C> is in class <C>2</C>, the number
      <C>3</C> is in class <C>2</C>, the number <C>-1</C> is
      in class <C>1</C>, the number <C>-2</C> is in class <C>2</C>, and 
      <C>-3</C> is in class <C>3</C>.
      As another example, <C>[ 1, 3, 2, 1 ]</C> is not the internal
      representation of any bipartition since there is no <C>2</C> before the 
      <C>3</C> in the second position.<P/>

      In its first form <C>BipartitionByIntRep</C> verifies that the argument
      <A>list</A> is the internal representation of a bipartition, whereas
      <C>BipartitionByIntRepNC</C> performs no checks. 
      <Example>
gap> BipartitionByIntRep([ 1, 2, 2, 1, 3, 4 ]);                         
&lt;bipartition: [ 1, -1 ], [ 2, 3 ], [ -2 ], [ -3 ]></Example> 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="PermLeftQuoBipartition">
  <ManSection>
    <Oper Name="PermLeftQuoBipartition" Arg="f, g"/>
    <Func Name="PermLeftQuoBipartitionNC" Arg="f, g"/>
    <Returns>A permutation.</Returns>
    <Description>
      If <A>f</A> and <A>g</A> are bipartitions with equal left and right
      blocks, then <C>PermLeftQuoBipartition</C> returns the permutation of the
      indices of the right blocks of <A>f</A> (and <A>g</A>) induced by 
      <C>Inverse(<A>f</A>)*<A>g</A></C>. <P/>

      <C>PermLeftQuoBipartition</C> verifies that <A>f</A> and <A>g</A> have
      equal left and right blocks, and returns an error if they do not.
      <C>PermLeftQuoTransformationNC</C> does no checks.<P/>

      The value returned by <C>PermLeftQuoBipartition(<A>f</A>,<A>g</A>)</C> is
      the same as that returned by 
      <C>PermRightBlocks(RightBlocks(<A>f</A>), Inverse(<A>f</A>)*g)</C>.
      See also <Ref Oper="PermRightBlocks"/> and 
       <Ref Oper="OnRightBlocksBipartitionByPerm"/>.
      <Example>
gap> f:=Bipartition( [ [ 1, 4, 6, 7, 8, 10 ], [ 2, 5, -1, -2, -8 ], 
> [ 3, -3, -6, -7, -9 ], [ 9, -4, -5 ], [ -10 ] ] );;
gap> g:=Bipartition( [ [ 1, 4, 6, 7, 8, 10 ], [ 2, 5, -3, -6, -7, -9 ], 
> [ 3, -4, -5 ], [ 9, -1, -2, -8 ], [ -10 ] ] );;
gap> PermLeftQuoBipartition(f, g);
(1,2,3)
gap> Inverse(f)*g;
&lt;bipartition: [ 1, 2, 8, -3, -6, -7, -9 ], [ 3, 6, 7, 9, -4, -5 ], 
[ 4, 5, -1, -2, -8 ], [ 10 ], [ -10 ]>
gap> PermRightBlocks(RightBlocks(f), last);
(1,2,3)</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="OnRightBlocksBipartitionByPerm">
  <ManSection>
    <Oper Name="OnRightBlocksBipartitionByPerm" Arg="f, p"/>
    <Returns>A bipartition.</Returns>
    <Description>
      If <A>f</A> is a bipartition and <A>p</A> is a permutation of the
      indices of the right blocks of <A>f</A>, then
      <C>OnRightBlocksBipartitionByPerm</C> returns the bipartition obtained
      from <A>f</A> by rearranging the right blocks of <A>f</A> according to
      <A>p</A>.
      
      <Example>
gap> f:=Bipartition( [ [ 1, 4, 6, 7, 8, 10 ], [ 2, 5, -1, -2, -8 ],
> [ 3, -3, -6, -7, -9 ], [ 9, -4, -5 ], [ -10 ] ] );;
gap> OnRightBlocksBipartitionByPerm(f, (1,2,3));
&lt;bipartition: [ 1, 4, 6, 7, 8, 10 ], [ 2, 5, -3, -6, -7, -9 ], 
[ 3, -4, -5 ], [ 9, -1, -2, -8 ], [ -10 ]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IdentityBipartition">
  <ManSection>
    <Func Name="IdentityBipartition" Arg="n"/>
    <Returns>The identity bipartition.</Returns>
    <Description>
      Returns the identity bipartition with degree <A>n</A>. 
      <Example>
gap> IdentityBipartition(10);
&lt;bipartition: [ 1, -1 ], [ 2, -2 ], [ 3, -3 ], [ 4, -4 ], [ 5, -5 ], 
[ 6, -6 ], [ 7, -7 ], [ 8, -8 ], [ 9, -9 ], [ 10, -10 ]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RankOfBipartition">
  <ManSection>
    <Attr Name="RankOfBipartition" Arg="f"/>
    <Attr Name="NrTransverseBlocks" Arg="f" Label="for a bipartition"/>
    <Returns>The rank of a bipartition.</Returns>
    <Description>
      When the argument is a bipartition <A>f</A>, <C>RankOfBipartition</C>
      returns the number of blocks of <A>f</A> containing both positive and
      negative entries, i.e. the number of transverse blocks of <A>f</A>.<P/>

      <C>NrTransverseBlocks</C> is just a synonym for <C>RankOfBipartition</C>. 
      <Example>
gap> f:=Bipartition( [ [ 1, 2, 6, 7, -4, -5, -7 ], [ 3, 4, 5, -1, -3 ], 
> [ 8, -9 ], [ 9, -2 ], [ -6 ], [ -8 ] ] );
&lt;bipartition: [ 1, 2, 6, 7, -4, -5, -7 ], [ 3, 4, 5, -1, -3 ], 
[ 8, -9 ], [ 9, -2 ], [ -6 ], [ -8 ]>
gap> RankOfBipartition(f);
4</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="DegreeOfBipartition">
  <ManSection>
    <Attr Name="DegreeOfBipartition" Arg="f"/>
    <Attr Name="DegreeOfBipartitionCollection" Arg="f"/>
    <Returns>A positive integer.</Returns>
    <Description>
The degree of a bipartition is, roughly speaking, the number of points where
the bipartition is defined. More precisely, if <A>f</A> is a bipartition defined on <C>2*n</C> points, then the degree of <A>f</A> is <C>n</C>. <P/>

The degree of a collection <A>coll</A> of bipartitions of equal degree is just
the degree of any (and every) bipartition in <A>coll</A>. The degree of collection of bipartitions of unequal degrees is not defined. 

<Example>
gap> f:=Bipartition( [ [ 1, 7, -3, -8 ], [ 2, 6 ], [ 3 ], [ 4, -7, -9 ], 
> [ 5, 9, -2 ], [ 8, -1, -4, -6 ], [ -5 ] ] );;
gap> DegreeOfBipartition(f);
9
gap> s:=BrauerMonoid(5);
&lt;regular bipartition semigroup on 5 pts with 3 generators>
gap> IsBipartitionCollection(s);
true
gap> DegreeOfBipartitionCollection(s);
5</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Bipartition">
  <ManSection>
    <Func Name="Bipartition" Arg="blocks"/>
    <Func Name="BipartitionNC" Arg="blocks"/>
    <Returns>A bipartition.</Returns>
    <Description>
      <C>Bipartition</C> returns the bipartition <C>f</C> with equivalence
      classes <A>blocks</A>, which should be a list of duplicate-free lists
      whose union is <C>[-n..-1]</C> union <C>[1..n]</C> for some positive
      integer <C>n</C>. <P/>
      
      <C>Bipartition</C> returns an error if the argument does not define a
      bipartition, whereas <C>BipartitionNC</C> performs no checks on its
      argument. 
      <Example>
gap> f:=Bipartition( [ [ 1, -1 ],[ 2, 3, -3 ], [ -2 ] ] );
&lt;bipartition: [ 1, -1 ], [ 2, 3, -3 ], [ -2 ]></Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ExtRepOfBipartition">
  <ManSection>
    <Attr Name="ExtRepOfBipartition" Arg="f"/>
    <Returns>A partition of <C>[1..2*n]</C>.</Returns>
    <Description>
      If <C>n</C> is the degree of the bipartition
      <A>f</A>, then <C>ExtRepOfBipartition</C> returns the partition of 
      <C>[-n..-1]</C> union <C>[1..n]</C> corresponding to <A>f</A> as a
      sorted list of duplicate-free lists. 
<Example>
gap> f:=Bipartition( [ [ 1, 5, -3 ], [ 2, 4, -2, -4 ], [ 3, -1, -5 ] ] );
&lt;bipartition: [ 1, 5, -3 ], [ 2, 4, -2, -4 ], [ 3, -1, -5 ]>
gap> ExtRepOfBipartition(f);
[ [ 1, 5, -3 ], [ 2, 4, -2, -4 ], [ 3, -1, -5 ] ]</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="LeftProjection">
  <ManSection>
    <Attr Name="LeftOne" Arg="f" Label="for a bipartition"/>
    <Attr Name="LeftProjection" Arg="f"/>
    <Returns>A bipartition.</Returns>
    <Description>
      The <C>LeftProjection</C> of a bipartition <A>f</A> is the bipartition
      <C><A>f</A>*Inverse(<A>f</A>)</C>. It is so-named, since the left and
      right blocks of the left projection equal the left blocks of <A>f</A>.
      <P/>

      The left projection <C>e</C> of <A>f</A> is also a bipartition with the
      property that <C>e*<A>f</A>=<A>f</A></C>. <C>LeftOne</C> and
      <C>LeftProjection</C> are synonymous. 
      <Example>
gap> f:=Bipartition( [ [ 1, 4, -1, -2, -6 ], [ 2, 3, 5, -4 ], 
> [ 6, -3 ], [ -5 ] ] );;
gap> LeftOne(f);
&lt;bipartition: [ 1, 4, -1, -4 ], [ 2, 3, 5, -2, -3, -5 ], [ 6, -6 ]>
gap> LeftBlocks(f);
&lt;blocks: [ 1, 4 ], [ 2, 3, 5 ], [ 6 ]>
gap> RightBlocks(LeftOne(f));
&lt;blocks: [ 1, 4 ], [ 2, 3, 5 ], [ 6 ]>
gap> LeftBlocks(LeftOne(f)); 
&lt;blocks: [ 1, 4 ], [ 2, 3, 5 ], [ 6 ]>
gap> LeftOne(f)*f=f;
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RightProjection">
  <ManSection>
    <Attr Name="RightOne" Arg="f" Label="for a bipartition"/>
    <Attr Name="RightProjection" Arg="f"/>
    <Returns>A bipartition.</Returns>
    <Description>
      The <C>RightProjection</C> of a bipartition <A>f</A> is the bipartition
      <C>Inverse(<A>f</A>)*<A>f</A></C>. It is so-named, since the left and
      right blocks of the right projection equal the right blocks of <A>f</A>.
      <P/>

      The right projection <C>e</C> of <A>f</A> is also a bipartition with the
      property that <C><A>f</A>*e=<A>f</A></C>. <C>RightOne</C> and
      <C>RightProjection</C> are synonymous.
      <Example>
gap> f:=Bipartition( [ [ 1, -1, -4 ], [ 2, -2, -3 ], [ 3, 4 ], [ 5, -5 ] ] );;
gap> RightOne(f);
&lt;bipartition: [ 1, 4, -1, -4 ], [ 2, 3, -2, -3 ], [ 5, -5 ]>
gap> RightBlocks(RightOne(f));
&lt;blocks: [ 1, 4 ], [ 2, 3 ], [ 5 ]>
gap> LeftBlocks(RightOne(f));        
&lt;blocks: [ 1, 4 ], [ 2, 3 ], [ 5 ]>
gap> RightBlocks(f);
&lt;blocks: [ 1, 4 ], [ 2, 3 ], [ 5 ]>
gap> f*RightOne(f)=f;
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InverseOp">
  <ManSection>
    <Oper Name="InverseOp" Arg="f" Label="for a bipartition"/>
    <Returns>A bipartition.</Returns>
    <Description>
      <C>InverseOp</C> returns the unique bipartition <C>g</C> with the
      property that: <C><A>f</A>*g*<A>f</A>=<A>f</A></C>,
      <C>RightBlocks(<A>f</A>)=LeftBlocks(g)</C>, and
      <C>LeftBlocks(<A>f</A>)=RightBlocks(g)</C>. The inverse <C>g</C> can
      be obtained from <A>f</A> by changing the sign of every integer in the
      external representation of <A>f</A>.  
      <Example>
gap> f:=Bipartition( [ [ 1, -4 ], [ 2, 3, 4 ], [ 5 ], [ -1 ], 
> [ -2, -3 ], [ -5 ] ] );
&lt;bipartition: [ 1, -4 ], [ 2, 3, 4 ], [ 5 ], [ -1 ], [ -2, -3 ], 
[ -5 ]>
gap> g:=Inverse(f);
&lt;bipartition: [ 1 ], [ 2, 3 ], [ 4, -1 ], [ 5 ], [ -2, -3, -4 ], 
[ -5 ]>
gap> f*g*f=f;
true
gap> LeftBlocks(f)=RightBlocks(g);
true
gap> RightBlocks(f)=LeftBlocks(g); 
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomBipartition">
  <ManSection>
    <Attr Name="RandomBipartition" Arg="n"/>
    <Returns>A bipartition.</Returns>
    <Description>
      If <A>n</A> is a positive integer, then <C>RandomBipartition</C> returns
      a random bipartition of degree <A>n</A>.
      <Log>
gap> f:=RandomBipartition(6); 
&lt;bipartition: [ 1, 2, 3, 4 ], [ 5 ], [ 6, -2, -3, -4 ], [ -1, -5 ], [ -6 ]>
</Log>
    </Description>
  </ManSection>
<#/GAPDoc>


