  
  [1X2 Transformations[0X
  
  The  functions  described  in  this  section extend the functionality of [5XGAP[0m
  relating to transformations.
  
  
  [1X2.1 Creating Transformations[0X
  
  
  [1X2.1-1 TransformationByKernelAndImage[0X
  
  [2X> TransformationByKernelAndImage( [0X[3Xker, img[0X[2X ) ______________________[0Xoperation
  [2X> TransformationByKernelAndImageNC( [0X[3Xker, img[0X[2X ) ____________________[0Xoperation
  
  returns the transformation [10Xf[0m with kernel [10Xker[0m and image [10Ximg[0m where [10X(x)f=img[i][0m
  for all [10Xx[0m in [10Xker[i][0m. The argument [10Xker[0m should be a set of sets that partition
  the set [10X1,...n[0m for some [10Xn[0m and [10Ximg[0m should be a sublist of [10X1,...n[0m.
  
  [10XTransformationByKernelAndImage[0m  first  checks  that [10Xker[0m and [10Ximg[0m describe the
  kernel       and       image      of      a      transformation      whereas
  [10XTransformationByKernelAndImageNC[0m performs no such check.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> TransformationByKernelAndImageNC([[1,2,3,4],[5,6,7],[8]],[1,2,8]);[0X
    [4X  Transformation( [ 1, 1, 1, 1, 2, 2, 2, 8 ] )[0X
    [4X  gap> TransformationByKernelAndImageNC([[1,6],[2,5],[3,4]], [4,5,6]);[0X
    [4X  Transformation( [ 4, 5, 6, 6, 5, 4 ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.1-2 AllTransformationsWithKerAndImg[0X
  
  [2X> AllTransformationsWithKerAndImg( [0X[3Xker, img[0X[2X ) _____________________[0Xoperation
  [2X> AllTransformationsWithKerAndImgNC( [0X[3Xker, img[0X[2X ) ___________________[0Xoperation
  
  returns  a  list  of  all transformations with kernel [10Xker[0m and image [10Ximg[0m. The
  argument  [10Xker[0m should be a set of sets that partition the set [10X1,...n[0m for some
  [10Xn[0m and [10Ximg[0m should be a sublist of [10X1,...n[0m.
  
  [10XAllTransformationsWithKerAndImg[0m  first  checks that [10Xker[0m and [10Ximg[0m describe the
  kernel       and       image      of      a      transformation      whereas
  [10XAllTransformationsWithKerAndImgNC[0m performs no such check.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> AllTransformationsWithKerAndImg([[1,6],[2,5],[3,4]], [4,5,6]);[0X
    [4X  [ Transformation( [ 4, 5, 6, 6, 5, 4 ] ), [0X
    [4X    Transformation( [ 6, 5, 4, 4, 5, 6 ] ), [0X
    [4X    Transformation( [ 6, 4, 5, 5, 4, 6 ] ), [0X
    [4X    Transformation( [ 4, 6, 5, 5, 6, 4 ] ), [0X
    [4X    Transformation( [ 5, 6, 4, 4, 6, 5 ] ), [0X
    [4X    Transformation( [ 5, 4, 6, 6, 4, 5 ] ) ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.1-3 Idempotent[0X
  
  [2X> IdempotentNC( [0X[3Xker, img[0X[2X ) _________________________________________[0Xfunction
  [2X> Idempotent( [0X[3Xker, img[0X[2X ) ___________________________________________[0Xfunction
  
  [10XIdempotentNC[0m  returns  an  idempotent  with kernel [10Xker[0m and image [10Ximg[0m without
  checking [2XIsTransversal[0m ([14X2.2-1[0m) with arguments [10Xker[0m and [10Xim[0m.
  
  [10XIdempotent[0m  returns  an  idempotent  with  kernel  [10Xker[0m  and  image [10Ximg[0m after
  checking that [2XIsTransversal[0m ([14X2.2-1[0m) with arguments [10Xker[0m and [10Xim[0m returns [10Xtrue[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> g1:=Transformation([2,2,4,4,5,6]);;[0X
    [4X  gap> g2:=Transformation([5,3,4,4,6,6]);;[0X
    [4X  gap> ker:=KernelOfTransformation(g2*g1);;[0X
    [4X  gap> im:=ImageListOfTransformation(g2);;[0X
    [4X  gap> Idempotent(ker, im);[0X
    [4X  Error,  the image must be a transversal of the kernel[0X
    [4X  [ ... ][0X
    [4X  gap> Idempotent([[1,2,3],[4,5],[6,7]], [1,5,6]);[0X
    [4X  Transformation( [ 1, 1, 1, 5, 5, 6, 6 ] )[0X
    [4X  gap> IdempotentNC([[1,2,3],[4,5],[6,7]], [1,5,6]);[0X
    [4X  Transformation( [ 1, 1, 1, 5, 5, 6, 6 ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.1-4 RandomIdempotent[0X
  
  [2X> RandomIdempotent( [0X[3Xarg[0X[2X ) _________________________________________[0Xoperation
  [2X> RandomIdempotentNC( [0X[3Xarg[0X[2X ) _______________________________________[0Xoperation
  
  If  the  argument  is  a kernel, then a random idempotent is return that has
  that  kernel.  A  [13Xkernel[0m  is a set of sets that partition the set [10X1,...n[0m for
  some [10Xn[0m and an [13Ximage[0m is a sublist of [10X1,...n[0m.
  
  If  the  first argument is an image [10Ximg[0m and the second a positive integer [10Xn[0m,
  then a random idempotent of degree [10Xn[0m is returned with image [10Ximg[0m.
  
  The no check version does not check that the arguments can be the kernel and
  image of an idempotent.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> RandomIdempotent([[1,2,3], [4,5], [6,7,8]], [1,2,3]);;[0X
    [4X  fail[0X
    [4X  gap> RandomIdempotent([1,2,3],5);[0X
    [4X  Transformation( [ 1, 2, 3, 1, 3 ] )[0X
    [4X  gap> RandomIdempotent([[1,6], [2,4], [3,5]]);[0X
    [4X  Transformation( [ 1, 2, 5, 2, 5, 1 ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.1-5 RandomTransformation[0X
  
  [2X> RandomTransformation( [0X[3Xarg[0X[2X ) _____________________________________[0Xoperation
  [2X> RandomTransformationNC( [0X[3Xarg[0X[2X ) ___________________________________[0Xoperation
  
  These are new methods for the existing library function [2XRandomTransformation[0m
  ([14XReference: RandomTransformation[0m).
  
  If  the  first  argument  is a kernel and the second an image, then a random
  transformation  is  returned with this kernel and image.A [13Xkernel[0m is a set of
  sets  that  partition the set [10X1,...n[0m for some [10Xn[0m and an [13Ximage[0m is a sublist of
  [10X1,...n[0m.
  
  If  the  argument is a kernel, then a random transformation is returned that
  has that kernel.
  
  If  the  first argument is an image [10Ximg[0m and the second a positive integer [10Xn[0m,
  then a random transformation of degree [10Xn[0m is returned with image [10Ximg[0m.
  
  The no check version does not check that the arguments can be the kernel and
  image of a transformation.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> RandomTransformation([[1,2,3], [4,5], [6,7,8]], [1,2,3]);;[0X
    [4X  Transformation( [ 2, 2, 2, 1, 1, 3, 3, 3 ] )[0X
    [4X  gap> RandomTransformation([[1,2,3],[5,7],[4,6]]); [0X
    [4X  Transformation( [ 3, 3, 3, 6, 1, 6, 1 ] )[0X
    [4X  gap> RandomTransformation([[1,2,3],[5,7],[4,6]]);[0X
    [4X  Transformation( [ 4, 4, 4, 7, 3, 7, 3 ] )[0X
    [4X  gap> RandomTransformationNC([[1,2,3],[5,7],[4,6]]);[0X
    [4X  Transformation( [ 1, 1, 1, 7, 5, 7, 5 ] )[0X
    [4X  gap> RandomTransformation([1,2,3], 6);             [0X
    [4X  Transformation( [ 2, 1, 2, 1, 1, 2 ] )[0X
    [4X  gap> RandomTransformationNC([1,2,3], 6);[0X
    [4X  Transformation( [ 3, 1, 2, 2, 1, 2 ] )[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.1-6 TransformationActionNC[0m
  
  [2X> TransformationActionNC( [0X[3Xlist, act, elm[0X[2X ) ________________________[0Xoperation
  
  returns the list [10Xlist[0m acted on by [10Xelm[0m via the action [10Xact[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> mat:=OneMutable(GeneratorsOfGroup(GL(3,3))[1]);[0X
    [4X  [ [ Z(3)^0, 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, 0*Z(3) ], [0X
    [4X    [ 0*Z(3), 0*Z(3), Z(3)^0 ] ][0X
    [4X  gap> mat[3][3]:=Z(3)*0; [0X
    [4X  0*Z(3)[0X
    [4X  gap> F:=BaseDomain(mat);[0X
    [4X  GF(3)[0X
    [4X  gap> TransformationActionNC(Elements(F^3), OnRight, mat);[0X
    [4X  Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 10, 10, 10, 13, 13, 13, 16, 16, [0X
    [4X    16, 19, 19, 19, 22, 22, 22, 25, 25, 25 ] )[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.2 Properties & Attributes[0X
  
  [1X2.2-1 IsTransversal[0m
  
  [2X> IsTransversal( [0X[3Xlist1, list2[0X[2X ) ____________________________________[0Xfunction
  
  returns  [10Xtrue[0m if the list [10Xlist2[0m is a transversal of the list of lists [10Xlist1[0m.
  That is, if every list in [10Xlist1[0m contains exactly one element in [10Xlist2[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> g1:=Transformation([2,2,4,4,5,6]);;[0X
    [4X  gap> g2:=Transformation([5,3,4,4,6,6]);;[0X
    [4X  gap> ker:=KernelOfTransformation(g2*g1);[0X
    [4X  [ [ 1 ], [ 2, 3, 4 ], [ 5, 6 ] ] [0X
    [4X  gap> im:=ImageListOfTransformation(g2);[0X
    [4X  [ 5, 3, 4, 4, 6, 6 ][0X
    [4X  gap> IsTransversal(ker, im);[0X
    [4X  false[0X
    [4X  gap> IsTransversal([[1,2,3],[4,5],[6,7]], [1,5,6]);[0X
    [4X  true[0X
    [4X  [0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.2-2 IsKerImgOfTransformation[0m
  
  [2X> IsKerImgOfTransformation( [0X[3Xker, img[0X[2X ) _____________________________[0Xfunction
  
  returns  [10Xtrue[0m  if the arguments [10Xker[0m and [10Ximg[0m can be the kernel and image of a
  single  transformation,  respectively.  The  argument [10Xker[0m should be a set of
  sets that partition the set [10X1,...n[0m for some [10Xn[0m and [10Ximg[0m should be a sublist of
  [10X1,...n[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> ker:=[[1,2,3],[5,6],[8]];[0X
    [4X  [ [ 1, 2, 3 ], [ 5, 6 ], [ 8 ] ][0X
    [4X  gap> img:=[1,2,9];[0X
    [4X  [ 1, 2, 9 ][0X
    [4X  gap> IsKerImgOfTransformation(ker,img);[0X
    [4X  false[0X
    [4X  gap> ker:=[[1,2,3,4],[5,6,7],[8]];[0X
    [4X  [ [ 1, 2, 3, 4 ], [ 5, 6, 7 ], [ 8 ] ][0X
    [4X  gap> IsKerImgOfTransformation(ker,img);[0X
    [4X  false[0X
    [4X  gap> img:=[1,2,8];[0X
    [4X  [ 1, 2, 8 ][0X
    [4X  gap> IsKerImgOfTransformation(ker,img);[0X
    [4X  true[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.2-3 KerImgOfTransformation[0m
  
  [2X> KerImgOfTransformation( [0X[3Xf[0X[2X ) _____________________________________[0Xoperation
  
  returns  the  kernel and image set of the transformation [10Xf[0m. These attributes
  of  [10Xf[0m  can  be  obtain  separately  using [2XKernelOfTransformation[0m ([14XReference:
  KernelOfTransformation[0m)     and     [2XImageSetOfTransformation[0m     ([14XReference:
  ImageSetOfTransformation[0m), respectively.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> t:=Transformation( [ 10, 8, 7, 2, 8, 2, 2, 6, 4, 1 ] );;[0X
    [4X  gap> KerImgOfTransformation(t);[0X
    [4X  [ [ [ 1 ], [ 2, 5 ], [ 3 ], [ 4, 6, 7 ], [ 8 ], [ 9 ], [ 10 ] ], [0X
    [4X    [ 1, 2, 4, 6, 7, 8, 10 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.2-4 IsRegularTransformation[0m
  
  [2X> IsRegularTransformation( [0X[3XS, f[0X[2X ) _________________________________[0Xoperation
  
  if  [10Xf[0m  is  a regular element of the transformation semigroup [10XS[0m, then [10Xtrue[0m is
  returned. Otherwise [10Xfalse[0m is returned.
  
  A transformation [10Xf[0m is regular inside a transformation semigroup [10XS[0m if it lies
  inside  a regular D-class. This is equivalent to the orbit of the image of [10Xf[0m
  containing a transversal of the kernel of [10Xf[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4Xgap> g1:=Transformation([2,2,4,4,5,6]);;[0X
    [4Xgap> g2:=Transformation([5,3,4,4,6,6]);;[0X
    [4Xgap> m1:=Monoid(g1,g2);;[0X
    [4Xgap> IsRegularTransformation(m1, g1);[0X
    [4Xtrue[0X
    [4Xgap> img:=ImageSetOfTransformation(g1);[0X
    [4X[ 2, 4, 5, 6 ][0X
    [4Xgap> ker:=KernelOfTransformation(g1);[0X
    [4X[ [ 1, 2 ], [ 3, 4 ], [ 5 ], [ 6 ] ][0X
    [4Xgap> ForAny(MonoidOrbit(m1, img), x-> IsTransversal(ker, x));[0X
    [4Xtrue[0X
    [4Xgap> IsRegularTransformation(m1, g2);[0X
    [4Xfalse[0X
    [4Xgap> IsRegularTransformation(FullTransformationSemigroup(6), g2);[0X
    [4Xtrue[0X
    [4X	[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.2-5 IndexPeriodOfTransformation[0m
  
  [2X> IndexPeriodOfTransformation( [0X[3Xf[0X[2X ) ________________________________[0Xattribute
  
  returns  the  minimum numbers [10Xm, r[0m such that [10Xf^(m+r)=f^m[0m; known as the [13Xindex[0m
  and [13Xperiod[0m of the transformation.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> f:=Transformation( [ 3, 4, 4, 6, 1, 3, 3, 7, 1 ] );;[0X
    [4X  gap> IndexPeriodOfTransformation(f);[0X
    [4X  [ 2, 3 ][0X
    [4X  gap> f^2=f^5;[0X
    [4X  true[0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.2-6 SmallestIdempotentPower[0m
  
  [2X> SmallestIdempotentPower( [0X[3Xf[0X[2X ) ____________________________________[0Xattribute
  
  returns  the  least  natural number [10Xn[0m such that the transformation [10Xf^n[0m is an
  idempotent.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> t:=Transformation( [ 6, 7, 4, 1, 7, 4, 6, 1, 3, 4 ] );;[0X
    [4X  gap> SmallestIdempotentPower(t);[0X
    [4X  6[0X
    [4X  gap> t:=Transformation( [ 6, 6, 6, 2, 7, 1, 5, 3, 10, 6 ] );;[0X
    [4X  gap> SmallestIdempotentPower(t);[0X
    [4X  4[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.2-7 InversesOfTransformation[0X
  
  [2X> InversesOfTransformation( [0X[3XS, f[0X[2X ) ________________________________[0Xoperation
  [2X> InversesOfTransformationNC( [0X[3XS, f[0X[2X ) ______________________________[0Xoperation
  
  returns a list of the inverses of the transformation [10Xf[0m in the transformation
  semigroup  [10XS[0m.  The function [10XInversesOfTransformationNC[0m does not check that [10Xf[0m
  is an element of [10XS[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> S:=Semigroup([ Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] ), [0X
    [4X    Transformation( [ 5, 7, 8, 8, 7, 5, 9, 1, 9 ] ), [0X
    [4X    Transformation( [ 7, 6, 2, 8, 4, 7, 5, 8, 3 ] ) ]);;[0X
    [4X  gap> f:=Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] );;[0X
    [4X  gap> InversesOfTransformationNC(S, f);[0X
    [4X  [  ][0X
    [4X  gap> IsRegularTransformation(S, f);[0X
    [4X  false[0X
    [4X  gap> f:=Transformation( [ 1, 9, 7, 5, 5, 1, 9, 5, 1 ] );;[0X
    [4X  gap> inv:=InversesOfTransformation(S, f);[0X
    [4X  [ Transformation( [ 1, 5, 1, 1, 5, 1, 3, 1, 2 ] ), [0X
    [4X    Transformation( [ 1, 5, 1, 2, 5, 1, 3, 2, 2 ] ), [0X
    [4X    Transformation( [ 1, 2, 3, 5, 5, 1, 3, 5, 2 ] ) ][0X
    [4X  gap> IsRegularTransformation(S, f);[0X
    [4X  true[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1X2.3 Changing Representation[0X
  
  [1X2.3-1 AsBooleanMatrix[0m
  
  [2X> AsBooleanMatrix( [0X[3Xf[, n][0X[2X ) _______________________________________[0Xoperation
  
  returns the transformation or permutation [10Xf[0m represented as an [10Xn[0m by [10Xn[0m Boolean
  matrix where [10Xi,f(i)[0mth entries equal [10X1[0m and all other entries are [10X0[0m.
  
  If [10Xf[0m is a transformation, then [10Xn[0m is the size of the domain of [10Xf[0m.
  
  If [10Xf[0m is a permutation, then [10Xn[0m is the number of points moved by [10Xf[0m.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> t:=Transformation( [ 4, 2, 2, 1 ] );;[0X
    [4X  gap> AsBooleanMatrix(t);[0X
    [4X  [ [ 0, 0, 0, 1 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ] ][0X
    [4X  gap> t:=(1,4,5);;[0X
    [4X  gap> AsBooleanMatrix(t);[0X
    [4X  [ [ 0, 0, 0, 1, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1 ],[0X
    [4X    [ 1, 0, 0, 0, 0 ] ][0X
    [4X  gap> AsBooleanMatrix(t,3);[0X
    [4X  fail[0X
    [4X  gap> AsBooleanMatrix(t,5);[0X
    [4X  [ [ 0, 0, 0, 1, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1 ],[0X
    [4X    [ 1, 0, 0, 0, 0 ] ][0X
    [4X  gap> AsBooleanMatrix(t,6);[0X
    [4X  [ [ 0, 0, 0, 1, 0, 0 ], [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 1, 0, 0, 0 ], [0X
    [4X    [ 0, 0, 0, 0, 1, 0 ], [ 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  [1X2.3-2 AsPermOfRange[0m
  
  [2X> AsPermOfRange( [0X[3Xx[0X[2X ) ______________________________________________[0Xoperation
  
  converts  a  transformation  [10Xx[0m  that is a permutation of its image into that
  permutation.
  
  [4X---------------------------  Example  ----------------------------[0X
    [4X  gap> t:=Transformation([1,2,9,9,9,8,8,8,4]);[0X
    [4X  Transformation( [ 1, 2, 9, 9, 9, 8, 8, 8, 4 ] )[0X
    [4X  gap> AsPermOfRange(t);[0X
    [4X  (4,9)[0X
    [4X  gap> t*last;[0X
    [4X  Transformation( [ 1, 2, 4, 4, 4, 8, 8, 8, 9 ] )[0X
    [4X  gap> AsPermOfRange(last);[0X
    [4X  ()[0X
  [4X------------------------------------------------------------------[0X
  
