<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (MONOID) - Chapter 2: Transformations</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap1.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap3.html">Next Chapter</a>&nbsp;  </div>

<p><a id="X860026B880BCB2A5" name="X860026B880BCB2A5"></a></p>
<div class="ChapSects"><a href="chap2.html#X860026B880BCB2A5">2 <span class="Heading">Transformations</span></a>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap2.html#X80F3086F87E93DF8">2.1 <span class="Heading">Creating Transformations</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82CB17E47CBCFA69">2.1-1 <span class="Heading">TransformationByKernelAndImage</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D1937FF85B76BB3">2.1-2 <span class="Heading">AllTransformationsWithKerAndImg</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85D1071484CE004C">2.1-3 <span class="Heading">Idempotent</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7C5BED247F770ECB">2.1-4 <span class="Heading">RandomIdempotent</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8475448F87E8CB8A">2.1-5 <span class="Heading">RandomTransformation</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X814B3E6E7D3F1036">2.1-6 TransformationActionNC</a></span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap2.html#X84DD0B3981E5735B">2.2 <span class="Heading">Properties &amp; Attributes</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79E9FFC97AFCEE61">2.2-1 IsTransversal</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79A3FCED7E8A8B1B">2.2-2 IsKerImgOfTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E72E6117BFFC74E">2.2-3 KerImgOfTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7856A73E80DAF56F">2.2-4 IsRegularTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X863216CB7AF88BED">2.2-5 IndexPeriodOfTransformation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X84E1A41F84B70DBB">2.2-6 SmallestIdempotentPower</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X846B9EBB86A69BDC">2.2-7 <span class="Heading">InversesOfTransformation</span></a>
</span>
</div>
<div class="ContSect"><span class="nocss">&nbsp;</span><a href="chap2.html#X80B8EF3D78E711BB">2.3 <span class="Heading">Changing Representation</span></a>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F867C337B18D84E">2.3-1 AsBooleanMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A249D7781F31C22">2.3-2 AsPermOfRange</a></span>
</div>
</div>

<h3>2 <span class="Heading">Transformations</span></h3>

<p>The functions described in this section extend the functionality of <strong class="pkg">GAP</strong> relating to transformations.</p>

<p><a id="X80F3086F87E93DF8" name="X80F3086F87E93DF8"></a></p>

<h4>2.1 <span class="Heading">Creating Transformations</span></h4>

<p><a id="X82CB17E47CBCFA69" name="X82CB17E47CBCFA69"></a></p>

<h5>2.1-1 <span class="Heading">TransformationByKernelAndImage</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TransformationByKernelAndImage</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TransformationByKernelAndImageNC</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>returns the transformation <code class="code">f</code> with kernel <code class="code">ker</code> and image <code class="code">img</code> where <code class="code">(x)f=img[i]</code> for all <code class="code">x</code> in <code class="code">ker[i]</code>. The argument <code class="code">ker</code> should be a set of sets that partition the set <code class="code">1,...n</code> for some <code class="code">n</code> and <code class="code">img</code> should be a sublist of <code class="code">1,...n</code>.</p>

<p><code class="code">TransformationByKernelAndImage</code> first checks that <code class="code">ker</code> and <code class="code">img</code> describe the kernel and image of a transformation whereas <code class="code">TransformationByKernelAndImageNC</code> performs no such check.</p>


<table class="example">
<tr><td><pre>
  gap&gt; TransformationByKernelAndImageNC([[1,2,3,4],[5,6,7],[8]],[1,2,8]);
  Transformation( [ 1, 1, 1, 1, 2, 2, 2, 8 ] )
  gap&gt; TransformationByKernelAndImageNC([[1,6],[2,5],[3,4]], [4,5,6]);
  Transformation( [ 4, 5, 6, 6, 5, 4 ] )
</pre></td></tr></table>

<p><a id="X7D1937FF85B76BB3" name="X7D1937FF85B76BB3"></a></p>

<h5>2.1-2 <span class="Heading">AllTransformationsWithKerAndImg</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AllTransformationsWithKerAndImg</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AllTransformationsWithKerAndImgNC</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>returns a list of all transformations with kernel <code class="code">ker</code> and image <code class="code">img</code>. The argument <code class="code">ker</code> should be a set of sets that partition the set <code class="code">1,...n</code> for some <code class="code">n</code> and <code class="code">img</code> should be a sublist of <code class="code">1,...n</code>.</p>

<p><code class="code">AllTransformationsWithKerAndImg</code> first checks that <code class="code">ker</code> and <code class="code">img</code> describe the kernel and image of a transformation whereas <code class="code">AllTransformationsWithKerAndImgNC</code> performs no such check.</p>


<table class="example">
<tr><td><pre>
  gap&gt; AllTransformationsWithKerAndImg([[1,6],[2,5],[3,4]], [4,5,6]);
  [ Transformation( [ 4, 5, 6, 6, 5, 4 ] ), 
    Transformation( [ 6, 5, 4, 4, 5, 6 ] ), 
    Transformation( [ 6, 4, 5, 5, 4, 6 ] ), 
    Transformation( [ 4, 6, 5, 5, 6, 4 ] ), 
    Transformation( [ 5, 6, 4, 4, 6, 5 ] ), 
    Transformation( [ 5, 4, 6, 6, 4, 5 ] ) ]
</pre></td></tr></table>

<p><a id="X85D1071484CE004C" name="X85D1071484CE004C"></a></p>

<h5>2.1-3 <span class="Heading">Idempotent</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IdempotentNC</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( function )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Idempotent</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><code class="code">IdempotentNC</code> returns an idempotent with kernel <code class="code">ker</code> and image <code class="code">img</code> without checking <code class="func">IsTransversal</code> (<a href="chap2.html#X79E9FFC97AFCEE61"><b>2.2-1</b></a>) with arguments <code class="code">ker</code> and <code class="code">im</code>.</p>

<p><code class="code">Idempotent</code> returns an idempotent with kernel <code class="code">ker</code> and image <code class="code">img</code> after checking that <code class="func">IsTransversal</code> (<a href="chap2.html#X79E9FFC97AFCEE61"><b>2.2-1</b></a>) with arguments <code class="code">ker</code> and <code class="code">im</code> returns <code class="code">true</code>.</p>


<table class="example">
<tr><td><pre>
  gap&gt; g1:=Transformation([2,2,4,4,5,6]);;
  gap&gt; g2:=Transformation([5,3,4,4,6,6]);;
  gap&gt; ker:=KernelOfTransformation(g2*g1);;
  gap&gt; im:=ImageListOfTransformation(g2);;
  gap&gt; Idempotent(ker, im);
  Error,  the image must be a transversal of the kernel
  [ ... ]
  gap&gt; Idempotent([[1,2,3],[4,5],[6,7]], [1,5,6]);
  Transformation( [ 1, 1, 1, 5, 5, 6, 6 ] )
  gap&gt; IdempotentNC([[1,2,3],[4,5],[6,7]], [1,5,6]);
  Transformation( [ 1, 1, 1, 5, 5, 6, 6 ] )
</pre></td></tr></table>

<p><a id="X7C5BED247F770ECB" name="X7C5BED247F770ECB"></a></p>

<h5>2.1-4 <span class="Heading">RandomIdempotent</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RandomIdempotent</code>( <var class="Arg">arg</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RandomIdempotentNC</code>( <var class="Arg">arg</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>If the argument is a kernel, then a random idempotent is return that has that kernel. A <em>kernel</em> is a set of sets that partition the set <code class="code">1,...n</code> for some <code class="code">n</code> and an <em>image</em> is a sublist of <code class="code">1,...n</code>.</p>

<p>If the first argument is an image <code class="code">img</code> and the second a positive integer <code class="code">n</code>, then a random idempotent of degree <code class="code">n</code> is returned with image <code class="code">img</code>.</p>

<p>The no check version does not check that the arguments can be the kernel and image of an idempotent.</p>


<table class="example">
<tr><td><pre>
  gap&gt; RandomIdempotent([[1,2,3], [4,5], [6,7,8]], [1,2,3]);;
  fail
  gap&gt; RandomIdempotent([1,2,3],5);
  Transformation( [ 1, 2, 3, 1, 3 ] )
  gap&gt; RandomIdempotent([[1,6], [2,4], [3,5]]);
  Transformation( [ 1, 2, 5, 2, 5, 1 ] )
</pre></td></tr></table>

<p><a id="X8475448F87E8CB8A" name="X8475448F87E8CB8A"></a></p>

<h5>2.1-5 <span class="Heading">RandomTransformation</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RandomTransformation</code>( <var class="Arg">arg</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; RandomTransformationNC</code>( <var class="Arg">arg</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>These are new methods for the existing library function <code class="func">RandomTransformation</code>.</p>

<p>If the first argument is a kernel and the second an image, then a random transformation is returned with this kernel and image.A <em>kernel</em> is a set of sets that partition the set <code class="code">1,...n</code> for some <code class="code">n</code> and an <em>image</em> is a sublist of <code class="code">1,...n</code>.</p>

<p>If the argument is a kernel, then a random transformation is returned that has that kernel.</p>

<p>If the first argument is an image <code class="code">img</code> and the second a positive integer <code class="code">n</code>, then a random transformation of degree <code class="code">n</code> is returned with image <code class="code">img</code>.</p>

<p>The no check version does not check that the arguments can be the kernel and image of a transformation.</p>


<table class="example">
<tr><td><pre>
  gap&gt; RandomTransformation([[1,2,3], [4,5], [6,7,8]], [1,2,3]);;
  Transformation( [ 2, 2, 2, 1, 1, 3, 3, 3 ] )
  gap&gt; RandomTransformation([[1,2,3],[5,7],[4,6]]); 
  Transformation( [ 3, 3, 3, 6, 1, 6, 1 ] )
  gap&gt; RandomTransformation([[1,2,3],[5,7],[4,6]]);
  Transformation( [ 4, 4, 4, 7, 3, 7, 3 ] )
  gap&gt; RandomTransformationNC([[1,2,3],[5,7],[4,6]]);
  Transformation( [ 1, 1, 1, 7, 5, 7, 5 ] )
  gap&gt; RandomTransformation([1,2,3], 6);             
  Transformation( [ 2, 1, 2, 1, 1, 2 ] )
  gap&gt; RandomTransformationNC([1,2,3], 6);
  Transformation( [ 3, 1, 2, 2, 1, 2 ] )
</pre></td></tr></table>

<p><a id="X814B3E6E7D3F1036" name="X814B3E6E7D3F1036"></a></p>

<h5>2.1-6 TransformationActionNC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; TransformationActionNC</code>( <var class="Arg">list, act, elm</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>returns the list <code class="code">list</code> acted on by <code class="code">elm</code> via the action <code class="code">act</code>.</p>


<table class="example">
<tr><td><pre>
  gap&gt; mat:=OneMutable(GeneratorsOfGroup(GL(3,3))[1]);
  [ [ Z(3)^0, 0*Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0, 0*Z(3) ], 
    [ 0*Z(3), 0*Z(3), Z(3)^0 ] ]
  gap&gt; mat[3][3]:=Z(3)*0; 
  0*Z(3)
  gap&gt; F:=BaseDomain(mat);
  GF(3)
  gap&gt; TransformationActionNC(Elements(F^3), OnRight, mat);
  Transformation( [ 1, 1, 1, 4, 4, 4, 7, 7, 7, 10, 10, 10, 13, 13, 13, 16, 16, 
    16, 19, 19, 19, 22, 22, 22, 25, 25, 25 ] )
</pre></td></tr></table>

<p><a id="X84DD0B3981E5735B" name="X84DD0B3981E5735B"></a></p>

<h4>2.2 <span class="Heading">Properties &amp; Attributes</span></h4>

<p><a id="X79E9FFC97AFCEE61" name="X79E9FFC97AFCEE61"></a></p>

<h5>2.2-1 IsTransversal</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsTransversal</code>( <var class="Arg">list1, list2</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>returns <code class="code">true</code> if the list <code class="code">list2</code> is a transversal of the list of lists <code class="code">list1</code>. That is, if every list in <code class="code">list1</code> contains exactly one element in <code class="code">list2</code>.</p>


<table class="example">
<tr><td><pre>
  gap&gt; g1:=Transformation([2,2,4,4,5,6]);;
  gap&gt; g2:=Transformation([5,3,4,4,6,6]);;
  gap&gt; ker:=KernelOfTransformation(g2*g1);
  [ [ 1 ], [ 2, 3, 4 ], [ 5, 6 ] ] 
  gap&gt; im:=ImageListOfTransformation(g2);
  [ 5, 3, 4, 4, 6, 6 ]
  gap&gt; IsTransversal(ker, im);
  false
  gap&gt; IsTransversal([[1,2,3],[4,5],[6,7]], [1,5,6]);
  true
  </pre></td></tr></table>

<p><a id="X79A3FCED7E8A8B1B" name="X79A3FCED7E8A8B1B"></a></p>

<h5>2.2-2 IsKerImgOfTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsKerImgOfTransformation</code>( <var class="Arg">ker, img</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>returns <code class="code">true</code> if the arguments <code class="code">ker</code> and <code class="code">img</code> can be the kernel and image of a single transformation, respectively. The argument <code class="code">ker</code> should be a set of sets that partition the set <code class="code">1,...n</code> for some <code class="code">n</code> and <code class="code">img</code> should be a sublist of <code class="code">1,...n</code>.</p>


<table class="example">
<tr><td><pre>
  gap&gt; ker:=[[1,2,3],[5,6],[8]];
  [ [ 1, 2, 3 ], [ 5, 6 ], [ 8 ] ]
  gap&gt; img:=[1,2,9];
  [ 1, 2, 9 ]
  gap&gt; IsKerImgOfTransformation(ker,img);
  false
  gap&gt; ker:=[[1,2,3,4],[5,6,7],[8]];
  [ [ 1, 2, 3, 4 ], [ 5, 6, 7 ], [ 8 ] ]
  gap&gt; IsKerImgOfTransformation(ker,img);
  false
  gap&gt; img:=[1,2,8];
  [ 1, 2, 8 ]
  gap&gt; IsKerImgOfTransformation(ker,img);
  true
</pre></td></tr></table>

<p><a id="X7E72E6117BFFC74E" name="X7E72E6117BFFC74E"></a></p>

<h5>2.2-3 KerImgOfTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; KerImgOfTransformation</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>returns the kernel and image set of the transformation <code class="code">f</code>. These attributes of <code class="code">f</code> can be obtain separately using <code class="func">KernelOfTransformation</code> (<a href="/Users/jdm/Desktop/gap4r4/doc/htm/ref/CHAP052.htm"><b>Reference: KernelOfTransformation</b></a>) and <code class="func">ImageSetOfTransformation</code> (<a href="/Users/jdm/Desktop/gap4r4/doc/htm/ref/CHAP052.htm"><b>Reference: ImageSetOfTransformation</b></a>), respectively.</p>


<table class="example">
<tr><td><pre>
  gap&gt; t:=Transformation( [ 10, 8, 7, 2, 8, 2, 2, 6, 4, 1 ] );;
  gap&gt; KerImgOfTransformation(t);
  [ [ [ 1 ], [ 2, 5 ], [ 3 ], [ 4, 6, 7 ], [ 8 ], [ 9 ], [ 10 ] ], 
    [ 1, 2, 4, 6, 7, 8, 10 ] ]
</pre></td></tr></table>

<p><a id="X7856A73E80DAF56F" name="X7856A73E80DAF56F"></a></p>

<h5>2.2-4 IsRegularTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsRegularTransformation</code>( <var class="Arg">S, f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>if <code class="code">f</code> is a regular element of the transformation semigroup <code class="code">S</code>, then <code class="code">true</code> is returned. Otherwise <code class="code">false</code> is returned.</p>

<p>A transformation <code class="code">f</code> is regular inside a transformation semigroup <code class="code">S</code> if it lies inside a regular D-class. This is equivalent to the orbit of the image of <code class="code">f</code> containing a transversal of the kernel of <code class="code">f</code>.</p>


<table class="example">
<tr><td><pre>
gap&gt; g1:=Transformation([2,2,4,4,5,6]);;
gap&gt; g2:=Transformation([5,3,4,4,6,6]);;
gap&gt; m1:=Monoid(g1,g2);;
gap&gt; IsRegularTransformation(m1, g1);
true
gap&gt; img:=ImageSetOfTransformation(g1);
[ 2, 4, 5, 6 ]
gap&gt; ker:=KernelOfTransformation(g1);
[ [ 1, 2 ], [ 3, 4 ], [ 5 ], [ 6 ] ]
gap&gt; ForAny(MonoidOrbit(m1, img), x-&gt; IsTransversal(ker, x));
true
gap&gt; IsRegularTransformation(m1, g2);
false
gap&gt; IsRegularTransformation(FullTransformationSemigroup(6), g2);
true
	</pre></td></tr></table>

<p><a id="X863216CB7AF88BED" name="X863216CB7AF88BED"></a></p>

<h5>2.2-5 IndexPeriodOfTransformation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IndexPeriodOfTransformation</code>( <var class="Arg">f</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>returns the minimum numbers <code class="code">m, r</code> such that <code class="code">f^(m+r)=f^m</code>; known as the <em>index</em> and <em>period</em> of the transformation.</p>


<table class="example">
<tr><td><pre>
  gap&gt; f:=Transformation( [ 3, 4, 4, 6, 1, 3, 3, 7, 1 ] );;
  gap&gt; IndexPeriodOfTransformation(f);
  [ 2, 3 ]
  gap&gt; f^2=f^5;
  true
</pre></td></tr></table>

<p><a id="X84E1A41F84B70DBB" name="X84E1A41F84B70DBB"></a></p>

<h5>2.2-6 SmallestIdempotentPower</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; SmallestIdempotentPower</code>( <var class="Arg">f</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>returns the least natural number <code class="code">n</code> such that the transformation <code class="code">f^n</code> is an idempotent.</p>


<table class="example">
<tr><td><pre>
  gap&gt; t:=Transformation( [ 6, 7, 4, 1, 7, 4, 6, 1, 3, 4 ] );;
  gap&gt; SmallestIdempotentPower(t);
  6
  gap&gt; t:=Transformation( [ 6, 6, 6, 2, 7, 1, 5, 3, 10, 6 ] );;
  gap&gt; SmallestIdempotentPower(t);
  4
</pre></td></tr></table>

<p><a id="X846B9EBB86A69BDC" name="X846B9EBB86A69BDC"></a></p>

<h5>2.2-7 <span class="Heading">InversesOfTransformation</span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InversesOfTransformation</code>( <var class="Arg">S, f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InversesOfTransformationNC</code>( <var class="Arg">S, f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>returns a list of the inverses of the transformation <code class="code">f</code> in the transformation semigroup <code class="code">S</code>. The function <code class="code">InversesOfTransformationNC</code> does not check that <code class="code">f</code> is an element of <code class="code">S</code>.</p>


<table class="example">
<tr><td><pre>
  gap&gt; S:=Semigroup([ Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] ), 
    Transformation( [ 5, 7, 8, 8, 7, 5, 9, 1, 9 ] ), 
    Transformation( [ 7, 6, 2, 8, 4, 7, 5, 8, 3 ] ) ]);;
  gap&gt; f:=Transformation( [ 3, 1, 4, 2, 5, 2, 1, 6, 1 ] );;
  gap&gt; InversesOfTransformationNC(S, f);
  [  ]
  gap&gt; IsRegularTransformation(S, f);
  false
  gap&gt; f:=Transformation( [ 1, 9, 7, 5, 5, 1, 9, 5, 1 ] );;
  gap&gt; inv:=InversesOfTransformation(S, f);
  [ Transformation( [ 1, 5, 1, 1, 5, 1, 3, 1, 2 ] ), 
    Transformation( [ 1, 5, 1, 2, 5, 1, 3, 2, 2 ] ), 
    Transformation( [ 1, 2, 3, 5, 5, 1, 3, 5, 2 ] ) ]
  gap&gt; IsRegularTransformation(S, f);
  true
</pre></td></tr></table>

<p><a id="X80B8EF3D78E711BB" name="X80B8EF3D78E711BB"></a></p>

<h4>2.3 <span class="Heading">Changing Representation</span></h4>

<p><a id="X7F867C337B18D84E" name="X7F867C337B18D84E"></a></p>

<h5>2.3-1 AsBooleanMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AsBooleanMatrix</code>( <var class="Arg">f[, n]</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>returns the transformation or permutation <code class="code">f</code> represented as an <code class="code">n</code> by <code class="code">n</code> Boolean matrix where <code class="code">i,f(i)</code>th entries equal <code class="code">1</code> and all other entries are <code class="code">0</code>.</p>

<p>If <code class="code">f</code> is a transformation, then <code class="code">n</code> is the size of the domain of <code class="code">f</code>.</p>

<p>If <code class="code">f</code> is a permutation, then <code class="code">n</code> is the number of points moved by <code class="code">f</code>.</p>


<table class="example">
<tr><td><pre>
  gap&gt; t:=Transformation( [ 4, 2, 2, 1 ] );;
  gap&gt; AsBooleanMatrix(t);
  [ [ 0, 0, 0, 1 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ] ]
  gap&gt; t:=(1,4,5);;
  gap&gt; AsBooleanMatrix(t);
  [ [ 0, 0, 0, 1, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1 ],
    [ 1, 0, 0, 0, 0 ] ]
  gap&gt; AsBooleanMatrix(t,3);
  fail
  gap&gt; AsBooleanMatrix(t,5);
  [ [ 0, 0, 0, 1, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1 ],
    [ 1, 0, 0, 0, 0 ] ]
  gap&gt; AsBooleanMatrix(t,6);
  [ [ 0, 0, 0, 1, 0, 0 ], [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 1, 0, 0, 0 ], 
    [ 0, 0, 0, 0, 1, 0 ], [ 1, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1 ] ]
</pre></td></tr></table>

<p><a id="X7A249D7781F31C22" name="X7A249D7781F31C22"></a></p>

<h5>2.3-2 AsPermOfRange</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; AsPermOfRange</code>( <var class="Arg">x</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>converts a transformation <code class="code">x</code> that is a permutation of its image into that permutation.</p>


<table class="example">
<tr><td><pre>
  gap&gt; t:=Transformation([1,2,9,9,9,8,8,8,4]);
  Transformation( [ 1, 2, 9, 9, 9, 8, 8, 8, 4 ] )
  gap&gt; AsPermOfRange(t);
  (4,9)
  gap&gt; t*last;
  Transformation( [ 1, 2, 4, 4, 4, 8, 8, 8, 9 ] )
  gap&gt; AsPermOfRange(last);
  ()
</pre></td></tr></table>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">Top of Book</a>&nbsp;  &nbsp;<a href="chap1.html">Previous Chapter</a>&nbsp;  &nbsp;<a href="chap3.html">Next Chapter</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
