
<#GAPDoc Label="AddToOrbitsOfImages">
<ManSection><Func Name="AddToOrbitsOfImages" Arg="s, f, d, o"/>
  <Description>
  The arguments should be: <A>s</A> a semigroup or D-class, <A>f</A> a 
  transformation, <A>o</A> the attribute <Ref Attr="OrbitsOfImages"/>
  of <A>s</A>, and <A>d=[j, k, l, m, val, n, g]</A> where:
  <List>
    <Item> <A>j</A> - is the size of the image set of <A>f</A>;
    </Item>
        
    <Item> <A>k</A> - is the index of the orbit containing the image of 
    <A>f</A>, that is, <C>ImageSetOfTransformation(f)</C> is in
     <C>OrbitsOfImages(s)!.orbits[j][k]</C>;
    </Item>
        
    <Item><A>l</A> - is the position of the image of <A>f</A> in 
    <C>OrbitsOfImages(s)!.orbits[j][k]</C>;</Item>

    <Item> <A>m</A> - is the index of the strongly connected component of 
    <C>OrbitsOfImages(s)!.orbits[j][k]</C> containing the image of 
    <A>f</A>;
    </Item>
        
    <Item> <A>val</A> - is the return value of 
    <Log>
      HTValue(OrbitsOfImages(s)!.orbits[j][k]!.kernels_ht[m],
       KernelOfTransformation(f)),
    </Log> 
    that is, the index of the list of representatives of R-classes of 
    <A>s</A> with the same Schutzenberger group, strong orbit of images, 
    and kernel as <A>f</A>; 
    </Item>
    
    <Item> <A>n</A> - the length of the list 
    <C>OrbitsOfImages(s)!.orbits[j][k]!.reps[m][val]</C> of 
    representatives of R-classes of <A>s</A> with the same Schutzenberger
    group, strong orbit of images, and kernel as <A>f</A>;
    </Item>

    <Item> <A>g</A> - the transformation 
    <C>f*OrbitsOfImages(s)!.orbits[j][k]!.perms[l]</C>, which is
    R-related to <A>f</A> and has the property that the image <C>X</C> of 
    <A>g</A> satisfies 
    <Log>
      Position(OrbitsOfImages(s)!.orbits[j][k], X)=
      OrbitsOfImages(s)!.orbits[j][k]!.scc[m][1].
    </Log>
    </Item>
  </List>
  
  The result of this function is to add all the information relating to 
  the R-class of <A>f</A> in <A>s</A> to the attribute 
  <Ref Attr="OrbitsOfImages"/> of <A>s</A>. <P/>

  See also <Ref Func="PreInOrbitsOfImages"/> and 
  <Ref Func="InOrbitsOfImages"/>. 
  
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CreateRClass">
  <ManSection><Func Name="CreateRClass" Arg="s, d, o, f"/>
  <Description>
  creates an R-class <C>r</C> object using <Ref Func="RClassType"/> of 
  <A>s</A> where the components used by <Package>monoid</Package> are: 
  <List>
    <Item> <C>r!.parent=s</C> the semigroup</Item> 
    
    <Item> <C>r!.data=d</C> the tuple [j, k, l, m, val, n] described in 
    <Ref Func="AddToOrbitsOfImage"/></Item>
    
    <Item><C>r!.orbit=o</C> which is either 
    <Ref Attr="OrbitsOfImages"/> of <A>s</A> if <C>r</C> was created by 
    <Ref Oper= "GreensRClassOfElement"/> or a local version of 
    <Ref Attr="OrbitsOfImages"/> stored in <C>r</C> if it was created with 
    <Ref Oper= "GreensRClassOfElementNC"/></Item>
    
    <Item><C>r!.rep=f</C> is the representative of the R-class.</Item>
  </List>

  Note that <C>ParentAttr</C> of the <C>r</C> is not set as this 
  seems to take some time.

  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user -->

<#GAPDoc Label="CreateSchreierTreeOfSCC">
  <ManSection><Func Name="CreateSchreierTreeOfSCC" Arg="o,i"/>
  <Description>
  if <A>o</A> is an <Package>orb</Package> orbit object created 
  by <Ref Func="ForwardOrbitOfImage"/> or 
  <Ref Func="ForwardOrbitOfKernel"/> and <A>i</A> is the index
  of one of the strongly connected components of <A>o</A>, then 
  <C>CreateSchreierTreeOfSCC</C> returns a list <C>[gen, pos]</C> 
  such that:
  
  <Log>
    OnSets(o[pos[j]], o!.gens[gen[j]])=o[j];
    OnKernelsAntiAction(o[pos[j]], o!.gens[gen[j]])=o[j];
  </Log>

  So, the generator whose index appears in <C>gen[j]</C> maps
  the <C>pos[j]</C>th element of <A>o</A> to <A>o[j]</A>.<P/>

  See also <Ref Func="TraceSchreierTreeOfSCCForward"/>, 
  <Ref Func="CreateReverseSchreierTreeOfSCC"/>, and
  <Ref Func="TraceSchreierTreeOfSCCBack"/>.
  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user -->

<#GAPDoc Label="CreateReverseSchreierTreeOfSCC">
  <ManSection><Func Name="CreateReverseSchreierTreeOfSCC" Arg="o,i"/>
  <Description>
  if <A>o</A> is an <Package>orb</Package> orbit object created by 
  <Ref Func="ForwardOrbitOfImage"/> or <Ref Func="ForwardOrbitOfKernel"/> 
  and <A>i</A> is the index of one of the strongly connected components of
  <A>o</A>, then <C>CreateReverseSchreierTreeOfSCC</C> returns a list 
  <C>[gen, pos]</C> such that:

  <Log>
    OnSets(o[j], o!.gens[gen[j]])=o[pos[j]];
    OnKernelsAntiAction(o[j], o!.gens[gen[j]])=o[pos[j]];
  </Log>
  
  So, the generator whose index appears in <C>gen[j]</C> maps
  the <C>j</C>th element of <A>o</A> to <A>o[pos[j]]</A>.<P/>

  See also <Ref Func="TraceSchreierTreeOfSCCForward"/>, 
  <Ref Func="CreateSchreierTreeOfSCC"/>, and
  <Ref Func="TraceSchreierTreeOfSCCBack"/>.
  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user --> 

<#GAPDoc Label="DisplayOrbitsOfImages">
  <ManSection><Func Name="DisplayOrbitsOfImages" Arg="s"/>
  <Description>
  returns the information stored in <Ref Func="OrbitsOfImages"/> of 
  the transformation semigroup <A>s</A> in a (more or less) nicely formatted 
  way. See <Ref Func="OrbitsOfImages"/> for more details.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ExpandOrbitsOfImages">
  <ManSection><Func Name="ExpandOrbitsOfImages" Arg="s"/>
  <Description>
  completes the information in <Ref Attr="OrbitsOfImages"/> that is 
  used to calculate the size, membership, and R-classes of <A>s</A>.
  This is equivalent to the following:
  
  <Log>
  gap> iter:=IteratorOfNewRClassRepsData(s);;
  gap> for i in iter do od;
  </Log>
  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user -->

<#GAPDoc Label="ForwardOrbitOfImage">
  <ManSection><Func Name="ForwardOrbitOfImage" Arg="s, f, [imgs[, gens]]"/>
  <Description>
  returns a triple consisting of:
  
  <List>
  <Item>the <Package>orb</Package> orbit object <C>o</C> of the image of 
  <A>f</A> in transformation semigroup <A>s</A>;</Item>
  
  <Item> a flat list of R-class representatives associated with <C>o</C>;
  </Item>
  
  <Item> a set containing the index of the first image set in every 
  strongly connected component of <C>o</C>.</Item>
  </List>
  
  If the optional argument <A>imgs</A> is present, then the option 
  <C>onlygradesdata</C> of <C>o</C> is set to equal the hash table <A>imgs</A>
  and only the sets <C>x</C> where <C>HTValue(imgs, x)=fail</C> are added to
  <C>o</C>. In other words, <A>imgs</A> is a hash table containing some image
  sets, and only those images not in <A>imgs</A> are added to the orbit.<P/> 

  If the optional argument <A>gens</A> (a list of generators of <A>s</A>) is 
  present, then for the sake of efficiency this is used instead of calling 
  <C>Generators(s)</C>. 

  <Example>
  gap> s:=Semigroup([ 
  >  Transformation( [ 12, 10, 8, 5, 1, 5, 12, 12, 8, 2, 6, 2 ] ), 
  >  Transformation( [ 5, 6, 10, 11, 10, 4, 10, 12, 5, 7, 4, 10 ] ), 
  >  Transformation( [ 6, 8, 12, 5, 4, 8, 10, 7, 4, 1, 10, 11 ] ) ]);;
  gap> f:=Transformation( [ 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8 ] );;
  gap> ForwardOrbitOfImage(s, f);
  [ &lt;closed img orbit 40 sets with 2 elts, 1 scc, 1 kernels, 1 reps>, 
  [ Transformation( [ 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8 ] ) ], [ 1 ] ]
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensRClassOfElementNC">
  <ManSection><Oper Name="GreensRClassOfElementNC" Arg="s, f"/>
  <Description>
  creates the R-class of the transformation <A>f</A> in the transformation
  semigroup <A>s</A> without first checking that <A>f</A> is an element of 
  <A>s</A>. More precisely, <C>GreensRClassOfElementNC</C> checks if <A>f</A>
  is in <Ref Attr="OrbitsOfImages"/> of <A>s</A> and if it is or if it is not
  and <C>OrbitsOfImages(s)</C> is finished, then the R-class of <A>f</A> in 
  <A>s</A> is returned. Calling this function does not modify 
  <Ref Attr="OrbitsOfImages"/> of <A>s</A>. <P/>

  It can be quicker to compute to compute the R-class of an element using 
  <C>GreensRClassOfElementNC</C> than using <C>GreensRClassOfElement</C> if it
  is known <E>a priori</E> that <A>f</A> is an element of <A>s</A>. <P/> 

  For example, if 
  <Log>
  f:=Transformation( [ 15, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
  20, 20, 20, 20, 20, 20 ] );
  </Log>
  in the semigroup <A>s</A> of order-preserving mappings on 20 points, then
  <Log>
  GreensRClassOfElementNC(s, f);;
  </Log>
  returns an answer relatively quickly, whereas <C>GreensRClassOfElement</C>
  can take a signficant amount of time and memory to return a value. 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensRClassReps">
  <ManSection><Attr Name="GreensRClassReps" Arg="s"/>
  <Description>
  returns a list of R-class representatives of the transformation semigroup 
  <A>s</A>. The same output can be obtained by calling: 
  <Log>
    List(GreensRClasses(s), Representative);
  </Log>
  Note that if R-classes are not required, then <C>GreensRClassReps</C> is more
  efficient than the above, since the R-class objects are not created.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Idempotents">
  <ManSection><Func Name="Idempotents" Arg="x[,n]"/>
  <Description>
  returns a list of the idempotents in the transformation semigroup or Green's 
  class <A>x</A>. <P/>

  If the optional second argument <A>n</A> is present and <A>x</A> is a
  transformation semigroup, then a list of the 
  idempotents in <A>x</A> of rank <A>n</A> is returned. If you are only 
  interested in the idempotents of a given rank, then the second version of the 
  function will likely be faster. However, if the optional second argument is
  present, then nothing is stored in <A>x</A> and so every time the function
  is called the computation must be repeated. 
  
  <Example>
  gap> s:=Semigroup([ Transformation( [ 2, 3, 4, 1 ] ), 
   > Transformation( [ 3, 3, 1, 1 ] ) ]);;
  gap> Idempotents(s, 1);
  [  ]
  gap> Idempotents(s, 2);                        
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ), 
    Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> Idempotents(s);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 2, 3, 4 ] ), 
    Transformation( [ 1, 3, 3, 1 ] ), Transformation( [ 2, 2, 4, 4 ] ), 
    Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> f:=Transformation( [ 2, 2, 4, 4 ] );;
  gap> r:=RClass(s, f);
  {Transformation( [ 3, 3, 1, 1 ] )}
  gap> Idempotents(r);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 2, 2, 4, 4 ] ) ]
  </Example> 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InOrbitsOfImages">
  <ManSection><Func Name="InOrbitsOfImages" Arg="s, f, d, o, imgs"/>
  <Description>
  The arguments of <C>InOrbitsOfImages</C> should be:
  
  <List>
  
  <Item> <A>s</A> - a transformation semigroup;
  </Item>
  
  <Item> <A>f</A> - a transformation;
  </Item>

  <Item> <A>d</A> - a tuple <C>[j, k, l, m, val, g]</C> as described in 
  <Ref Func="AddToOrbitsOfImages"/>. Of course, if every element in <A>d</A> is 
  not <C>fail</C>, then you already know that <A>f</A> is in <A>s</A>;
  </Item>

  <Item> <A>o</A><C>=OrbitsOfImages(s)!.orbits</C> the orbits of images of
  <A>s</A>;
  </Item>

  <Item> <A>imgs</A><C>=OrbitsOfImages(s)!.images</C> the hash table containing 
  the list of images of elements of <A>s</A> so far computed. 
  </Item>

  </List>
  
  <C>InOrbitsOfImages</C> returns the tuple 
  <C>[true/false, [j, k, l, m, val, n, g]</C> where 
  the first component indicates if the transformation <A>f</A> is in <Ref
  Attr="OrbitsOfImages"/> of <A>s</A>, and the second component is as described
  in <Ref Func="AddToOrbitsOfImages"/>. The output entries in the tuple 
  <C>[j, k, l, m, val, n, g]</C> are an updated version of the argument
  <A>d</A>. <P/>

  To check that <A>f</A> is in <Ref Attr="OrbitsOfImages"/> of 
  <A>s</A> use <Ref Func="PreInOrbitsOfImages"/> to avoid the complicated input
  required by <C>InOrbitsOfImages</C>. Note that the input to
  <C>InOrbitsOfImages</C> is complicated to avoid repeatedly having to find
  access the components of <C>OrbitsOfImages</C>, which could slow things down
  when using <Ref Func="IteratorOfRClassRepsData"/> and functions based on it.

  <Example>
  gap> s:=Monoid(Transformation( [ 8, 7, 5, 3, 1, 3, 8, 8 ] ),
  > Transformation( [ 5, 1, 4, 1, 4, 4, 7, 8 ] ));;
  gap> f:=Transformation( [ 8, 8, 1, 5, 8, 5, 8, 8 ] );;
  gap> PreInOrbitsOfImages(s, f);
  [ false, [ 3, fail, fail, fail, fail, 0, fail ] ]
  gap> iter:=IteratorOfGreensRClasses(s);
  &lt;iterator of R-classes>
  gap> NextIterator(iter);; NextIterator(iter);;
  gap> PreInOrbitsOfImages(s, f);
  [ false, [ 3, fail, fail, fail, fail, 0, fail ] ]
  gap> NextIterator(iter);; NextIterator(iter);;
  gap> PreInOrbitsOfImages(s, f);
  [ true, [ 3, 1, 1, 1, 1, 1, Transformation( [ 8, 8, 1, 5, 8, 5, 8, 8 ] ) ] ]
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularRClass">
  <ManSection><Func Name="IsRegularRClass" Arg="r"/>
  <Description>
  return <C>true</C> if the R-class <A>r</A> of a transformation
  semigroup is regular (i.e. it contains an idempotent) and returns 
  <C>false</C> otherwise.

  <Example>
  gap> s:=Monoid(Transformation( [ 10, 8, 7, 4, 1, 4, 10, 10, 7, 2 ] ),
  > Transformation( [ 5, 2, 5, 5, 9, 10, 8, 3, 8, 10 ] ));;
  gap> f:=Transformation( [ 1, 1, 10, 8, 8, 8, 1, 1, 10, 8 ] );;
  gap> r:=RClass(s, f);;
  gap> IsRegularRClass(r);
  true
  gap> h:=HClass(s, f);;
  gap> IsRegularRClass(h);
  gap> f:=Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] );;
  gap> gens:=;;
  gap> s:=Monoid(Transformation([2,3,4,5,1,8,7,6,2,7]), 
  > Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] ));;
  gap> r:=RClass(s, f);;
  gap> IsRegularRClass(r);
  false
  gap> NrIdempotents(r);
  0
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularRClassData">
  <ManSection><Func Name="IsRegularRClassData" Arg="s, d[, o[, f]]"/>
  <Description>
  if <A>s</A> is a transformation semigroup, <A>d</A> is a tuple  
  <A>[j, k, l, m, val, n, g]</A> as described in 
  <Ref Func="AddToOrbitsOfImages"/>, then <C>IsRegularRClassData</C> returns
  <C>true</C> if the R-class created using <Ref Func="CreateRClass"/> with
  arguments <A>s, d, OrbitsOfImages(s), RClassRepFromData(s, d)</A>
  is regular and it returns <C>false</C> otherwise. <P/>

  If the optional third argument <A>o</A> is present, then this is used instead
  of <C>OrbitsOfImages(s)</C> above. <P/>

  If the optional fourth argument <A>f</A> is present, then this is used
  instead of <C>RClassRepFromData(s, d, o)</C> above. <P/>

  Note that it is not necessary to actually create the R-class to perform this
  check, and that if the R-class is not actually required, then using
  <C>IsRegularRClassData</C> will be more efficient. <P/>
  
  See also <Ref Prop="IsRegularRClass"/>. 
  
  </Description>
  </ManSection>
<#/GAPDoc>

