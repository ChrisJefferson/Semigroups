#############################################################################
##
#W  digraph.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="IsDirectedGraph">
<ManSection>
  <Filt Name="IsDirectedGraph" Type='Category'/>
  <Description>
    Every  directed graph in  &Semigroups;  belongs  to  the  category <C>IsDirectedGraph</C>.
    Basic attributes and operations for directed graphs are: <Ref Oper="Vertices"/>, 
    <Ref Attr="Range"/>, <Ref Attr="Source"/>, <Ref Attr="Adjacencies"/>, and <Ref Attr="Edges"/>. 
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraph">
<ManSection>
  <Oper Name="DirectedGraph" Arg="obj[, func]"/>
  <Returns>A directed graph.</Returns>
  <Description>
    <List>
      
      <Mark>for a record</Mark>
      <Item> 
        if <A>obj</A> is a record with components <C>vertices</C>,
        <C>source</C>, and <C>range</C>, then this function returns the directed
        graph with vertices <M>E^0=</M><C>[1..Length(<A>obj</A>.vertices)]</C>,
        edges indexed by <C>[1..Length(<A>obj</A>.source)]</C>, range and source
        function defined by <C><A>obj</A>.range</C> and
        <C><A>obj</A>.source</C>.  The components <C><A>obj</A>.range</C> and
        <C><A>obj</A>.source</C> must be lists of equal length consisting of
        elements of the list <C><A>obj</A>.vertices</C>.  
      </Item>
      
      <Mark>for a list</Mark> 
      <Item>
        if <A>obj</A> is a list of duplicate free lists of positive integers in
        the range from <C>1</C> to <C>Length(<A>obj</A>)</C>, then this function
        returns the directed graph with vertices
        <M>E^0=</M><C>[1..Length(<A>obj</A>)]</C>, and edges corresponding to
        the entries of <A>obj</A>. More precisely, there is an edge from vertex
        <C>i</C> to <C>j</C> if <C>j</C> is in <C><A>obj</A>[i]</C>; the source of this
        edge is <C>i</C> and the range is <C>j</C>.
      </Item>

      <Mark>for a list and a function</Mark>
      <Item>
        if <A>obj</A> is a list of &GAP; objects, and the optional second
        argument <A>func</A> is a function whose argument is a record, and which
        outputs a record defining a directed graph (as described above) with
        vertices equal to <A>obj</A>, then this function returns the latter.
      </Item>
      
      <Mark>for a Grape package graph</Mark>
      <Item>
        if <A>obj</A> is a &Grape; package graph (i.e. a record for which the
        function <C>IsGraph</C> returns <K>true</K>), then this function returns
        a directed graph isomorphic to <A>obj</A>.
      </Item>

    </List>
  
    <Example><![CDATA[
gap> gr:=DirectedGraph(rec(vertices:=["a", "b", "c"],
> source:=["a"], range:=["b"]));
<directed graph with 3 vertices, 1 edges>
gap> gr:=DirectedGraph(rec(vertices:=[1,2,3,4,5], 
> source:=[1,2,2,4,4,1,1], range:=[2,3,5,3,5,1,1]));
<directed graph with 5 vertices, 7 edges>
gap> gr:= DirectedGraph( [ [ 2, 5, 8, 10 ], [ 2, 3, 4, 5, 6, 8, 9, 10 ], 
> [ 1 ], [ 3, 5, 7, 8, 10 ], [ 2, 5, 7 ], [ 3, 6, 7, 9, 10 ], [ 1, 4 ], 
> [ 1, 5, 9 ], [ 1, 2, 7, 8 ], [ 3, 5 ] ] );
<directed graph with 10 vertices, 37 edges>
gap> cycle:=function(record)
>  local i;
>  for i in [0..Length(record.vertices)-1] do 
>    Add(record.source, i mod Length(record.vertices) + 1);
>    Add(record.range, (i + 1) mod Length(record.vertices) +1);
>  od;
>  return record;
> end;;
gap> DirectedGraph([1..10000], cycle);
<directed graph with 10000 vertices, 10000 edges>
gap> Petersen := Graph( SymmetricGroup(5), [[1,2]], OnSets,
> function(x,y) return Intersection(x,y)=[]; end );;
gap> DirectedGraph(Petersen);
<directed graph with 10 vertices, 30 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="GrapeGraph">
<ManSection>
  <Oper Name="Graph" Arg="digraph"/>
  <Returns>A <Package>Grape</Package> package graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this method returns a &Grape;
    package graph, that is isomorphic to <A>digraph</A>.
    
    <Example><![CDATA[
gap> Petersen := Graph( SymmetricGroup(5), [[1,2]], OnSets,
> function(x,y) return Intersection(x,y)=[]; end );
rec( adjacencies := [ [ 3, 5, 8 ] ], group := Group([ (1,2,3,5,7)
  (4,6,8,9,10), (2,4)(6,9)(7,10) ]), isGraph := true, 
  names := [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 3 ], [ 4, 5 ], 
      [ 2, 4 ], [ 1, 5 ], [ 3, 5 ], [ 1, 4 ], [ 2, 5 ] ], 
  order := 10, representatives := [ 1 ], 
  schreierVector := [ -1, 1, 1, 2, 1, 1, 1, 1, 2, 2 ] )
gap> DirectedGraph(Petersen);
<directed graph with 10 vertices, 30 edges>
gap> Graph(last);
rec( 
  adjacencies := [ [ 3, 5, 8 ], [ 5, 7, 9 ], [ 1, 7, 10 ], 
      [ 5, 6, 10 ], [ 1, 2, 4 ], [ 4, 7, 8 ], [ 2, 3, 6 ], 
      [ 1, 6, 9 ], [ 2, 8, 10 ], [ 3, 4, 9 ] ], group := Group(()), 
  isGraph := true, names := [ 1 .. 10 ], order := 10, 
  representatives := [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ], 
  schreierVector := [ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10 ] )
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomSimpleDirectedGraph">
<ManSection>
  <Oper Name="RandomSimpleDirectedGraph" Arg="n"/>
  <Returns>A directed graph.</Returns>
  <Description>
    Returns a random simple directed graph with <A>n</A> vertices.
    <Log><![CDATA[
gap> RandomSimpleDirectedGraph(1000);
<directed graph with 1000 vertices, 364444 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Vertices">
<ManSection>
  <Oper Name="Vertices" Arg="digraph"/>
  <Returns>The vertices of a directed graph.</Returns>
  <Description>
    Returns the vertices of the directed graph <A>digraph</A>. <P/>

    <B>Note that:</B> the vertices of a directed graph are always a range of
    positive integers from <C>1</C> to the number of vertices of the graph. 
    <Example><![CDATA[
gap> gr:=DirectedGraph(rec(vertices:=["a", "b", "c"],
> source:=["a", "b", "b"], range:=["b", "c", "a"]));
<directed graph with 3 vertices, 3 edges>
gap> Vertices(gr);
[ 1 .. 3 ]
gap> gr:=DirectedGraph(rec(vertices:=[1,2,3,4,5,7],
> source:=[1,2,2,4,4], range:=[2,3,5,3,5]));
<directed graph with 6 vertices, 5 edges>
gap> Vertices(gr);
[ 1 .. 6 ]
gap> Vertices(RandomSimpleDirectedGraph(100));
[ 1 .. 100 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Edges">
<ManSection>
  <Attr Name="Edges" Arg="digraph"/>
  <Returns>The edges of a directed graph.</Returns>
  <Description>
    Returns the set of edges of the directed graph <A>digraph</A>, that is, a set of
    pairs of elements of <Ref Oper="Vertices"/>.
    <Example><![CDATA[
gap> gr:= DirectedGraph( [ [ 1, 3, 4, 5 ], [ 1, 2, 3, 5 ], [ 2, 4, 5 ], 
> [ 2, 4, 5 ], [ 1 ] ] );
<directed graph with 5 vertices, 15 edges>
gap> Edges(gr);
[ [ 1, 1 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 1 ], [ 2, 2 ], 
  [ 2, 3 ], [ 2, 5 ], [ 3, 2 ], [ 3, 4 ], [ 3, 5 ], [ 4, 2 ], 
  [ 4, 4 ], [ 4, 5 ], [ 5, 1 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RangeSourceDigraph">
<ManSection>
  <Attr Name="Range" Arg="digraph"/>
  <Attr Name="Source" Arg="digraph"/>
  <Returns>A list of positive integers.</Returns>
  <Description>
    <C>Range</C> and <C>Source</C> return the range and source of the directed
    graph <A>digraph</A>. More precisely, position <C>i</C> in
    <C>Range(<A>digraph</A>)</C> is the range of the <C>i</C>th edge of
    <A>digraph</A>. 

    <Example><![CDATA[
gap> gr:=DirectedGraph( [ [ 1, 2, 3, 5 ], [ 1, 3, 4 ], [ 2, 3 ], 
> [ 2 ], [ 1, 2, 3, 4 ] ] );
<directed graph with 5 vertices, 14 edges>
gap> Range(gr);
[ 1, 2, 3, 5, 1, 3, 4, 2, 3, 2, 1, 2, 3, 4 ]
gap> Source(gr);
[ 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5 ]
gap> Edges(gr);
[ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 5 ], [ 2, 1 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 5, 1 ], [ 5, 2 ], 
  [ 5, 3 ], [ 5, 4 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Adjacencies">
<ManSection>
  <Attr Name="Adjacencies" Arg="digraph"/>
  <Returns>The adjacencies of a directed graph.</Returns>
  <Description>
    Returns the list <C>adj</C> of adjacencies of the directed graph
    <A>digraph</A>. More specifically, <C>j</C> belongs to <C>adj[i]</C>
    whenever there is an edge from <C>i</C> to <C>j</C> in <A>digraph</A>. <P/>

    A <A>digraph</A> is a simple directed graph if and only if it is defined by
    its adjacencies. 

    <Example><![CDATA[
gap> gr:=DirectedGraph(rec(vertices:=["a", "b", "c"],
> source:=["a", "b", "b"], range:=["b", "c", "a"]));
<directed graph with 3 vertices, 3 edges>
gap> Adjacencies(gr);
[ [ 2 ], [ 1, 3 ], [  ] ]
gap> gr:=DirectedGraph(rec(vertices:=[1..3], 
> source:=[1,2,3,1,1,2], range:=[1,2,3,2,3,1]));
<directed graph with 3 vertices, 6 edges>
gap> Adjacencies(gr);
[ [ 1, 2, 3 ], [ 1, 2 ], [ 3 ] ]
gap> gr:=DirectedGraph(rec(vertices:=[1..3],
> source:=[1,2,3,1,1,2,1], range:=[1,2,3,2,3,1,2]));
<directed graph with 3 vertices, 7 edges>
gap> Adjacencies(gr);
[ [ 1, 2, 3 ], [ 1, 2 ], [ 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsSimpleDirectedGraph">
<ManSection>
  <Prop Name="IsSimpleDirectedGraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A <E>simple directed graph</E> is one that it does not have multiple 
    edges with equal source and range. In other words, is defined by its
    adjacencies <Ref Attr="Adjacencies"/>. A <E>simple directed graph</E>
    may have loops. 
 
    <Example><![CDATA[
gap> gr:=DirectedGraph(rec(vertices:=["a", "b", "c"],
> source:=["a", "b", "b"], range:=["b", "c", "a"]));
<directed graph with 3 vertices, 3 edges>
gap> IsSimpleDirectedGraph(gr);
true
gap> gr:=DirectedGraph(rec(vertices:=[1..3], 
> source:=[1,2,3,1,1,2], range:=[1,2,3,2,3,1]));
<directed graph with 3 vertices, 6 edges>
gap> IsSimpleDirectedGraph(gr);
true
gap> gr:=DirectedGraph(rec(vertices:=[1..3],
> source:=[1,2,3,1,1,2,1], range:=[1,2,3,2,3,1,2]));
<directed graph with 3 vertices, 7 edges>
gap> IsSimpleDirectedGraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsStronglyConnectedDirectedGraph">
<ManSection>
  <Prop Name="IsStronglyConnectedDirectedGraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    This function returns <K>true</K> if the directed graph <A>digraph</A> is
    strongly connected and <K>false</K> if it is not.  A digraph <A>digraph</A>
    is <E>strongly connected</E> if there is a path from every vertex to every
    other vertex. <P/>

    The method used in this operation is based on Gabow's Algorithm <Cite
      Key="Gabow2000aa"/> and has complexity <M>O(m+n)</M> where <M>m</M> is the
    number of edges (counting multiple edges as one) and <M>n</M> is the number
    of vertices in the directed graph. 
  
    <Example><![CDATA[
gap> cycle:=function(record)
>   local i;
>   for i in [0..Length(record.vertices)-1] do 
>     Add(record.source, i mod Length(record.vertices) + 1);
>     Add(record.range, (i + 1) mod Length(record.vertices) +1);
>   od;
>   return record;
> end;;
gap> gr:=DirectedGraph([1..250000], cycle);
<directed graph with 250000 vertices, 250000 edges>
gap> IsStronglyConnectedDirectedGraph(gr);
true
gap> gr:=DirectedGraphRemoveEdges(gr, [[250000, 1]]);
<directed graph with 250000 vertices, 249999 edges>
gap> IsStronglyConnectedDirectedGraph(gr);
false
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsAcyclicDirectedGraph">
<ManSection>
  <Prop Name="IsAcyclicDirectedGraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    Returns <K>true</K> if the directed graph <A>digraph</A> is acyclic and
    <K>false</K> if it is not. A digraph is <E>acyclic</E> if
    there are no cycles, i.e. paths starting and ending at the same vertex. 

    The method used in this operation has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the directed graph. 

    <Example><![CDATA[
gap> Petersen := Graph( SymmetricGroup(5), [[1,2]], OnSets,           
> function(x,y) return Intersection(x,y)=[]; end );;
gap> gr:=DirectedGraph(Petersen);                    
<directed graph with 10 vertices, 30 edges>
gap> IsAcyclicDirectedGraph(gr);
false
gap> gr:=DirectedGraph( [ [ ], [ 1 ], [ 1 ], [ 1 ], [ 3 ], [ 3 ], 
> [ 4 ], [ 4 ], [ 5 ], [ 5 ], [ 5 ], [ 6 ], [ 6 ], [ 7 ], [ 7 ], 
> [ 7 ], [ 8 ], [ 9 ], [ 9 ], [ 11 ], [ 11 ], [ 12 ], [ 12 ], [ 13 ], 
> [ 14 ], [ 15 ], [ 15 ], [ 16 ], [ 16 ], [ 17 ], [ 17 ], [ 18 ], 
> [ 18 ], [ 19 ], [ 20 ], [ 20 ], [ 21 ], [ 22 ], [ 22 ], [ 23 ], 
> [ 23 ], [ 24 ], [ 28 ], [ 29 ], [ 30 ], [ 30 ], [ 31 ], [ 32 ], 
> [ 32 ], [ 33 ], [ 34 ], [ 41 ], [ 46 ], [ 47 ], [ 51 ] ] );;
gap> IsAcyclicDirectedGraph(gr);
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphRelabel">
<ManSection>
  <Oper Name="DirectedGraphRelabel" Arg="digraph, perm"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, and <A>perm</A> is a permutation of
    the vertices of <A>digraph</A>, then this operation returns a directed graph
    constructed from <A>digraph</A> by relabelling the vertices according to
    <A>perm</A>. 
    <Example><![CDATA[
gap> gr := DirectedGraph( [ [ 3 ], [ 1, 3, 5 ], [ 1 ], [ 1, 2, 4 ], 
> [ 2, 3, 5 ] ] );
<directed graph with 5 vertices, 11 edges>
gap> DirectedGraphRelabel(gr, (1,2));
<directed graph with 5 vertices, 11 edges>
gap> Adjacencies(last);
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 1, 2, 4 ], [ 1, 3, 5 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphRemoveLoops">
<ManSection>
  <Oper Name="DirectedGraphRemoveLoops" Arg="digraph"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph, then this operation returns a directed graph 
    constructed from <A>digraph</A> by removing all of the loops (edges with
    equal source and range).
    <Example><![CDATA[
gap> gr:=DirectedGraph( [ [ 1, 2, 4 ], [ 1, 4 ], [ 3, 4 ], [ 1, 4, 5 ], 
> [ 1, 5 ] ] );
<directed graph with 5 vertices, 12 edges>
gap> DirectedGraphRemoveLoops(gr);                 
<directed graph with 5 vertices, 8 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphRemoveEdges">
<ManSection>
  <Oper Name="DirectedGraphRemoveEdges" Arg="digraph, edges"/>
  <Returns>A directed graph.</Returns>
  <Description>
    If <A>digraph</A> is a directed graph and <A>edges</A> is a list of either:
    pairs of vertices of the simple directed graph <A>digraph</A> or indices of
    edges of <A>digraph</A>, then this operation returns a directed graph
    constructed from <A>digraph</A> by removing all of the edges specified by
    <A>edges</A>.

    <Example><![CDATA[
gap> cycle:=function(record)
>   local i;
>   for i in [0..Length(record.vertices)-1] do 
>     Add(record.source, i mod Length(record.vertices) + 1);
>     Add(record.range, (i + 1) mod Length(record.vertices) +1);
>   od;
>   return record;
> end;;
gap> gr:=DirectedGraph([1..250000], cycle);
<directed graph with 250000 vertices, 250000 edges>
gap> gr:=DirectedGraphRemoveEdges(gr, [[250000, 1]]);
<directed graph with 250000 vertices, 249999 edges>
gap> gr:=DirectedGraphRemoveEdges(gr, [10]);

  ]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphTopologicalSort">
<ManSection>
  <Oper Name="DirectedGraphTopologicalSort" Arg="digraph"/>
  <Returns>A list of positive integers.</Returns>
  <Description>
    If <A>digraph</A> is an acyclic directed graph, then this operation returns
    the vertices of <A>digraph</A> ordered so that every vertex adjacent to
    <C>i</C> occurs before <C>i</C>. <P/>

    The method used in this operation has complexity <M>O(m+n)</M> where
    <M>m</M> is the number of edges (counting multiple edges as one) and
    <M>n</M> is the number of vertices in the directed graph. 
    <Example><![CDATA[
gap> gr:=DirectedGraph([[2,3], [],[4,6], [5], [], [7,8,9], [],[],[]]);
<directed graph with 9 vertices, 8 edges>
gap> DirectedGraphTopologicalSort(gr);
[ 2, 5, 4, 7, 8, 9, 6, 3, 1 ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DirectedGraphReflexiveTransitiveClosure">
<ManSection>
  <Oper Name="DirectedGraphReflexiveTransitiveClosure" Arg="digraph"/>
  <Oper Name="DirectedGraphTransitiveClosure" Arg="digraph"/>
  <Returns>A directed graph.</Returns>
  <Description>
    The first of these functions returns the (reflexive) transitive closure of the simple 
    directed graph <A>digraph</A>. <P/>

    A directed graph is <E>reflexive</E> if there is a loop at every vertex, and
    it is <E>transitive</E> if whenever <C>[ i, j ]</C> and <C>[ j, k ]</C> are
    edges, <C>[ i, k ]</C> is also an edge. The <E>transitive closure</E> of a
    directed graph <A>digraph</A> is the least transitive directed graph
    containing <A>digraph</A>. 

    <Example><![CDATA[
gap> gr:=DirectedGraph( [ [ 4, 6 ], [ 1, 3 ], [ ], [ 5 ], [ ], [ 7, 8, 9 ], 
> [ ], [ ], [ ] ] );;
gap> DirectedGraphTransitiveClosure(gr);
<directed graph with 9 vertices, 18 edges>
gap> Adjacencies(last);
[ [ 4, 5, 6, 7, 8, 9 ], [ 1, 3, 4, 5, 6, 7, 8, 9 ], [  ], [ 5 ], 
  [  ], [ 7, 8, 9 ], [  ], [  ], [  ] ]
gap> DirectedGraphReflexiveTransitiveClosure(gr);  
<directed graph with 9 vertices, 27 edges>
gap> Adjacencies(last);
[ [ 1, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3 ], 
  [ 4, 5 ], [ 5 ], [ 6, 7, 8, 9 ], [ 7 ], [ 8 ], [ 9 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>


