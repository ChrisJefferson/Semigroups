#############################################################################
##
#W  greens.xml
#Y  Copyright (C) 2006-2011                             James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="DClassOfRClass">
  <ManSection>
    <Oper Name="DClassOfRClass" Arg="r"/>
    <Description>
      returns the Green's <Math>\mathcal{D}</Math>-class containing the
      Green's <Math>\mathcal{R}</Math>-class <A>r</A>.  
      Note that if it is not known to &GAP; whether or not the representative 
      of <A>r</A> is an element of the semigroup containing <A>r</A>, then no
      attempt is made to check this. 
      <Example>
        new example here!
      </Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensDClassOfElementNC">
  <ManSection>
    <Oper Name="GreensDClassOfElementNC" Arg="s, f"/>
    <Oper Name="GreensHClassOfElementNC" Arg="s, f"/>
    <Oper Name="GreensLClassOfElementNC" Arg="s, f"/>
    <Oper Name="GreensRClassOfElementNC" Arg="s, f"/>
    <Description>
      creates the <Math>\mathcal{R}</Math>-class, 
      <Math>\mathcal{D}</Math>-class, <Math>\mathcal{L}</Math>-
      class, or <Math>\mathcal{H}</Math>-class of the transformation <A>f</A> 
      in the transformation semigroup <A>s</A> after checking if <A>f</A> has 
      already been shown to be an element of <A>s</A> or not. Note that if it 
      is not known to &GAP; if <A>f</A> is an element of <A>s</A> or not, then 
      no further attempt to verify if <A>f</A> is in <A>s</A> is made. 

      It can be quicker to compute to compute the class of an element using 
      <C>GreensRClassOfElementNC</C>, say, than using 
      <Ref Oper="GreensRClassOfElement" BookName="ref"/> 
      if it is known <E>a priori</E> that <A>f</A> 
      is an element of <A>s</A>. On the other
      hand, if <A>f</A> is not an element of <A>s</A>, then the results of this
      computation are unpredictable.<P/> 

      For example, if 
      <Log>
f:=Transformation( [ 15, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
20, 20, 20, 20, 20, 20, 20, 20 ] );
      </Log>
      in the semigroup <A>s</A> of order-preserving mappings on 20 points, then
      <Log>
GreensRClassOfElementNC(s, f);;
      </Log>
      returns an answer relatively quickly, whereas 
      <Ref Oper="GreensRClassOfElement" BookName="ref"/>
      can take a signficant amount of time and memory to return a value. 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensDClassReps">
  <ManSection>
    <Attr Name="GreensDClassReps" Arg="s"/>
    <Description>
      returns a list of representatives of <Math>\mathcal{D}</Math>-classes of
      the transformation semigroup <A>s</A>.<P/>

      The same output can be obtained by calling, for example:
      <Log>
List(GreensDClasses(s), Representative);
      </Log>

      Note that if the <Math>\mathcal{D}</Math>-classes themselves are not 
      required, then 
      <C>GreensDClassReps</C> will return an answer more quickly 
      than the above, since the <Math>\mathcal{D}</Math>-class 
      objects are not created.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensLClassReps">
  <ManSection><Heading>GreensClassReps</Heading>
    <Attr Name="GreensLClassReps" Arg="x"/>
    <Attr Name="GreensRClassReps" Arg="x"/>
    <Description>
      returns a list of representatives of <Math>\mathcal{L}</Math>- or
      <Math>\mathcal{R}</Math>-classes of
      the transformation semigroup <A>s</A> or <Math>\mathcal{D}</Math>-class
      <A>x</A>. 
      <P/>

      The same output can be obtained by calling, for example:
      <Log>
List(GreensLClasses(x), Representative);
List(GreensRClasses(x), Representative);
      </Log>

      Note that if the <Math>\mathcal{L}</Math>- or
      <Math>\mathcal{R}</Math>-classes themselves are not 
      required, then 
      <C>GreensLClassReps</C> or <C>GreensRClassReps</C> will return an answer 
      more quickly 
      than the above, since the <Math>\mathcal{D}</Math>-class 
      objects are not created.
    </Description>
  </ManSection>
<#/GAPDoc>



<#GAPDoc Label="PartialOrderOfDClasses">
  <ManSection>
  <Attr Name="PartialOrderOfDClasses" Arg="s"/>
  <Description>
  returns a list <C>l</C> where <C>j</C> is in <C>l[i]</C> if and only if 
  <C>GreensDClasses(s)[j]</C> is immediately less than 
  <C>GreensDClasses(s)[i]</C> in the partial order of <Math>D</Math>-classes of <A>s</A>.
  The transitive closure of the relation <Math>\{\:(j,i):\:\: j\in
  l[i]\:\}</Math> is the partial order of <Math>D</Math>-classes. <P/>

  The partial order on the <Math>D</Math>-classes is defined by 
  <Math>x\leq y</Math> in if and only if <C>s^1xs^1</C> is a subset of  
  <C>s^1ys^1</C>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrRegularDClasses"> 
  <ManSection><Attr Name="NrRegularDClasses" Arg="s"/> 
    <Description>
    returns the number of regular <Math>D</Math>-classes of the transformation
    semigroup <A>s</A>.
    </Description>
    </ManSection>
<#/GAPDoc>





<#GAPDoc Label="GreensHClasses">
  <ManSection><Attr Name="GreensHClasses" Arg="x"/>
  <Description>
  returns a list of <Math>H</Math>-classes contained in the object 
  <A>x</A> where <A>x</A> is a transformation semigroup, an R-class, an L-class,
  or a D-class. <P/>

  See also <Ref Attr="GreensHClassReps"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensHClassReps">
  <ManSection><Attr Name="GreensHClassReps" Arg="x"/>
  <Description>
  returns a list of representatives of <Math>H</Math>-classes contained in the 
  object <A>x</A> where <A>x</A> is a transformation semigroup, an R-class, an L-
  class, or a D-class. <P/>

  Note that if the H-classes are not required, then <C>GreensHClassReps</C> is more 
  efficient than <C>GreensHClasses</C>, since the H-class objects are not created.<P/>

  See also <Ref Attr="GreensHClasses"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensRClasses">
  <ManSection><Attr Name="GreensRClasses" Arg="x"/>
  <Description>
  returns a list of <Math>R</Math>-classes contained in the object 
  <A>x</A> where <A>x</A> is a transformation semigroup,
  or a D-class. <P/>

  See also <Ref Attr="GreensRClassReps"/> and 
  <Ref Func="IteratorOfGreensRClasses"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Idempotents">
  <ManSection><Attr Name="Idempotents" Arg="x[,n]"/>
  <Description>
  returns a list of the idempotents in the transformation semigroup or Green's 
  class <A>x</A>. <P/>

  If the optional second argument <A>n</A> is present and <A>x</A> is a
  transformation semigroup, then a list of the 
  idempotents in <A>x</A> of rank <A>n</A> is returned. If you are only 
  interested in the idempotents of a given rank, then the second version of the 
  function will likely be faster. However, if the optional second argument is
  present, then nothing is stored in <A>x</A> and so every time the function
  is called the computation must be repeated. 
  
  <Example>
  gap> s:=Semigroup([ Transformation( [ 2, 3, 4, 1 ] ), 
   > Transformation( [ 3, 3, 1, 1 ] ) ]);;
  gap> Idempotents(s, 1);
  [  ]
  gap> Idempotents(s, 2);                        
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ), 
    Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> Idempotents(s);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 2, 3, 4 ] ), 
    Transformation( [ 1, 3, 3, 1 ] ), Transformation( [ 2, 2, 4, 4 ] ), 
    Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> f:=Transformation( [ 2, 2, 4, 4 ] );;
  gap> r:=RClass(s, f);
  {Transformation( [ 3, 3, 1, 1 ] )}
  gap> Idempotents(r);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 2, 2, 4, 4 ] ) ]
  </Example> 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularRClass">
  <ManSection><Attr Name="IsRegularRClass" Arg="r"/>
  <Description>
  return <C>true</C> if the R-class <A>r</A> of a transformation
  semigroup is regular (i.e. it contains an idempotent) and returns 
  <C>false</C> otherwise.

  <Example>
    gap> s:=Monoid(Transformation( [ 10, 8, 7, 4, 1, 4, 10, 10, 7, 2 ] ),
    > Transformation( [ 5, 2, 5, 5, 9, 10, 8, 3, 8, 10 ] ));;
    gap> f:=Transformation( [ 1, 1, 10, 8, 8, 8, 1, 1, 10, 8 ] );;
    gap> r:=RClass(s, f);;
    gap> IsRegularRClass(r);
    true
    gap> h:=HClass(s, f);;
    gap> IsRegularRClass(h);
    gap> f:=Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] );;
    gap> s:=Monoid(Transformation([2,3,4,5,1,8,7,6,2,7]), 
    > Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] ));;
    gap> r:=RClass(s, f);;
    gap> IsRegularRClass(r);
    false
    gap> NrIdempotents(r);
    0
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGreensClassOfTransSemigp">
  <ManSection><Prop Name="IsGreensClassOfTransSemigp" Arg="x"/>
  <Description>
  returns <C>true</C> if <C>x</C> is a Green's class of a transformation 
  semigroup and returns <C>false</C> otherwise.<P/>
  
  This attribute is required so that a Green's class knowns that it belongs to 
  a transformation semigroup, so that the methods defined in the
  <Package>monoid</Package> are used in preference to those in the library.
  <Example>
    gap> s:=Semigroup(Transformation( [ 2, 1, 4, 5, 6, 3 ] ), 
    > Transformation( [ 2, 3, 1, 5, 4, 1 ] ));;
    gap> GreensLClassOfElement(s, a);
    {Transformation( [ 2, 1, 4, 5, 6, 3 ] )}
    gap> IsGreensClassOfTransSemigp(last);
    true
  </Example> <!-- greens.tst -->
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IteratorOfGreensRClasses">
  <ManSection>
  <Func Name="IteratorOfGreensRClasses" Arg="s"/>
  <Func Name="IteratorOfGreensDClasses" Arg="s"/>
  <Description>
  returns an iterator of the R-classes of the transformation semigroup <A>s</A>. 
  See <Ref Sect="Iterators" BookName="ref"/> for more information on
  iterators.<P/>

  This function is useful if you are, for example, looking for an R-class of
  semigroup with a particular property but do not necessarily want to compute
  all of the R-classes.<P/>

  See also <Ref Oper="GreensRClasses" BookName="ref"/> and 
  <Ref Oper="IteratorOfRClassReps"/>.<P/>

  The semigroup in the example below has 25147892 elements but it only takes 
  a fraction of a second to find a non-trivial R-class. <P/>

  <Example>
    gap> gens:=[ Transformation( [ 2, 4, 1, 5, 4, 4, 7, 3, 8, 1 ] ),
    >   Transformation( [ 3, 2, 8, 8, 4, 4, 8, 6, 5, 7 ] ),
    >   Transformation( [ 4, 10, 6, 6, 1, 2, 4, 10, 9, 7 ] ),
    >   Transformation( [ 6, 2, 2, 4, 9, 9, 5, 10, 1, 8 ] ),
    >   Transformation( [ 6, 4, 1, 6, 6, 8, 9, 6, 2, 2 ] ),
    >   Transformation( [ 6, 8, 1, 10, 6, 4, 9, 1, 9, 4 ] ),
    >   Transformation( [ 8, 6, 2, 3, 3, 4, 8, 6, 2, 9 ] ),
    >   Transformation( [ 9, 1, 2, 8, 1, 5, 9, 9, 9, 5 ] ),
    >   Transformation( [ 9, 3, 1, 5, 10, 3, 4, 6, 10, 2 ] ),
    >   Transformation( [ 10, 7, 3, 7, 1, 9, 8, 8, 4, 10 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> iter:=IteratorOfGreensRClasses(s);
    &lt;iterator of R-classes>
    gap> for r in iter do
    > if Size(r)>1 then break; fi;
    > od;
    gap> r;
    {Transformation( [ 6, 4, 1, 6, 6, 8, 9, 6, 2, 2 ] )}
    gap> Size(r);
    21600
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IteratorOfRClassReps">
  <ManSection>
  <Func Name="IteratorOfRClassReps" Arg="s"/>
  <Func Name="IteratorOfDClassReps" Arg="s"/>
  <Description>
  returns an iterator of the representatives of R-classes of the transformation
  semigroup <A>s</A>. See <Ref Sect="Iterators" BookName="ref"/> for more
  information on iterators.<P/>

  See also <Ref Oper="GreensRClasses" BookName="ref"/>, <Ref Oper="GreensRClasses"/>, 
  and <Ref Oper="IteratorOfGreensRClasses"/>.<P/>
  
  In the display of an <C>IteratorOfRClassReps</C> the total number of elements
  in the orbit of the semigroup acting on itself on the left is given (every
  R-class representative occurs in this orbit), the
  number of elements of the semigroup that have so far been computed is given,
  and the number of distinct R-classes that have been found is given. Note that these
  numbers depend on the state of the semigroup <A>s</A> and not of the iterator.
  <P/>
  
  <Example>
    gap> gens:=[ Transformation( [ 3, 2, 1, 5, 4 ] ), 
    > Transformation( [ 5, 4, 3, 2, 1 ] ), 
    > Transformation( [ 5, 4, 3, 2, 1 ] ), Transformation( [ 5, 5, 4, 5, 1 ] ), 
    > Transformation( [ 4, 5, 4, 3, 3 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> iter:=IteratorOfRClassReps(s);
    &lt;iterator of R-class reps, 6 candidates, 0 elements, 0 R-classes>
    gap> NextIterator(iter);
    Transformation( [ 1, 2, 3, 4, 5 ] )
    gap> NextIterator(iter);
    Transformation( [ 5, 5, 4, 5, 1 ] )
    gap> iter;
    &lt;iterator of R-class reps, 10 candidates, 20 elements, 2 R-classes>
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrGreensHClasses">
  <ManSection><Attr Name="NrGreensHClasses" Arg="x"/>
  <Description>
  returns the number of H-classes in the transformation semigroup, R-class,
  L-class, or D-class <A>x</A>. If the actual H-classes are not required, then it is  
  more efficient to use <C>NrGreensHClasses</C> than <C>Length(GreensHClasses)</C> 
  since the classes themselves are not created when <C>NrGreensHClasses</C> is
  called. 
  
  <Example>
    gap> gens:=[ Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),
    >   Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),
    >   Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),
    >   Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),
    >   Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> f:=Transformation( [ 2, 5, 4, 7, 4, 3, 6, 3 ] );;
    gap> r:=RClass(s, f);
    {Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
    gap> NrGreensHClasses(r);
    12
    gap> d:=DClass(r);
    {Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
    gap> NrGreensHClasses(d);
    72
    gap> l:=LClass(s, f);
    {Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
    gap> NrGreensHClasses(l);
    6 
    gap> NrGreensHClasses(s);
    1555
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrGreensRClasses">
  <ManSection>
  <Attr Name="NrGreensRClasses" Arg="x"/>
  <Attr Name="NrGreensDClasses" Arg="x"/>
  <Description>
  returns the number of R-classes in the transformation semigroup  or D-class 
  <A>x</A>. If the actual R-classes are not required, then it is  
  more efficient to use <C>NrGreensRClasses</C> than <C>Length(GreensRClasses)</C> 
  since the classes themselves are not created when <C>NrGreensRClasses</C> is
  called. 
  
  <Example>
    gap> gens:=[ Transformation( [ 4, 6, 5, 2, 1, 3 ] ),
    >   Transformation( [ 6, 3, 2, 5, 4, 1 ] ),
    >   Transformation( [ 1, 2, 4, 3, 5, 6 ] ),
    >   Transformation( [ 3, 5, 6, 1, 2, 3 ] ),
    >   Transformation( [ 5, 3, 6, 6, 6, 2 ] ),
    >   Transformation( [ 2, 3, 2, 6, 4, 6 ] ),
    >   Transformation( [ 2, 1, 2, 2, 2, 4 ] ),
    >   Transformation( [ 4, 4, 1, 2, 1, 2 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> NrGreensRClasses(s);
    150
    gap> Size(s);
    6342
    gap> f:=Transformation( [ 1, 3, 3, 1, 3, 5 ] );;
    gap> d:=DClass(s, f);
    {Transformation( [ 4, 1, 1, 4, 1, 2 ] )}
    gap> NrGreensRClasses(d);
    87
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrIdempotents">
  <ManSection><Attr Name="NrIdempotents" Arg="x"/>
  <Description>
  returns the number of idempotents in the transformation semigroup, R-class,
  L-class or D-class <A>x</A>. If the actual idempotents are not required, then it
  is more efficient to use <C>NrIdempotents(x)</C> than <C>Length(Idempotents(x))</C>
  since the idempotents themselves are not created when <C>NrIdempotents</C>
  is called.

  <Example>
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SchutzenbergerGroup">
  <ManSection><Attr Name="SchutzenbergerGroup" Arg="x"/>
  <Description>
  returns the (generalized) Schutzenberger group of the R-class, D-class, L-class or 
  H-class <A>x</A> of a transformation semigroup.<P/>
  
  If <A>x</A> is an R-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then
  <C>SchutzenbergerGroup(x)</C> is the permutation group 
  <Display>
    \{\:g|_{\textrm{im}(f)}\::\:\textrm{im}(f)^g=\textrm{im}(f)\:\}.
  </Display><P/>

  If <A>x</A> is an L-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then
  <C>SchutzenbergerGroup(x)</C> is the permutation group
  <Display>
    \{\:g|_{\textrm{ker}(f)}\::\:\ker(f)^g=\ker(f)\:\}.
  </Display><P/>

  If <A>x</A> is an H-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then <C>SchutzenbergerGroup(x)</C> is the 
  intersection of <C>SchutzenbergerGroup(RClass(s, f))</C> and
  <C>SchutzenbergerGroup(LClass(s, f))</C>. <P/>
  
  If <A>x</A> is a D-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then <C>SchutzenbergerGroup(x)</C> is just 
  <C>SchutzenbergerGroup(HClass(s, f))</C>. <P/>
       
  For more details see Chapter <Ref Chap="glossary"/>, <Cite Key="pfeiffer1"/> or
  <Cite Key="pfeiffer2"/>.<P/> 

  <Example>
    gap> s:=Semigroup([Transformation( [ 4, 4, 3, 5, 3 ] ), 
    > Transformation( [ 5, 1, 1, 4, 1 ] ), 
    > Transformation( [ 5, 5, 4, 4, 5 ] ));;
    gap> f:=Transformation( [ 4, 5, 5, 5, 5 ] );;
    gap> SchutzenbergerGroup(DClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(RClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(LClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(HClass(s, f));
    Group([ (4,5) ])
  </Example> <!-- greens.tst -->
  </Description>
  </ManSection>
<#/GAPDoc>

