#############################################################################
##
#W  d.xml
#Y  Copyright (C) 2006-2011                             James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##
## $Id: r.tst 127 2010-11-22 20:09:29Z jamesm $
##

<#GAPDoc Label="PartialOrderOfDClasses">
  <ManSection>
  <Attr Name="PartialOrderOfDClasses" Arg="s"/>
  <Description>
  returns a list <C>l</C> where <C>j</C> is in <C>l[i]</C> if and only if 
  <C>GreensDClasses(s)[j]</C> is immediately less than 
  <C>GreensDClasses(s)[i]</C> in the partial order of <Math>D</Math>-classes of <A>s</A>.
  The transitive closure of the relation <Math>\{\:(j,i):\:\: j\in
  l[i]\:\}</Math> is the partial order of <Math>D</Math>-classes. <P/>

  The partial order on the <Math>D</Math>-classes is defined by 
  <Math>x\leq y</Math> in if and only if <C>s^1xs^1</C> is a subset of  
  <C>s^1ys^1</C>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrRegularDClasses"> 
  <ManSection><Attr Name="NrRegularDClasses" Arg="s"/> 
    <Description>
    returns the number of regular <Math>D</Math>-classes of the transformation
    semigroup <A>s</A>.
    </Description>
    </ManSection>
<#/GAPDoc>


#############################################################################
##
#W  r.xml
#Y  Copyright (C) 2006-2010                             James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##
## $Id: r.tst 127 2010-11-22 20:09:29Z jamesm $
##

## - cross references and double check. 

<Chapter Label="Advanced"> <Heading>Advanced Features</Heading>
  
  <Section Label="GreensAdvancedR">
    <Heading>Green's R-relation - advanced</Heading>
  
    The functions described in this section are used by <Package>monoid
    </Package> in computation related to Green's R-relation. It is not 
    envisioned that these functions be used when performing a single 
    calculation but rather could be used to extend the 
    <Package>monoid</Package> package. <P/> 

    Please note that calling certain functions in this section in the incorrect
    context could have unpredictable and unusual consequences. 

    <#Include Label="AddToOrbitsOfImages">
    <#Include Label="CreateRClass">
    <#Include Label="CreateSchreierTreeOfSCC">
    <#Include Label="CreateReverseSchreierTreeOfSCC">
    <#Include Label="DisplayOrbitsOfImages">
    <#Include Label="ExpandOrbitsOfImages">
    <#Include Label="ForwardOrbitOfImage">
    <#Include Label="InOrbitsOfImages">
    <#Include Label="IsRegularRClassData"> 
  </Section>

  <Section Label="GreensAdvancedH">
    <Heading>Green's H-relation - advanced</Heading>
    
    <#Include Label="GreensHClassRepsData">
  </Section>

</Chapter> 

<#GAPDoc Label="AddToOrbitsOfImages">
<ManSection><Func Name="AddToOrbitsOfImages" Arg="s, f, d, o"/>
  <Description>
  The arguments should be: <A>s</A> a semigroup or D-class, <A>f</A> a 
  transformation, <A>o</A> the attribute <Ref Attr="OrbitsOfImages"/>
  of <A>s</A>, and <A>d=[j, k, l, m, val, n, g]</A> where:
  <List>
    <Item> <A>j</A> - is the size of the image set of <A>f</A>;
    </Item>
        
    <Item> <A>k</A> - is the index of the orbit containing the image of 
    <A>f</A>, that is, <C>ImageSetOfTransformation(f)</C> is in
     <C>OrbitsOfImages(s)!.orbits[j][k]</C>;
    </Item>
        
    <Item><A>l</A> - is the position of the image of <A>f</A> in 
    <C>OrbitsOfImages(s)!.orbits[j][k]</C>;</Item>

    <Item> <A>m</A> - is the index of the strongly connected component of 
    <C>OrbitsOfImages(s)!.orbits[j][k]</C> containing the image of 
    <A>f</A>;
    </Item>
        
    <Item> <A>val</A> - is the return value of 
    <Log>
      HTValue(OrbitsOfImages(s)!.orbits[j][k]!.kernels_ht[m],
       KernelOfTransformation(f)),
    </Log> 
    that is, the index of the list of representatives of R-classes of 
    <A>s</A> with the same Schutzenberger group, strong orbit of images, 
    and kernel as <A>f</A>; 
    </Item>
    
    <Item> <A>n</A> - the length of the list 
    <C>OrbitsOfImages(s)!.orbits[j][k]!.reps[m][val]</C> of 
    representatives of R-classes of <A>s</A> with the same Schutzenberger
    group, strong orbit of images, and kernel as <A>f</A>;
    </Item>

    <Item> <A>g</A> - the transformation 
    <C>f*OrbitsOfImages(s)!.orbits[j][k]!.perms[l]</C>, which is
    R-related to <A>f</A> and has the property that the image <C>X</C> of 
    <A>g</A> satisfies 
    <Log>
      Position(OrbitsOfImages(s)!.orbits[j][k], X)=
      OrbitsOfImages(s)!.orbits[j][k]!.scc[m][1].
    </Log>
    </Item>
  </List>
  
  The result of this function is to add all the information relating to 
  the R-class of <A>f</A> in <A>s</A> to the attribute 
  <Ref Attr="OrbitsOfImages"/> of <A>s</A>. <P/>

  See also <Ref Func="PreInOrbitsOfImages"/> and 
  <Ref Func="InOrbitsOfImages"/>. 
  
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CreateRClass">
  <ManSection><Func Name="CreateRClass" Arg="s, d, o, f"/>
  <Description>
  creates an R-class <C>r</C> object using <Ref Func="RClassType"/> of 
  <A>s</A> where the components used by <Package>monoid</Package> are: 
  <List>
    <Item> <C>r!.parent=s</C> the semigroup</Item> 
    
    <Item> <C>r!.data=d</C> the tuple [j, k, l, m, val, n] described in 
    <Ref Func="AddToOrbitsOfImage"/></Item>
    
    <Item><C>r!.orbit=o</C> which is either 
    <Ref Attr="OrbitsOfImages"/> of <A>s</A> if <C>r</C> was created by 
    <Ref Oper= "GreensRClassOfElement"/> or a local version of 
    <Ref Attr="OrbitsOfImages"/> stored in <C>r</C> if it was created with 
    <Ref Oper= "GreensRClassOfElementNC"/></Item>
    
    <Item><C>r!.rep=f</C> is the representative of the R-class.</Item>
  </List>

  Note that <C>ParentAttr</C> of the <C>r</C> is not set as this 
  seems to take some time.

  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user -->

<#GAPDoc Label="CreateSchreierTreeOfSCC">
  <ManSection><Func Name="CreateSchreierTreeOfSCC" Arg="o,i"/>
  <Description>
  if <A>o</A> is an <Package>orb</Package> orbit object created 
  by <Ref Func="ForwardOrbitOfImage"/> or 
  <Ref Func="ForwardOrbitOfKernel"/> and <A>i</A> is the index
  of one of the strongly connected components of <A>o</A>, then 
  <C>CreateSchreierTreeOfSCC</C> returns a list <C>[gen, pos]</C> 
  such that:
  
  <Log>
    OnSets(o[pos[j]], o!.gens[gen[j]])=o[j];
    OnKernelsAntiAction(o[pos[j]], o!.gens[gen[j]])=o[j];
  </Log>

  So, the generator whose index appears in <C>gen[j]</C> maps
  the <C>pos[j]</C>th element of <A>o</A> to <A>o[j]</A>.<P/>

  See also <Ref Func="TraceSchreierTreeOfSCCForward"/>, 
  <Ref Func="CreateReverseSchreierTreeOfSCC"/>, and
  <Ref Func="TraceSchreierTreeOfSCCBack"/>.
  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user -->

<#GAPDoc Label="CreateReverseSchreierTreeOfSCC">
  <ManSection><Func Name="CreateReverseSchreierTreeOfSCC" Arg="o,i"/>
  <Description>
  if <A>o</A> is an <Package>orb</Package> orbit object created by 
  <Ref Func="ForwardOrbitOfImage"/> or <Ref Func="ForwardOrbitOfKernel"/> 
  and <A>i</A> is the index of one of the strongly connected components of
  <A>o</A>, then <C>CreateReverseSchreierTreeOfSCC</C> returns a list 
  <C>[gen, pos]</C> such that:

  <Log>
    OnSets(o[j], o!.gens[gen[j]])=o[pos[j]];
    OnKernelsAntiAction(o[j], o!.gens[gen[j]])=o[pos[j]];
  </Log>
  
  So, the generator whose index appears in <C>gen[j]</C> maps
  the <C>j</C>th element of <A>o</A> to <A>o[pos[j]]</A>.<P/>

  See also <Ref Func="TraceSchreierTreeOfSCCForward"/>, 
  <Ref Func="CreateSchreierTreeOfSCC"/>, and
  <Ref Func="TraceSchreierTreeOfSCCBack"/>.
  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user --> 

<#GAPDoc Label="DisplayOrbitsOfImages">
  <ManSection><Func Name="DisplayOrbitsOfImages" Arg="s"/>
  <Description>
  returns the information stored in <Ref Func="OrbitsOfImages"/> of 
  the transformation semigroup <A>s</A> in a (more or less) nicely formatted 
  way. See <Ref Func="OrbitsOfImages"/> for more details.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="ExpandOrbitsOfImages">
  <ManSection><Func Name="ExpandOrbitsOfImages" Arg="s"/>
  <Description>
  completes the information in <Ref Attr="OrbitsOfImages"/> that is 
  used to calculate the size, membership, and R-classes of <A>s</A>.
  This is equivalent to the following:
  
  <Log>
  gap> iter:=IteratorOfNewRClassRepsData(s);;
  gap> for i in iter do od;
  </Log>
  </Description>
  </ManSection>
<#/GAPDoc><!-- non-user -->

<#GAPDoc Label="ForwardOrbitOfImage">
  <ManSection><Func Name="ForwardOrbitOfImage" Arg="s, f, [imgs[, gens]]"/>
  <Description>
  returns a triple consisting of:
  
  <List>
  <Item>the <Package>orb</Package> orbit object <C>o</C> of the image of 
  <A>f</A> in transformation semigroup <A>s</A>;</Item>
  
  <Item> a flat list of R-class representatives associated with <C>o</C>;
  </Item>
  
  <Item> a set containing the index of the first image set in every 
  strongly connected component of <C>o</C>.</Item>
  </List>
  
  If the optional argument <A>imgs</A> is present, then the option 
  <C>onlygradesdata</C> of <C>o</C> is set to equal the hash table <A>imgs</A>
  and only the sets <C>x</C> where <C>HTValue(imgs, x)=fail</C> are added to
  <C>o</C>. In other words, <A>imgs</A> is a hash table containing some image
  sets, and only those images not in <A>imgs</A> are added to the orbit.<P/> 

  If the optional argument <A>gens</A> (a list of generators of <A>s</A>) is 
  present, then for the sake of efficiency this is used instead of calling 
  <C>Generators(s)</C>. 

  <Example>
  gap> s:=Semigroup([ 
  >  Transformation( [ 12, 10, 8, 5, 1, 5, 12, 12, 8, 2, 6, 2 ] ), 
  >  Transformation( [ 5, 6, 10, 11, 10, 4, 10, 12, 5, 7, 4, 10 ] ), 
  >  Transformation( [ 6, 8, 12, 5, 4, 8, 10, 7, 4, 1, 10, 11 ] ) ]);;
  gap> f:=Transformation( [ 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8 ] );;
  gap> ForwardOrbitOfImage(s, f);
  [ &lt;closed img orbit 40 sets with 2 elts, 1 scc, 1 kernels, 1 reps>, 
  [ Transformation( [ 4, 8, 4, 8, 4, 8, 4, 8, 4, 8, 4, 8 ] ) ], [ 1 ] ]
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensHClasses">
  <ManSection><Attr Name="GreensHClasses" Arg="x"/>
  <Description>
  returns a list of <Math>H</Math>-classes contained in the object 
  <A>x</A> where <A>x</A> is a transformation semigroup, an R-class, an L-class,
  or a D-class. <P/>

  See also <Ref Attr="GreensHClassReps"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensHClassReps">
  <ManSection><Attr Name="GreensHClassReps" Arg="x"/>
  <Description>
  returns a list of representatives of <Math>H</Math>-classes contained in the 
  object <A>x</A> where <A>x</A> is a transformation semigroup, an R-class, an L-
  class, or a D-class. <P/>

  Note that if the H-classes are not required, then <C>GreensHClassReps</C> is more 
  efficient than <C>GreensHClasses</C>, since the H-class objects are not created.<P/>

  See also <Ref Attr="GreensHClasses"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensHClassRepsData">
  <ManSection><Attr Name="GreensHClassRepsData" Arg="r"/>
  <Description>
  returns a triple corresponding to the representatives of <Math>H</Math>-
  classes contained in the R-class <A>r</A> where:
  
  <List>

    <Item> the first component is the tuple <C>[j, k, l, m, n, val, g]</C>
    equal to <A>r!.data</A> as described in <Ref Func="AddToOrbitsOfImages"/>;
    </Item>
 
    <Item> the second component is the tuple <C>[j, k, l, m, n, val, g, i]</C>
    equal to <A>GreensDClass(r)!.data[2]</A> as described in JDM3.
    </Item>

    <Item> the third component is the pair <C>[i, j]</C> where <C>i</C> is a
    position in <C>RClassSCC(r)</C> and <C>j</C> is the index of an element in 
    <C>DClassRCosets(GreensDClass(r))</C> so that the corresponding H-class 
    representative is 
    
    <Log>
  Representative(r)*(RClassPerms(r)[i]/DClassRCosets(GreensDClass(r))[j]);
    </Log>
    
    </Item>
  </List> 

  Note that if the H-classes are not required, then GreensHClassReps is more 
  efficient than the above, since the H-class objects are not created.<P/>

  See also <Ref Attr="GreensHClasses" BookName="ref"/> and
  <Ref Attr="GreensHClassReps"/>.

  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensRClasses">
  <ManSection><Attr Name="GreensRClasses" Arg="x"/>
  <Description>
  returns a list of <Math>R</Math>-classes contained in the object 
  <A>x</A> where <A>x</A> is a transformation semigroup,
  or a D-class. <P/>

  See also <Ref Attr="GreensRClassReps"/> and 
  <Ref Func="IteratorOfGreensRClasses"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensRClassOfElementNC">
  <ManSection>
  <Oper Name="GreensRClassOfElementNC" Arg="s, f"/>
  <Oper Name="GreensDClassOfElementNC" Arg="s, f"/>
  <Description>
  creates the <Math>R</Math>-class, <Math>D</Math>-class, <Math>L</Math>-class,
  or <Math>H</Math>-class of the transformation <A>f</A> 
  in the transformation
  semigroup <A>s</A> after checking if <A>f</A> has already been shown to be an
  element of <A>s</A> or not. Note that if it is not known to &GAP; if 
  <A>f</A> is an element of <A>s</A> or not, then no further attempt to verify if
  <A>f</A> is in <A>s</A> is made. 
   <!--Calling this function does not modify 
  <Ref Attr="OrbitsOfImages"/> of <A>s</A>.--> <P/>

  It can be quicker to compute to compute the class of an element using 
  <C>GreensRClassOfElementNC</C>, say, than using <C>GreensRClassOfElement</C> if it
  is known <E>a priori</E> that <A>f</A> is an element of <A>s</A>. On the other
  hand, if <A>f</A> is not an element of <A>s</A>, then the results of this
  computation are unpredictable.<P/> 

  For example, if 
  <Log>
  f:=Transformation( [ 15, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
  20, 20, 20, 20, 20, 20 ] );
  </Log>
  in the semigroup <A>s</A> of order-preserving mappings on 20 points, then
  <Log>
  GreensRClassOfElementNC(s, f);;
  </Log>
  returns an answer relatively quickly, whereas <C>GreensRClassOfElement</C>
  can take a signficant amount of time and memory to return a value. 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensRClassReps">
  <ManSection>
  <Attr Name="GreensRClassReps" Arg="s"/>
  <Attr Name="GreensDClassReps" Arg="s"/>
  <Description>
  returns a list of <Math>R</Math>-class representatives of the transformation 
  semigroup <A>s</A>. The same output can be obtained by calling: 
  <Log>
    List(GreensRClasses(s), Representative);
  </Log>
  Note that if R-classes are not required, then <C>GreensRClassReps</C> is more
  efficient than the above, since the R-class objects are not created.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Idempotents">
  <ManSection><Attr Name="Idempotents" Arg="x[,n]"/>
  <Description>
  returns a list of the idempotents in the transformation semigroup or Green's 
  class <A>x</A>. <P/>

  If the optional second argument <A>n</A> is present and <A>x</A> is a
  transformation semigroup, then a list of the 
  idempotents in <A>x</A> of rank <A>n</A> is returned. If you are only 
  interested in the idempotents of a given rank, then the second version of the 
  function will likely be faster. However, if the optional second argument is
  present, then nothing is stored in <A>x</A> and so every time the function
  is called the computation must be repeated. 
  
  <Example>
  gap> s:=Semigroup([ Transformation( [ 2, 3, 4, 1 ] ), 
   > Transformation( [ 3, 3, 1, 1 ] ) ]);;
  gap> Idempotents(s, 1);
  [  ]
  gap> Idempotents(s, 2);                        
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ), 
    Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> Idempotents(s);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 2, 3, 4 ] ), 
    Transformation( [ 1, 3, 3, 1 ] ), Transformation( [ 2, 2, 4, 4 ] ), 
    Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> f:=Transformation( [ 2, 2, 4, 4 ] );;
  gap> r:=RClass(s, f);
  {Transformation( [ 3, 3, 1, 1 ] )}
  gap> Idempotents(r);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 2, 2, 4, 4 ] ) ]
  </Example> 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="InOrbitsOfImages">
  <ManSection><Func Name="InOrbitsOfImages" Arg="s, f, d, o, imgs"/>
  <Description>
  The arguments of <C>InOrbitsOfImages</C> should be:
  
  <List>
  
  <Item> <A>s</A> - a transformation semigroup;
  </Item>
  
  <Item> <A>f</A> - a transformation;
  </Item>

  <Item> <A>d</A> - a tuple <C>[j, k, l, m, val, g]</C> as described in 
  <Ref Func="AddToOrbitsOfImages"/>. Of course, if every element in <A>d</A> is 
  not <C>fail</C>, then you already know that <A>f</A> is in <A>s</A>;
  </Item>

  <Item> <A>o</A><C>=OrbitsOfImages(s)!.orbits</C> the orbits of images of
  <A>s</A>;
  </Item>

  <Item> <A>imgs</A><C>=OrbitsOfImages(s)!.images</C> the hash table containing 
  the list of images of elements of <A>s</A> so far computed. 
  </Item>

  </List>
  
  <C>InOrbitsOfImages</C> returns the tuple 
  <C>[true/false, [j, k, l, m, val, n, g]</C> where 
  the first component indicates if the transformation <A>f</A> is in <Ref
  Attr="OrbitsOfImages"/> of <A>s</A>, and the second component is as described
  in <Ref Func="AddToOrbitsOfImages"/>. The output entries in the tuple 
  <C>[j, k, l, m, val, n, g]</C> are an updated version of the argument
  <A>d</A>. <P/>

  To check that <A>f</A> is in <Ref Attr="OrbitsOfImages"/> of 
  <A>s</A> use <Ref Func="PreInOrbitsOfImages"/> to avoid the complicated input
  required by <C>InOrbitsOfImages</C>. Note that the input to
  <C>InOrbitsOfImages</C> is complicated to avoid repeatedly having to find
  access the components of <C>OrbitsOfImages</C>, which could slow things down
  when using <Ref Func="IteratorOfRClassRepsData"/> and functions based on it.

  <Example>
  gap> s:=Monoid(Transformation( [ 8, 7, 5, 3, 1, 3, 8, 8 ] ),
  > Transformation( [ 5, 1, 4, 1, 4, 4, 7, 8 ] ));;
  gap> f:=Transformation( [ 8, 8, 1, 5, 8, 5, 8, 8 ] );;
  gap> PreInOrbitsOfImages(s, f);
  [ false, [ 3, fail, fail, fail, fail, 0, fail ] ]
  gap> iter:=IteratorOfGreensRClasses(s);
  &lt;iterator of R-classes>
  gap> NextIterator(iter);; NextIterator(iter);;
  gap> PreInOrbitsOfImages(s, f);
  [ false, [ 3, fail, fail, fail, fail, 0, fail ] ]
  gap> NextIterator(iter);; NextIterator(iter);;
  gap> PreInOrbitsOfImages(s, f);
  [ true, [ 3, 1, 1, 1, 1, 1, Transformation( [ 8, 8, 1, 5, 8, 5, 8, 8 ] ) ] ]
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularRClass">
  <ManSection><Attr Name="IsRegularRClass" Arg="r"/>
  <Description>
  return <C>true</C> if the R-class <A>r</A> of a transformation
  semigroup is regular (i.e. it contains an idempotent) and returns 
  <C>false</C> otherwise.

  <Example>
    gap> s:=Monoid(Transformation( [ 10, 8, 7, 4, 1, 4, 10, 10, 7, 2 ] ),
    > Transformation( [ 5, 2, 5, 5, 9, 10, 8, 3, 8, 10 ] ));;
    gap> f:=Transformation( [ 1, 1, 10, 8, 8, 8, 1, 1, 10, 8 ] );;
    gap> r:=RClass(s, f);;
    gap> IsRegularRClass(r);
    true
    gap> h:=HClass(s, f);;
    gap> IsRegularRClass(h);
    gap> f:=Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] );;
    gap> s:=Monoid(Transformation([2,3,4,5,1,8,7,6,2,7]), 
    > Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] ));;
    gap> r:=RClass(s, f);;
    gap> IsRegularRClass(r);
    false
    gap> NrIdempotents(r);
    0
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGreensClassOfTransSemigp">
  <ManSection><Prop Name="IsGreensClassOfTransSemigp" Arg="x"/>
  <Description>
  returns <C>true</C> if <C>x</C> is a Green's class of a transformation 
  semigroup and returns <C>false</C> otherwise.<P/>
  
  This attribute is required so that a Green's class knowns that it belongs to 
  a transformation semigroup, so that the methods defined in the
  <Package>monoid</Package> are used in preference to those in the library.
  <Example>
    gap> s:=Semigroup(Transformation( [ 2, 1, 4, 5, 6, 3 ] ), 
    > Transformation( [ 2, 3, 1, 5, 4, 1 ] ));;
    gap> GreensLClassOfElement(s, a);
    {Transformation( [ 2, 1, 4, 5, 6, 3 ] )}
    gap> IsGreensClassOfTransSemigp(last);
    true
  </Example> <!-- greens.tst -->
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularRClassData">
  <ManSection><Func Name="IsRegularRClassData" Arg="s, d[, o[, f]]"/>
  <Description>
  if <A>s</A> is a transformation semigroup, <A>d</A> is a tuple  
  <A>[j, k, l, m, val, n, g]</A> as described in 
  <Ref Func="AddToOrbitsOfImages"/>, then <C>IsRegularRClassData</C> returns
  <C>true</C> if the R-class created using <Ref Func="CreateRClass"/> with
  arguments <A>s, d, OrbitsOfImages(s), RClassRepFromData(s, d)</A>
  is regular and it returns <C>false</C> otherwise. <P/>

  If the optional third argument <A>o</A> is present, then this is used instead
  of <C>OrbitsOfImages(s)</C> above. <P/>

  If the optional fourth argument <A>f</A> is present, then this is used
  instead of <C>RClassRepFromData(s, d, o)</C> above. <P/>

  Note that it is not necessary to actually create the R-class to perform this
  check, and that if the R-class is not actually required, then using
  <C>IsRegularRClassData</C> will be more efficient. <P/>
  
  See also <Ref Prop="IsRegularRClass"/>. 
  
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IteratorOfGreensRClasses">
  <ManSection>
  <Func Name="IteratorOfGreensRClasses" Arg="s"/>
  <Func Name="IteratorOfGreensDClasses" Arg="s"/>
  <Description>
  returns an iterator of the R-classes of the transformation semigroup <A>s</A>. 
  See <Ref Sect="Iterators" BookName="ref"/> for more information on
  iterators.<P/>

  This function is useful if you are, for example, looking for an R-class of
  semigroup with a particular property but do not necessarily want to compute
  all of the R-classes.<P/>

  See also <Ref Oper="GreensRClasses" BookName="ref"/> and 
  <Ref Oper="IteratorOfRClassReps"/>.<P/>

  The semigroup in the example below has 25147892 elements but it only takes 
  a fraction of a second to find a non-trivial R-class. <P/>

  <Example>
    gap> gens:=[ Transformation( [ 2, 4, 1, 5, 4, 4, 7, 3, 8, 1 ] ),
    >   Transformation( [ 3, 2, 8, 8, 4, 4, 8, 6, 5, 7 ] ),
    >   Transformation( [ 4, 10, 6, 6, 1, 2, 4, 10, 9, 7 ] ),
    >   Transformation( [ 6, 2, 2, 4, 9, 9, 5, 10, 1, 8 ] ),
    >   Transformation( [ 6, 4, 1, 6, 6, 8, 9, 6, 2, 2 ] ),
    >   Transformation( [ 6, 8, 1, 10, 6, 4, 9, 1, 9, 4 ] ),
    >   Transformation( [ 8, 6, 2, 3, 3, 4, 8, 6, 2, 9 ] ),
    >   Transformation( [ 9, 1, 2, 8, 1, 5, 9, 9, 9, 5 ] ),
    >   Transformation( [ 9, 3, 1, 5, 10, 3, 4, 6, 10, 2 ] ),
    >   Transformation( [ 10, 7, 3, 7, 1, 9, 8, 8, 4, 10 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> iter:=IteratorOfGreensRClasses(s);
    &lt;iterator of R-classes>
    gap> for r in iter do
    > if Size(r)>1 then break; fi;
    > od;
    gap> r;
    {Transformation( [ 6, 4, 1, 6, 6, 8, 9, 6, 2, 2 ] )}
    gap> Size(r);
    21600
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IteratorOfRClassReps">
  <ManSection>
  <Func Name="IteratorOfRClassReps" Arg="s"/>
  <Func Name="IteratorOfDClassReps" Arg="s"/>
  <Description>
  returns an iterator of the representatives of R-classes of the transformation
  semigroup <A>s</A>. See <Ref Sect="Iterators" BookName="ref"/> for more
  information on iterators.<P/>

  See also <Ref Oper="GreensRClasses" BookName="ref"/>, <Ref Oper="GreensRClasses"/>, 
  and <Ref Oper="IteratorOfGreensRClasses"/>.<P/>
  
  In the display of an <C>IteratorOfRClassReps</C> the total number of elements
  in the orbit of the semigroup acting on itself on the left is given (every
  R-class representative occurs in this orbit), the
  number of elements of the semigroup that have so far been computed is given,
  and the number of distinct R-classes that have been found is given. Note that these
  numbers depend on the state of the semigroup <A>s</A> and not of the iterator.
  <P/>
  
  <Example>
    gap> gens:=[ Transformation( [ 3, 2, 1, 5, 4 ] ), 
    > Transformation( [ 5, 4, 3, 2, 1 ] ), 
    > Transformation( [ 5, 4, 3, 2, 1 ] ), Transformation( [ 5, 5, 4, 5, 1 ] ), 
    > Transformation( [ 4, 5, 4, 3, 3 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> iter:=IteratorOfRClassReps(s);
    &lt;iterator of R-class reps, 6 candidates, 0 elements, 0 R-classes>
    gap> NextIterator(iter);
    Transformation( [ 1, 2, 3, 4, 5 ] )
    gap> NextIterator(iter);
    Transformation( [ 5, 5, 4, 5, 1 ] )
    gap> iter;
    &lt;iterator of R-class reps, 10 candidates, 20 elements, 2 R-classes>
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrGreensHClasses">
  <ManSection><Attr Name="NrGreensHClasses" Arg="x"/>
  <Description>
  returns the number of H-classes in the transformation semigroup, R-class,
  L-class, or D-class <A>x</A>. If the actual H-classes are not required, then it is  
  more efficient to use <C>NrGreensHClasses</C> than <C>Length(GreensHClasses)</C> 
  since the classes themselves are not created when <C>NrGreensHClasses</C> is
  called. 
  
  <Example>
    gap> gens:=[ Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),
    >   Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),
    >   Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),
    >   Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),
    >   Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> f:=Transformation( [ 2, 5, 4, 7, 4, 3, 6, 3 ] );;
    gap> r:=RClass(s, f);
    {Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
    gap> NrGreensHClasses(r);
    12
    gap> d:=DClass(r);
    {Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
    gap> NrGreensHClasses(d);
    72
    gap> l:=LClass(s, f);
    {Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
    gap> NrGreensHClasses(l);
    6 
    gap> NrGreensHClasses(s);
    1555
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrGreensRClasses">
  <ManSection>
  <Attr Name="NrGreensRClasses" Arg="x"/>
  <Attr Name="NrGreensDClasses" Arg="x"/>
  <Description>
  returns the number of R-classes in the transformation semigroup  or D-class 
  <A>x</A>. If the actual R-classes are not required, then it is  
  more efficient to use <C>NrGreensRClasses</C> than <C>Length(GreensRClasses)</C> 
  since the classes themselves are not created when <C>NrGreensRClasses</C> is
  called. 
  
  <Example>
    gap> gens:=[ Transformation( [ 4, 6, 5, 2, 1, 3 ] ),
    >   Transformation( [ 6, 3, 2, 5, 4, 1 ] ),
    >   Transformation( [ 1, 2, 4, 3, 5, 6 ] ),
    >   Transformation( [ 3, 5, 6, 1, 2, 3 ] ),
    >   Transformation( [ 5, 3, 6, 6, 6, 2 ] ),
    >   Transformation( [ 2, 3, 2, 6, 4, 6 ] ),
    >   Transformation( [ 2, 1, 2, 2, 2, 4 ] ),
    >   Transformation( [ 4, 4, 1, 2, 1, 2 ] ) ];;
    gap> s:=Semigroup(gens);;
    gap> NrGreensRClasses(s);
    150
    gap> Size(s);
    6342
    gap> f:=Transformation( [ 1, 3, 3, 1, 3, 5 ] );;
    gap> d:=DClass(s, f);
    {Transformation( [ 4, 1, 1, 4, 1, 2 ] )}
    gap> NrGreensRClasses(d);
    87
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrIdempotents">
  <ManSection><Attr Name="NrIdempotents" Arg="x"/>
  <Description>
  returns the number of idempotents in the transformation semigroup, R-class,
  L-class or D-class <A>x</A>. If the actual idempotents are not required, then it
  is more efficient to use <C>NrIdempotents(x)</C> than <C>Length(Idempotents(x))</C>
  since the idempotents themselves are not created when <C>NrIdempotents</C>
  is called.

  <Example>
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SchutzenbergerGroup">
  <ManSection><Attr Name="SchutzenbergerGroup" Arg="x"/>
  <Description>
  returns the (generalized) Schutzenberger group of the R-class, D-class, L-class or 
  H-class <A>x</A> of a transformation semigroup.<P/>
  
  If <A>x</A> is an R-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then
  <C>SchutzenbergerGroup(x)</C> is the permutation group 
  <Display>
    \{\:g|_{\textrm{im}(f)}\::\:\textrm{im}(f)^g=\textrm{im}(f)\:\}.
  </Display><P/>

  If <A>x</A> is an L-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then
  <C>SchutzenbergerGroup(x)</C> is the permutation group
  <Display>
    \{\:g|_{\textrm{ker}(f)}\::\:\ker(f)^g=\ker(f)\:\}.
  </Display><P/>

  If <A>x</A> is an H-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then <C>SchutzenbergerGroup(x)</C> is the 
  intersection of <C>SchutzenbergerGroup(RClass(s, f))</C> and
  <C>SchutzenbergerGroup(LClass(s, f))</C>. <P/>
  
  If <A>x</A> is a D-class of a transformation semigroup <C>s</C> with
  representative <C>f</C>, then <C>SchutzenbergerGroup(x)</C> is just 
  <C>SchutzenbergerGroup(HClass(s, f))</C>. <P/>
       
  For more details see Chapter <Ref Chap="glossary"/>, <Cite Key="pfeiffer1"/> or
  <Cite Key="pfeiffer2"/>.<P/> 

  <Example>
    gap> s:=Semigroup([Transformation( [ 4, 4, 3, 5, 3 ] ), 
    > Transformation( [ 5, 1, 1, 4, 1 ] ), 
    > Transformation( [ 5, 5, 4, 4, 5 ] ));;
    gap> f:=Transformation( [ 4, 5, 5, 5, 5 ] );;
    gap> SchutzenbergerGroup(DClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(RClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(LClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(HClass(s, f));
    Group([ (4,5) ])
  </Example> <!-- greens.tst -->
  </Description>
  </ManSection>
<#/GAPDoc>

