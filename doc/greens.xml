#############################################################################
##
#W  greens.xml
#Y  Copyright (C) 2006-2011                             James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="\&lt;">
  <ManSection><Heading>Less than for Green's classes</Heading>
    <Oper Name="\&lt;" Arg='left-expr, right-expr'/>
    <Description>
      returns <K>true</K> if the Green's classes <A>left-expr</A> and
      <A>right-expr</A> 
      belong to the same transformation semigroup and the representative
       of
      <A>left-expr</A> is less than the representative of
      <A>right-expr</A>.<P/>

      More precisely, <C>left-expr&lt;right-expr</C> if 
      <Log>ParentAttr(left-expr)=ParentAttr(right-expr)</Log> and 
      <Log>ImageListOfTransformation(Representative(left-expr))&lt; 
      ImageListOfTransformation(Representative(right-expr))</Log>
      see also <Ref Attr="ImageListOfTransformation" BookName="ref"/> and 
      <Ref Attr="Representative" BookName="ref"/>.<P/>

       Please note that this is not the usual order on the Green's classes of
       a semigroup as defined in 
       <Ref Sect="Green's Relations" BookName="ref"/>. See also 
       <Ref Oper="IsGreensLessThanOrEqual" BookName="ref"/>.
      <Example>
gap> s:=FullTransformationSemigroup(4);;
gap> x:=GreensRClassOfElement(s, Transformation( [ 2, 1, 3, 1 ] ));
{Transformation( [ 2, 1, 3, 1 ] )}
gap> y:=GreensRClassOfElement(s, Transformation( [ 1, 2, 3, 4 ] ));
{Transformation( [ 1, 2, 3, 4 ] )}
gap> x&lt;y;
false
gap> y&lt;x;
true
gap> IsGreensLessThanOrEqual(x,y);
true
gap> IsGreensLessThanOrEqual(y,x);
false</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="XClassOfYClass">
  <ManSection><Heading>XClassOfYClass</Heading>
    <Oper Name="DClassOfRClass" Arg="x"/>
    <Oper Name="DClassOfLClass" Arg="x"/>
    <Oper Name="RClassOfHClass" Arg="x"/>
    <Oper Name="LClassOfHClass" Arg="x"/>
    <Oper Name="DClassOfHClass" Arg="x"/>
    <Description>
      returns the Green's <Math>\mathcal{X}</Math>-class containing the
      Green's <Math>\mathcal{Y}</Math>-class <A>x</A> where
      <Math>\mathcal{X}</Math> and <Math>\mathcal{Y}</Math> should be
      replaced with one of <Math>\mathcal{D}, \mathcal{R},
      \mathcal{L}</Math> and <Math>\mathcal{R}, \mathcal{L},
      \mathcal{H}</Math>, respectively.<P/>

      Note that if it is not known to &GAP; whether or not the representative 
      of <A>x</A> is an element of the semigroup containing <A>x</A>, then no
      attempt is made to check this.<P/>

      The same result can be produced using:
      <Log> First(GreensXClasses(s), x-> Representative(r) in x);</Log>
      but this will be substantially slower in many examples.<P/>

      See also <Ref Oper="GreensDClassOfElement"
      BookName="ref"/>,
      <Ref Oper="GreensDClassOfElement"/>, and
      <Ref Oper="GreensDClassOfElementNC"/>.
      <Example>
gap> s:=Semigroup(Transformation( [ 1, 3, 2 ] ), Transformation( [ 2, 1, 3 ] ),
> Transformation( [ 3, 2, 1 ] ), Transformation( [ 1, 3, 1 ] ) );
gap> r:=GreensRClassOfElement(s, Transformation( [ 3, 2, 1 ] ));;
{Transformation( [ 1, 2, 3 ] )}
gap> DClassOfRClass(r);
{Transformation( [ 1, 2, 3 ] )}
gap> IsGreensDClass(last);
true</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensXClasses">
  <ManSection><Heading>GreensXClasses</Heading>
    <Oper Name="GreensDClasses" Arg="x"/>
    <Oper Name="GreensHClasses" Arg="x"/>
    <Oper Name="GreensLClasses" Arg="x"/>
    <Oper Name="GreensRClasses" Arg="x"/>
    <Description>
      returns a list of <Math>\mathcal{X}</Math>-classes contained in the 
      object <A>x</A> where <A>x</A> is a transformation semigroup,
      <Math>\mathcal{D}</Math>-, <Math>\mathcal{L}</Math>-, or
      <Math>\mathcal{R}</Math>-class and where
      <Math>\mathcal{X}</Math> should be
      replaced with one of <Math>\mathcal{D}, \mathcal{R}, \mathcal{L}</Math>
      or <Math>\mathcal{H}</Math>.<P/>

      See also <Ref Oper="GreensDClasses" BookName="ref"/>,
      <Ref Attr="GreensDClassReps"/>, and 
      <Ref Func="IteratorOfGreensDClasses"/>.
      <Example></Example>    
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensXClassOfElementNC">
  <ManSection><Heading>GreensXClassOfElementNC</Heading>
    <Oper Name="GreensDClassOfElementNC" Arg="s, f"/>
    <Oper Name="GreensHClassOfElementNC" Arg="s, f"/>
    <Oper Name="GreensLClassOfElementNC" Arg="s, f"/>
    <Oper Name="GreensRClassOfElementNC" Arg="s, f"/>
    <Description>
      creates the <Math>\mathcal{R}</Math>-class, 
      <Math>\mathcal{D}</Math>-class, <Math>\mathcal{L}</Math>-
      class, or <Math>\mathcal{H}</Math>-class of the transformation <A>f</A> 
      in the transformation semigroup <A>s</A> after checking if <A>f</A> has 
      already been shown to be an element of <A>s</A> or not. Note that if it 
      is not known to &GAP; if <A>f</A> is an element of <A>s</A> or not, then 
      no further attempt to verify if <A>f</A> is in <A>s</A> is made. 

      It can be quicker to compute to compute the class of an element using 
      <C>GreensRClassOfElementNC</C>, say, than using 
      <Ref Oper="GreensRClassOfElement" BookName="ref"/> 
      if it is known <E>a priori</E> that <A>f</A> 
      is an element of <A>s</A>. On the other
      hand, if <A>f</A> is not an element of <A>s</A>, then the results of this
      computation are unpredictable.<P/> 

      For example, if <Log>f:=Transformation( [ 15, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
      20, 20, 20, 20, 20, 20 ] );</Log>
      in the semigroup <A>s</A> of order-preserving mappings on 20 points, then
      <Log>GreensRClassOfElementNC(s, f);;</Log>
      returns an answer relatively quickly, whereas 
      <Ref Oper="GreensRClassOfElement" BookName="ref"/>
      can take a signficant amount of time and memory to return a value. 
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="GreensXClassReps">
  <ManSection><Heading>GreensXClassReps</Heading>
    <Attr Name="GreensDClassReps" Arg="x"/>
    <Attr Name="GreensHClassReps" Arg="x"/>
    <Attr Name="GreensLClassReps" Arg="x"/>
    <Attr Name="GreensRClassReps" Arg="x"/>
    <Description>
      returns a list of representatives of <Math>\mathcal{X}</Math>-classes of
      the object <A>x</A> where <A>x</A> can be a transformation semigroup,
      <Math>\mathcal{D}</Math>-, <Math>\mathcal{L}</Math>-, or
      <Math>\mathcal{R}</Math>-class.<P/>

      The same output can be obtained by calling, for example:
      <Log>List(GreensXClasses(x), Representative);</Log>

      Note that if the <Math>\mathcal{X}</Math>-classes themselves are not 
      required, then 
      <C>GreensXClassReps</C> will return an answer more quickly 
      than the above, since the <Math>\mathcal{X}</Math>-class 
      objects are not created.
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="Idempotents">
  <ManSection><Attr Name="Idempotents" Arg="x[,n]"/>
  <Description>
  returns a list of the idempotents in the transformation semigroup or Green's 
  class <A>x</A>. <P/>

  If the optional second argument <A>n</A> is present and <A>x</A> is a
  transformation semigroup, then a list of the 
  idempotents in <A>x</A> of rank <A>n</A> is returned. If you are only 
  interested in the idempotents of a given rank, then the second version of the 
  function will likely be faster. However, if the optional second argument is
  present, then nothing is stored in <A>x</A> and so every time the function
  is called the computation must be repeated. 
  
  <Example>
  gap> s:=Semigroup([ Transformation( [ 2, 3, 4, 1 ] ), 
   > Transformation( [ 3, 3, 1, 1 ] ) ]);;
  gap> Idempotents(s, 1);
  [  ]
  gap> Idempotents(s, 2);                        
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 3, 3, 1 ] ), 
    Transformation( [ 2, 2, 4, 4 ] ), Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> Idempotents(s);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 1, 2, 3, 4 ] ), 
    Transformation( [ 1, 3, 3, 1 ] ), Transformation( [ 2, 2, 4, 4 ] ), 
    Transformation( [ 4, 2, 2, 4 ] ) ]
  gap> f:=Transformation( [ 2, 2, 4, 4 ] );;
  gap> r:=RClass(s, f);
  {Transformation( [ 3, 3, 1, 1 ] )}
  gap> Idempotents(r);
  [ Transformation( [ 1, 1, 3, 3 ] ), Transformation( [ 2, 2, 4, 4 ] ) ]
  </Example> 
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsGreensClassOfTransSemigp">
  <ManSection><Prop Name="IsGreensClassOfTransSemigp" Arg="x"/>
  <Description>
  returns <K>true</K> if <A>x</A> is a Green's class of a transformation 
  semigroup and returns <K>false</K> otherwise.<P/>
  
  This attribute is required so that a Green's class knowns that it belongs to 
  a transformation semigroup, so that the methods defined in the
  <Package>Citrus</Package> are used in preference to those in the library.
  <Example>
    gap> s:=Semigroup(Transformation( [ 2, 1, 4, 5, 6, 3 ] ), 
    > Transformation( [ 2, 3, 1, 5, 4, 1 ] ));;
    gap> GreensLClassOfElement(s, a);
    {Transformation( [ 2, 1, 4, 5, 6, 3 ] )}
    gap> IsGreensClassOfTransSemigp(last);
    true
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsRegularXClass">
  <ManSection><Heading>IsRegularXClass</Heading>
    <Prop Name="IsRegularDClass" Arg="x"/>
    <Prop Name="IsRegularLClass" Arg="x"/>
    <Prop Name="IsRegularRClass" Arg="x"/>
    <Description>
      return <K>true</K> if the Green's class <A>x</A> of a transformation
      semigroup is regular (i.e. it contains an idempotent) and returns 
      <K>false</K> otherwise.<P/>

      See also <Ref Prop="IsRegularDClass" BookName="ref"/>.

      <Example>
gap> s:=Monoid(Transformation( [ 10, 8, 7, 4, 1, 4, 10, 10, 7, 2 ] ),
> Transformation( [ 5, 2, 5, 5, 9, 10, 8, 3, 8, 10 ] ));;
gap> f:=Transformation( [ 1, 1, 10, 8, 8, 8, 1, 1, 10, 8 ] );;
gap> r:=RClass(s, f);;
gap> IsRegularRClass(r);
true
gap> h:=HClass(s, f);;
gap> IsRegularRClass(h);
gap> f:=Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] );;
gap> s:=Monoid(Transformation([2,3,4,5,1,8,7,6,2,7]), 
> Transformation( [ 3, 8, 7, 4, 1, 4, 3, 3, 7, 2 ] ));;
gap> r:=RClass(s, f);;
gap> IsRegularRClass(r);
false
gap> NrIdempotents(r);
0</Example>
    </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IteratorOfXClassReps">
  <ManSection><Heading>IteratorOfXClassReps</Heading>
  <Func Name="IteratorOfDClassReps" Arg="x"/>
  <Func Name="IteratorOfHClassReps" Arg="x"/>
  <Func Name="IteratorOfLClassReps" Arg="x"/>
  <Func Name="IteratorOfRClassReps" Arg="x"/>
  <Description>
  returns an iterator of the representatives of the Green's classes contained
  in <A>x</A> where <A>x</A> can be a transformation
  semigroup, <Math>\mathcal{D}</Math>-, <Math>\mathcal{L}</Math>-, or
  <Math>\mathcal{R}</Math>-class of a transformation semigroup (where
  appropriate).    
  See <Ref Sect="Iterators" BookName="ref"/> for more
  information on iterators.<P/>

  See also <Ref Oper="GreensRClasses" BookName="ref"/>, 
  <Ref Oper="GreensRClasses"/>, 
  and <Ref Oper="IteratorOfGreensRClasses"/>.<P/>
  
  In the display of an <C>IteratorOfXClassReps</C> the total number of elements
  in the orbit of the semigroup acting on itself on the left is given (every
  <Math>\mathcal{R}</Math>-class representative occurs in this orbit), the
  number of elements of the semigroup that have so far been computed is given,
  and the number of distinct <Math>\mathcal{R}</Math>-classes that have been
  found is given. Note that 
  these numbers depend on the state of the semigroup and not of the 
  iterator.
  <P/>
  
  <Example>
gap> gens:=[ Transformation( [ 3, 2, 1, 5, 4 ] ), 
> Transformation( [ 5, 4, 3, 2, 1 ] ), 
> Transformation( [ 5, 4, 3, 2, 1 ] ), Transformation( [ 5, 5, 4, 5, 1 ] ), 
> Transformation( [ 4, 5, 4, 3, 3 ] ) ];;
gap> s:=Semigroup(gens);;
gap> iter:=IteratorOfRClassReps(s);
&lt;iterator of R-class reps, 6 candidates, 0 elements, 0 R-classes>
gap> NextIterator(iter);
Transformation( [ 1, 2, 3, 4, 5 ] )
gap> NextIterator(iter);
Transformation( [ 5, 5, 4, 5, 1 ] )
gap> iter;
&lt;iterator of R-class reps, 10 candidates, 20 elements, 2 R-classes>
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="IteratorOfGreensXClasses">
  <ManSection><Heading>IteratorOfGreensXClasses</Heading>
  <Func Name="IteratorOfGreensDClasses" Arg="x"/>
  <Func Name="IteratorOfGreensHClasses" Arg="x"/>
  <Func Name="IteratorOfGreensLClasses" Arg="x"/>
  <Func Name="IteratorOfGreensRClasses" Arg="x"/>
  <Description>
  returns an iterator of the Green's classes in <A>x</A> where
  <A>x</A> can be a transformation
    semigroup, <Math>\mathcal{D}</Math>-, <Math>\mathcal{L}</Math>-, or
      <Math>\mathcal{R}</Math>-class of a transformation semigroup (where
        appropriate).
  See <Ref Sect="Iterators" BookName="ref"/> for more information on
  iterators.<P/>

  This function is useful if you are, for example, looking for an
  <Math>\mathcal{R}</Math>-class of
  semigroup with a particular property but do not necessarily want to compute
  all of the <Math>\mathcal{R}</Math>-classes.<P/>

  See also <Ref Oper="GreensRClasses" BookName="ref"/> and 
  <Ref Oper="IteratorOfRClassReps"/>.<P/>

  The semigroup in the example below has 25147892 elements but it only takes 
  a fraction of a second to find a non-trivial <Math>R</Math>-class. <P/>

  <Example>
gap> gens:=[ Transformation( [ 2, 4, 1, 5, 4, 4, 7, 3, 8, 1 ] ),
>   Transformation( [ 3, 2, 8, 8, 4, 4, 8, 6, 5, 7 ] ),
>   Transformation( [ 4, 10, 6, 6, 1, 2, 4, 10, 9, 7 ] ),
>   Transformation( [ 6, 2, 2, 4, 9, 9, 5, 10, 1, 8 ] ),
>   Transformation( [ 6, 4, 1, 6, 6, 8, 9, 6, 2, 2 ] ),
>   Transformation( [ 6, 8, 1, 10, 6, 4, 9, 1, 9, 4 ] ),
>   Transformation( [ 8, 6, 2, 3, 3, 4, 8, 6, 2, 9 ] ),
>   Transformation( [ 9, 1, 2, 8, 1, 5, 9, 9, 9, 5 ] ),
>   Transformation( [ 9, 3, 1, 5, 10, 3, 4, 6, 10, 2 ] ),
>   Transformation( [ 10, 7, 3, 7, 1, 9, 8, 8, 4, 10 ] ) ];;
gap> s:=Semigroup(gens);;
gap> iter:=IteratorOfGreensRClasses(s);
&lt;iterator of R-classes>
gap> for r in iter do
> if Size(r)>1 then break; fi;
> od;
gap> r;
{Transformation( [ 6, 4, 1, 6, 6, 8, 9, 6, 2, 2 ] )}
gap> Size(r);
21600</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrGreensXClasses">
  <ManSection><Heading>NrGreensXClasses</Heading>
  <Attr Name="NrGreensDClasses" Arg="x"/>
  <Attr Name="NrGreensHClasses" Arg="x"/>
  <Attr Name="NrGreensLClasses" Arg="x"/>
  <Attr Name="NrGreensRClasses" Arg="x"/>
  <Description>
  returns the number of Green's classes in <A>x</A> where
    <A>x</A> can be a transformation
        semigroup, <Math>\mathcal{D}</Math>-, <Math>\mathcal{L}</Math>-, or
              <Math>\mathcal{R}</Math>-class of a transformation semigroup
              (where
                      appropriate).

  If the actual Green's classes are not required, then it is  
  more efficient to use <Log>NrGreensHClasses(x)</Log> than 
  <Log>Length(GreensHClasses)(x)</Log> 
  since the classes themselves are not created when <C>NrGreensXClasses</C> is
  called. 
  
  <Example>
gap> gens:=[ Transformation( [ 1, 2, 5, 4, 3, 8, 7, 6 ] ),
>   Transformation( [ 1, 6, 3, 4, 7, 2, 5, 8 ] ),
>   Transformation( [ 2, 1, 6, 7, 8, 3, 4, 5 ] ),
>   Transformation( [ 3, 2, 3, 6, 1, 6, 1, 2 ] ),
>   Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] ) ];;
gap> s:=Semigroup(gens);;
gap> f:=Transformation( [ 2, 5, 4, 7, 4, 3, 6, 3 ] );;
gap> r:=RClass(s, f);
{Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
gap> NrGreensHClasses(r);
12
gap> d:=DClass(r);
{Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
gap> NrGreensHClasses(d);
72
gap> l:=LClass(s, f);
{Transformation( [ 5, 2, 3, 6, 3, 4, 7, 4 ] )}
gap> NrGreensHClasses(l);
6 
gap> NrGreensHClasses(s);
1555
gap> gens:=[ Transformation( [ 4, 6, 5, 2, 1, 3 ] ),
>   Transformation( [ 6, 3, 2, 5, 4, 1 ] ),
>   Transformation( [ 1, 2, 4, 3, 5, 6 ] ),
>   Transformation( [ 3, 5, 6, 1, 2, 3 ] ),
>   Transformation( [ 5, 3, 6, 6, 6, 2 ] ),
>   Transformation( [ 2, 3, 2, 6, 4, 6 ] ),
>   Transformation( [ 2, 1, 2, 2, 2, 4 ] ),
>   Transformation( [ 4, 4, 1, 2, 1, 2 ] ) ];;
gap> s:=Semigroup(gens);;
gap> NrGreensRClasses(s);
150
gap> Size(s);
6342
gap> f:=Transformation( [ 1, 3, 3, 1, 3, 5 ] );;
gap> d:=DClass(s, f);
{Transformation( [ 4, 1, 1, 4, 1, 2 ] )}
gap> NrGreensRClasses(d);
87</Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrIdempotents">
  <ManSection><Attr Name="NrIdempotents" Arg="x"/>
  <Description>
  returns the number of idempotents in <A>x</A> where
    <A>x</A> can be a transformation
        semigroup, <Math>\mathcal{D}</Math>-, <Math>\mathcal{L}</Math>-, or
              <Math>\mathcal{R}</Math>-class of a transformation semigroup
              (where
                      appropriate).
 If the actual idempotents are not required, then it
  is more efficient to use <Log>NrIdempotents(x)</Log> than <Log>Length(Idempotents(x))</Log>
  since the idempotents themselves are not created when <C>NrIdempotents</C>
  is called.

  <Example>
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="NrRegularDClasses">
  <ManSection><Attr Name="NrRegularDClasses" Arg="s"/>
    <Description>
    returns the number of regular <Math>\mathcal{D}</Math>-classes of the 
    transformation semigroup <A>s</A>. <P/>
    
    See also <Ref Func="IsRegularDClass"/> and <Ref Func="IsRegularDClass"
    BookName="ref"/>.
    <Example></Example>
    </Description>
    </ManSection>
<#/GAPDoc>

<#GAPDoc Label="PartialOrderOfDClasses">
  <ManSection>
  <Attr Name="PartialOrderOfDClasses" Arg="s"/>
  <Description>
  returns a list <C>l</C> where <C>j</C> is in <C>l[i]</C> if and only if 
  <C>GreensDClasses(s)[j]</C> is immediately less than 
  <C>GreensDClasses(s)[i]</C> in the partial order of <Math>\mathcal{D}</Math>-
  classes of <A>s</A>.
  The transitive closure of the relation <Math>\{\:(j,i):\:\: j\in
  l[i]\:\}</Math> is the partial order of <Math>\mathcal{D}</Math>-classes. <P/>

  The partial order on the <Math>\mathcal{D}</Math>-classes is defined by 
  <Math>x\leq y</Math> if and only if <C>s^1xs^1</C> is a subset of  
  <C>s^1ys^1</C>. <P/>

  See also <Ref Attr="GreensDClasses"/>, <Ref Attr="GreensDClasses"
  BookName="ref"/>, <Ref Oper="IsGreensLessThanOrEqual" BookName="ref"/>,
  and <Ref Oper="\&lt;"/>.
  </Description>
  </ManSection>
<#/GAPDoc>

<#GAPDoc Label="SchutzenbergerGroup">
  <ManSection><Attr Name="SchutzenbergerGroup" Arg="x"/>
  <Description>
  returns the generalized Schutzenberger group (defined below) of the 
  <Math>\mathcal{R}</Math>-, <Math>\mathcal{D}</Math>-, 
  <Math>\mathcal{L}</Math>-, or 
  <Math>\mathcal{H}</Math>-class <A>x</A> of a transformation semigroup.<P/>
  
  If <A>x</A> is an <Math>\mathcal{R}</Math>-class of a transformation 
  semigroup <C>s</C> with
  representative <C>f</C>, then
  <C>SchutzenbergerGroup(x)</C> is the permutation group 
  <Display>
    \{\:g|_{\textrm{im}(f)}\::\:\textrm{im}(f)^g=\textrm{im}(f)\:\}.
  </Display><P/>

  If <A>x</A> is an <Math>\mathcal{L}</Math>-class of a transformation
  semigroup <C>s</C> with
  representative <C>f</C>, then
  <C>SchutzenbergerGroup(x)</C> is the permutation group
  <Display>
    \{\:g|_{\textrm{ker}(f)}\::\:\ker(f)^g=\ker(f)\:\}.
  </Display><P/>

  If <A>x</A> is an <Math>\mathcal{H}</Math>-class of a transformation
  semigroup <C>s</C> with
  representative <C>f</C>, then <C>SchutzenbergerGroup(x)</C> is the 
  intersection of <C>SchutzenbergerGroup(RClass(s, f))</C> and
  <C>SchutzenbergerGroup(LClass(s, f))</C>. <P/>
  
  If <A>x</A> is a <Math>\mathcal{D}</Math>-class of a transformation semigroup 
  <C>s</C> with
  representative <C>f</C>, then <C>SchutzenbergerGroup(x)</C> is just 
  <C>SchutzenbergerGroup(HClass(s, f))</C>. <P/>
       
  For more details see Chapter <Ref Chap="glossary"/>, <Cite Key="pfeiffer1"/> 
  or <Cite Key="pfeiffer2"/>.<P/> 

  <Example>
    gap> s:=Semigroup([Transformation( [ 4, 4, 3, 5, 3 ] ), 
    > Transformation( [ 5, 1, 1, 4, 1 ] ), 
    > Transformation( [ 5, 5, 4, 4, 5 ] ));;
    gap> f:=Transformation( [ 4, 5, 5, 5, 5 ] );;
    gap> SchutzenbergerGroup(DClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(RClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(LClass(s, f));
    Group([ (4,5) ])
    gap> SchutzenbergerGroup(HClass(s, f));
    Group([ (4,5) ])
  </Example>
  </Description>
  </ManSection>
<#/GAPDoc>

#EOF
